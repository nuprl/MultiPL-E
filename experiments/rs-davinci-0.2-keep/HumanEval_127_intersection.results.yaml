name: HumanEval_127_intersection
language: rust
results:
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxtvlqjug.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len <= 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxea_q5cu.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpab7wuwe_.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjedf2gfj.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps5n5zcwg.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start >\
    \ end {\n        (end, start)\n    } else {\n        (start, end)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (start, end) = if start > end {\n      \
    \  (end, start)\n    } else {\n        (start, end)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    let (start, end) = if start > end\
    \ {\n        (end, start)\n    } else {\n        (start, end)\n    };\n    let\
    \ (start, end) = if start > end {\n        (end, start)\n    } else {\n      \
    \  (start, end)\n    };\n    let (start, end) = if start > end {\n        (end,\
    \ start)\n    } else {\n        (start, end)\n    };\n    let (start, end) = if\
    \ start > end {\n        (end, start)\n    } else {\n        (start, end)\n  \
    \  };\n    let (start, end) = if start > end {\n        (end, start)\n    } else\
    \ {\n        (start, end)\n    };\n    let (start, end) = if start > end {\n \
    \       (end, start)\n    } else {\n        (start, end)\n    };\n    let (start,\
    \ end) = if start > end {\n        (end, start\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3yfrt13_.rs:99:3\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     let (start, end) =\
    \ if start > end {\n   |                                       - this delimiter\
    \ might not be properly closed...\n86 |         (end, start\n87 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmp3yfrt13_.rs:89:1\n   |\n87 | }\n   |  - expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n88 | \n89 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3yfrt13_.rs:86:9\n \
    \  |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - closing delimiter possibly meant for this\n...\n86 |\
    \         (end, start\n   |         ^ unclosed delimiter\n87 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c { (a, b) } else { (c, d) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmperhqq9yu.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzcdz4mlh.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut result = \"NO\";\n    if a <= c && c <= b {\n        if d <= b {\n\
    \            result = if (d - c).abs() == 1 { \"YES\" } else { \"NO\" };\n   \
    \     } else {\n            result = if (b - c).abs() == 1 { \"YES\" } else {\
    \ \"NO\" };\n        }\n    } else if c <= a && a <= d {\n        if b <= d {\n\
    \            result = if (b - a).abs() == 1 { \"YES\" } else { \"NO\" };\n   \
    \     } else {\n            result = if (d - a).abs() == 1 { \"YES\" } else {\
    \ \"NO\" };\n        }\n    }\n    result.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy1rny3_r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0frt4r0i.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptvg2zq4g.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (mut\
    \ start, mut end) = (a, b);\n    if c > a {\n        start = c;\n    }\n    if\
    \ d < b {\n        end = d;\n    }\n    let len = end - start + 1;\n    if len\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n\
    \        if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzqt57mgc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpa85uo0ks.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = (end - start + 1) as usize;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(length) {\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjjpwysns.rs:29:8\n\
    \   |\n29 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start <\
    \ 0 {\n        (0, end)\n    } else {\n        (start, end)\n    };\n    let mut\
    \ length = end - start;\n    if length == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    length += 1;\n    let mut is_prime = true;\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            is_prime = false;\n           \
    \ break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n \
    \   } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmwc5msml.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpna2mrleo.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = std::cmp::max(start1, start2);\n   \
    \ let mut end = std::cmp::min(end1, end2);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if start == end {\n        return \"YES\".to_string();\n\
    \    }\n    while start < end {\n        if end % start == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n        start += 1;\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjtbsp5ai.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1.max(start2);\n    let mut end\
    \ = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if start == end {\n        return \"YES\".to_string();\n    }\n  \
    \  while start < end {\n        if end % start == 0 {\n            return \"NO\"\
    .to_string();\n        }\n        start += 1;\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmk2kbqcg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5_0qmbgf.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpskautjx1.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut count = 0;\n\
    \    for i in start..=end {\n        count += 1;\n    }\n    if is_prime(count)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmphtqq33ps.rs:32:8\n\
    \   |\n32 |     if is_prime(count) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len < 2 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgaxpoymt.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpi7orl5qd.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 2 {\n    \
    \    return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcycsc8ro.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm3z8sqyi.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp33gofcya.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > b || c > d {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ start = a;\n    let mut end = b;\n    if c > a {\n        start = c;\n    }\n\
    \    if d < b {\n        end = d;\n    }\n    if start >= end {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = end - start + 1;\n    if len == 1\
    \ {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqm8aqr2s.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuqe3ay_a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start <= end {\n        let len = end - start + 1;\n\
    \        if len == 2 {\n            return \"YES\".to_string();\n        }\n \
    \       for i in 2..len {\n            if len % i == 0 {\n                return\
    \ \"NO\".to_string();\n            }\n        }\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7c0_v32e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl7zs0b15.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if start > end {\n        start = interval1.1;\n        end = interval1.0;\n\
    \    }\n    let (mut start2, mut end2) = (interval2.0, interval2.1);\n    if start2\
    \ > end2 {\n        start2 = interval2.1;\n        end2 = interval2.0;\n    }\n\
    \    if start > end2 || start2 > end {\n        return \"NO\".to_string();\n \
    \   }\n    if start2 > start {\n        start = start2;\n    }\n    if end2 <\
    \ end {\n        end = end2;\n    }\n    if start == end {\n        return \"\
    NO\".to_string();\n    }\n    if is_prime(end - start) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpcm6nx4we.rs:40:8\n\
    \   |\n40 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    if start == end {\n        return\
    \ \"YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..end\
    \ {\n        if end % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8fen_2l8.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n    let end\
    \ = end1.min(end2);\n    let length = end - start + 1;\n    if length < 2 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvxd_hv6c.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpedrubtx4.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpudlda_ys.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp692iy19d.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let mut start = i1_start;\n    let mut\
    \ end = i1_end;\n    if i1_start > i2_start {\n        start = i2_start;\n   \
    \ }\n    if i1_end < i2_end {\n        end = i2_end;\n    }\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let length = end - start +\
    \ 1;\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy8rqbjix.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmxcetthi.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start == 0 || end == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpiil9h_oc.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkq1p197m.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4sa36uzb.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let diff = (end - start) as usize;\n\
    \    if diff == 0 {\n        return \"NO\".to_string();\n    }\n    if diff ==\
    \ 1 {\n        return \"YES\".to_string();\n    }\n    if diff == 2 {\n      \
    \  return \"NO\".to_string();\n    }\n    if diff % 2 == 0 {\n        return \"\
    NO\".to_string();\n    }\n    for i in (3..diff).step_by(2) {\n        if diff\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpovwz4y8s.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n\
    \        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0k63d4wf.rs:31:8\n\
    \   |\n31 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start >= end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpm5r4lx0i.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let diff = end - start;\n\
    \    if diff == 1 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..diff {\n        if diff % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxjaloi3l.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let diff\
    \ = end - start;\n    if diff == 0 {\n        return \"NO\".to_string();\n   \
    \ }\n    if diff == 1 {\n        return \"YES\".to_string();\n    }\n    for i\
    \ in 2..diff {\n        if diff % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpskxhlow8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmppnny7ayr.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if start == end {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(end - start) {\n        return \"\
    YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvgdxyvh2.rs:28:8\n\
    \   |\n28 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8n0o9lgu.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_wnfb33j.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyfwz356j.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp624ytgzt.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start1 > start2 {\n        start = start2;\n    }\n    if end1 < end2 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..length {\n        if length\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp07qpurqi.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5p0912j2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpibuqn_o2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (start,\
    \ end) = if a > c { (a, b) } else { (c, d) };\n    let length = end - start +\
    \ 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    if length % 2\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    for i in 3..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_fb6lm5c.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvlivxjyc.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a < c {\n        (c, b.min(d))\n    } else {\n    \
    \    (a, d.min(b))\n    };\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len <= 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpo4y7kffb.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptcws29ns.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = isize::max(start1, start2);\n    let end\
    \ = isize::min(end1, end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgn9m1_lt.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if c > a {\n        start =\
    \ c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwy0qgw45.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_w2h7vbw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjgoog3en.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start <= end {\n        if is_prime(end - start +\
    \ 1) {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2rl0j75f.rs:32:12\n\
    \   |\n32 |         if is_prime(end - start + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let length\
    \ = (end - start) + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpu7uxi2_c.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyapj_ess.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1.max(start2);\n    let mut end\
    \ = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if start == end {\n        return \"YES\".to_string();\n    }\n  \
    \  while start < end {\n        start += 1;\n        if is_prime(start) {\n  \
    \          return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpg26anmiu.rs:30:12\n\
    \   |\n30 |         if is_prime(start) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (start,\
    \ end) = if a > c { (a, b) } else { (c, d) };\n    let mut n = end - start;\n\
    \    if n == 1 {\n        return \"NO\".to_string();\n    }\n    n -= 1;\n   \
    \ for i in 2..n {\n        if n % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpur1oq7uv.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpo853snhr.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..length {\n        if length % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3d856zkm.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut intersection = (0, 0);\n    if a <= c && c <= b {\n        intersection.0\
    \ = c;\n    } else if c <= a && a <= d {\n        intersection.0 = a;\n    }\n\
    \    if b <= d && d <= c {\n        intersection.1 = b;\n    } else if d <= b\
    \ && b <= c {\n        intersection.1 = d;\n    }\n    if intersection.0 == 0\
    \ || intersection.1 == 0 {\n        return \"NO\".to_string();\n    }\n    let\
    \ length = (intersection.1 - intersection.0) + 1;\n    if length <= 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"\
    YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i ==\
    \ 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpd08ekq1c.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfozoagug.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk95qwwqc.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start >\
    \ end {\n        (end, start)\n    } else {\n        (start, end)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (start, end) = if start > end {\n      \
    \  (end, start)\n    } else {\n        (start, end)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    let (start, end) = if start > end\
    \ {\n        (end, start)\n    } else {\n        (start, end)\n    };\n    let\
    \ (start, end) = if start > end {\n        (end, start)\n    } else {\n      \
    \  (start, end)\n    };\n    let (start, end) = if start > end {\n        (end,\
    \ start)\n    } else {\n        (start, end)\n    };\n    let (start, end) = if\
    \ start > end {\n        (end, start)\n    } else {\n        (start, end)\n  \
    \  };\n    let (start, end) = if start > end {\n        (end, start)\n    } else\
    \ {\n        (start, end)\n    };\n    let (start, end) = if start > end {\n \
    \       (end, start)\n    } else {\n        (start, end)\n    };\n    let (start,\
    \ end) = if start > end {\n        (end, start\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzmhl0_a1.rs:99:3\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     let (start, end) =\
    \ if start > end {\n   |                                       - this delimiter\
    \ might not be properly closed...\n86 |         (end, start\n87 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmpzmhl0_a1.rs:89:1\n   |\n87 | }\n   |  - expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n88 | \n89 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpzmhl0_a1.rs:86:9\n \
    \  |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - closing delimiter possibly meant for this\n...\n86 |\
    \         (end, start\n   |         ^ unclosed delimiter\n87 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if start > end {\n        std::mem::swap(&mut start, &mut end);\n    }\n\
    \    let (mut start2, mut end2) = (interval2.0, interval2.1);\n    if start2 >\
    \ end2 {\n        std::mem::swap(&mut start2, &mut end2);\n    }\n    if start\
    \ > end2 || start2 > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ (mut start, mut end) = (start.max(start2), end.min(end2));\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    if start == end {\n      \
    \  return \"YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i\
    \ in 2..(end - start) {\n        if (end - start) % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpze89mska.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfuz22ent.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start >\
    \ end {\n        (end, start)\n    } else {\n        (start, end)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (start, end) = if start > end {\n      \
    \  (end, start)\n    } else {\n        (start, end)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    let (start, end) = if start > end\
    \ {\n        (end, start)\n    } else {\n        (start, end)\n    };\n    let\
    \ (start, end) = if start > end {\n        (end, start)\n    } else {\n      \
    \  (start, end)\n    };\n    let (start, end) = if start > end {\n        (end,\
    \ start)\n    } else {\n        (start, end)\n    };\n    let (start, end) = if\
    \ start > end {\n        (end, start)\n    } else {\n        (start, end)\n  \
    \  };\n    let (start, end) = if start > end {\n        (end, start)\n    } else\
    \ {\n        (start, end)\n    };\n    let (start, end) = if start > end {\n \
    \       (end, start)\n    } else {\n        (start, end)\n    };\n    let (start,\
    \ end) = if start > end {\n        (end, start\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_cls81m0.rs:99:3\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     let (start, end) =\
    \ if start > end {\n   |                                       - this delimiter\
    \ might not be properly closed...\n86 |         (end, start\n87 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmp_cls81m0.rs:89:1\n   |\n87 | }\n   |  - expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n88 | \n89 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_cls81m0.rs:86:9\n \
    \  |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - closing delimiter possibly meant for this\n...\n86 |\
    \         (end, start\n   |         ^ unclosed delimiter\n87 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ x = c;\n    if a > x {\n        x = a;\n    }\n    let mut y = d;\n    if b\
    \ < y {\n        y = b;\n    }\n    if x > y {\n        return \"NO\".to_string();\n\
    \    }\n    let mut n = y - x + 1;\n    if n == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpoft21lqx.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if c > a {\n        start =\
    \ c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp17o81ci4.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let mut intersection = (0, 0);\n    if\
    \ i1_start <= i2_start && i2_start <= i1_end {\n        intersection.0 = i2_start;\n\
    \    } else if i2_start <= i1_start && i1_start <= i2_end {\n        intersection.0\
    \ = i1_start;\n    }\n    if i1_start <= i2_end && i2_end <= i1_end {\n      \
    \  intersection.1 = i2_end;\n    } else if i2_start <= i1_end && i1_end <= i2_end\
    \ {\n        intersection.1 = i1_end;\n    }\n    if intersection.0 == 0 && intersection.1\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let length = intersection.1\
    \ - intersection.0;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxbg7hly7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9vh4nrxi.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n    let end\
    \ = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..end {\n        if end %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpflot_5x5.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpp_axyluz.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len <= 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1i0utwz2.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpevcbf7tc.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl48mso8y.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmmu2omr8.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let mut start = i1_start;\n    let mut\
    \ end = i1_end;\n    if i1_start > i2_start {\n        start = i2_start;\n   \
    \ }\n    if i1_end < i2_end {\n        end = i2_end;\n    }\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2jhmfber.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpsjwwbi5r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len <= 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2zjfkq6w.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if is_prime(len) {\n\
    \        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmph94ywfq8.rs:26:8\n\
    \   |\n26 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start == 0 || end == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpky1wcd0a.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            is_prime = false;\n  \
    \          break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpeyzzszt0.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (start,\
    \ end) = if a > c { (a, b) } else { (c, d) };\n    let length = end - start +\
    \ 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp25rx2lxs.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let len\
    \ = end - start + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp859k2jys.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut x = 0;\n    if a <= c && c <= b {\n        x = b - c + 1;\n    }\
    \ else if c <= a && a <= d {\n        x = d - a + 1;\n    }\n    if x == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    if x == 1 {\n        return \"\
    NO\".to_string();\n    }\n    if x == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= x {\n        if x % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1vdxar23.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    if len <= 2 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpn25xnbau.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    let\
    \ mut i = 2;\n    while i * i <= len {\n        if len % i == 0 {\n          \
    \  return \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmg26sfmf.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    for i in 2..length {\n       \
    \ if length % i == 0 {\n            return \"NO\".to_string();\n        }\n  \
    \  }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuebuqnp4.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkz6i09s7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > b || c > d {\n        return \"NO\".to_string();\n    }\n    if a\
    \ > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut start\
    \ = a;\n    let mut end = b;\n    if c > a {\n        start = c;\n    }\n    if\
    \ d < b {\n        end = d;\n    }\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy91efegg.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start == 0 || end == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start;\n    if len < 2 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmp3r6dzzj8.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len < 2 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpp2dlfmup.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7e5tznks.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwe8wthnd.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let length = (end -\
    \ start) + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n   \
    \ }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl7w6egjk.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpze9mkozt.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length < 2 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp71rv2l_g.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp829ehj1z.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..end\
    \ {\n        if end % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpacbmf64q.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 2 {\n    \
    \    return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_0swmju1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmprn8jag7r.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpewyqypl_.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmponarkupp.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpps0mb09t.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len < 2 {\n        return \"NO\".to_string();\n    }\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3v3or4f6.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = max(start1, start2);\n    let end = min(end1,\
    \ end2);\n    if start > end {\n        return \"NO\".to_string();\n    }\n  \
    \  let len = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpo6q_75ol.rs:20:17\n\
    \   |\n20 |     let start = max(start1, start2);\n   |                 ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmpo6q_75ol.rs:21:15\n   |\n21 |     let end = min(end1, end2);\n\
    \   |               ^^^\n...\n40 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n21 |     let end = main(end1, end2);\n   |               ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmprwo3qm8b.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ intersection = (a, b);\n    if a < c {\n        intersection.0 = c;\n    }\n\
    \    if b > d {\n        intersection.1 = d;\n    }\n    let len = intersection.1\
    \ - intersection.0 + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_hozy918.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let len\
    \ = (end - start) + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp10b3tt33.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk77z02yu.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if len % 2 == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ for i in 3..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpj7ueodfk.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmphily8cmo.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c { (a, b) } else { (c, d) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > b || start > d { (0, 0) } else { (start, end) };\n    let\
    \ (start, end) = if end < a || end < c { (0, 0) } else { (start, end) };\n   \
    \ let length = end - start;\n    if length == 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        let is_prime = (2..length).all(|x| length % x != 0);\n\
    \        if is_prime {\n            \"YES\".to_string()\n        } else {\n  \
    \          \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpv6rn_1ne.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    if start == end {\n        return\
    \ \"YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..end\
    \ {\n        if end % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfk69umg1.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a < c {\n        start = c;\n\
    \    } else {\n        start = a;\n    }\n    if b < d {\n        end = b;\n \
    \   } else {\n        end = d;\n    }\n    if start > end {\n        return \"\
    NO\".to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpprfweqbp.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkscbnrj2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpa1vxqbgt.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = if start1 > start2 {\n        (start1,\
    \ end2)\n    } else {\n        (start2, end1)\n    };\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n \
    \   if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvka47d_o.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = std::cmp::max(start1, start2);\n   \
    \ let mut end = std::cmp::min(end1, end2);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if start == end {\n        return \"YES\".to_string();\n\
    \    }\n    if start == 1 {\n        start += 1;\n    }\n    for i in start..end\
    \ {\n        if is_prime(i) {\n            return \"YES\".to_string();\n     \
    \   }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpz31ctuto.rs:32:12\n\
    \   |\n32 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len <= 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg4i6da4w.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5hcjcpjw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5ovgns10.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6tvpg35o.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0rwcs4bz.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start >= end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 2 {\n    \
    \    return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk14ucwmo.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = interval1.0;\n    let mut end\
    \ = interval1.1;\n    if interval2.0 > start {\n        start = interval2.0;\n\
    \    }\n    if interval2.1 < end {\n        end = interval2.1;\n    }\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq8jqrwgu.rs:29:8\n\
    \   |\n29 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6sweemen.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvq9blxw8.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (a, b) = interval1;\n   \
    \ let (c, d) = interval2;\n    let (start, end) = if a < c {\n        (a, b)\n\
    \    } else {\n        (c, d)\n    };\n    let (start, end) = if start > end {\n\
    \        (end, start)\n    } else {\n        (start, end)\n    };\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut count = 0;\n\
    \    for i in start..end + 1 {\n        count += 1;\n    }\n    if count == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..count {\n   \
    \     if count % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_q3tbz9t.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (mut\
    \ start, mut end) = (a, b);\n    if c > a {\n        start = c;\n    }\n    if\
    \ d < b {\n        end = d;\n    }\n    let len = end - start + 1;\n    if len\
    \ <= 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len {\n \
    \       if len % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4y0svvpe.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start2, end2) = if a < c {\n        (a, b)\n    } else\
    \ {\n        (c, d)\n    };\n    if start > end2 || end < start2 {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = if start > start2 {\n        start\
    \ - start2\n    } else {\n        start2 - start\n    };\n    if len == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..len {\n        if len % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6mi1xp67.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp03zqbtie.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwfrh_nfh.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp10zmxdjo.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzh4tggwj.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0euqs6lg.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    if start == end {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..start {\n        if start\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..end {\n        if end % i == 0 {\n            is_prime = false;\n  \
    \          break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..(end - start) {\n        if (end - start)\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpnn0gnl_0.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > b || c > d {\n        return \"NO\".to_string();\n    }\n    if a\
    \ > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut start\
    \ = a;\n    let mut end = b;\n    if a < c {\n        start = c;\n    }\n    if\
    \ b > d {\n        end = d;\n    }\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl8xgom9a.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let length = end - start + 1;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmphxo6llh8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a < c {\n        (c, b)\n    } else {\n        (a,\
    \ d)\n    };\n    if start > end {\n        return \"NO\".to_string();\n    }\n\
    \    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpyrp_s9gx.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1.max(start2);\n    let mut end\
    \ = end1.min(end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if start == end {\n        return \"YES\".to_string();\n    }\n  \
    \  while start <= end {\n        if is_prime(start) {\n            return \"YES\"\
    .to_string();\n        }\n        start += 1;\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjoo5yiej.rs:29:12\n\
    \   |\n29 |         if is_prime(start) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(end - start + 1) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzrdqow4q.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (max(start1, start2), min(end1, end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpvof1syck.rs:20:25\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpvof1syck.rs:20:46\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n36 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n20 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = interval1.0;\n    let mut end\
    \ = interval1.1;\n    if interval2.0 > start {\n        start = interval2.0;\n\
    \    }\n    if interval2.1 < end {\n        end = interval2.1;\n    }\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    let length = end\
    \ - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n   \
    \ }\n    let mut is_prime = true;\n    for i in 2..length {\n        if length\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwnfcx3so.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut start = start1;\n    let mut end = end1;\n \
    \   if start2 > start1 {\n        start = start2;\n    }\n    if end2 < end1 {\n\
    \        end = end2;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n\
    \    for i in 3..length {\n        if length % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1om20780.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzkuv8y6a.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if len % 2 == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ for i in 3..len/2 {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3wop5x80.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmbguxpig.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if c > a {\n        start =\
    \ c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7zm1e860.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvw26ckf9.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c {\n        (a, b)\n    } else {\n        (c,\
    \ d)\n    };\n    let (start, end) = if start > end {\n        (end, start)\n\
    \    } else {\n        (start, end)\n    };\n    let (start, end) = if start >\
    \ 0 {\n        (start, end)\n    } else {\n        (0, end)\n    };\n    let (start,\
    \ end) = if end < 0 {\n        (start, 0)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > end {\n        (end, start)\n    }\
    \ else {\n        (start, end)\n    };\n    let (start, end) = if start == end\
    \ {\n        (start + 1, end)\n    } else {\n        (start, end)\n    };\n  \
    \  let (start, end) = if start > end {\n        (end, start)\n    } else {\n \
    \       (start, end)\n    };\n    let (start, end) = if start > 0 {\n        (start,\
    \ end)\n    } else {\n        (0, end)\n    };\n    let (start, end) = if end\
    \ < 0 {\n        (start, 0)\n    } else {\n        (start, end)\n    };\n    let\
    \ (start, end) = if start > end {\n        (end, start)\n    } else {\n      \
    \  (start, end)\n    };\n    let (start, end) = if start == end {\n        (start\
    \ + 1, end)\n    } else {\n        (start, end)\n    };\n    let (start, end)\
    \ = if start > end {\n        (end, start)\n    } else {\n        (start, end)\n\
    \    };\n    let (start, end) = if start > 0 {\n        (start, end)\n    } else\
    \ {\n        (0, end)\n    };\n    let (start, end) = if end < 0 {\n       \n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu0eimcfs.rs:99:3\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     let (start, end) =\
    \ if end < 0 {\n   |                                   - this delimiter might\
    \ not be properly closed...\n86 |        \n87 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n99 | }\n   |   ^\n\nerror: expected one\
    \ of `.`, `;`, `?`, `else`, or an operator, found keyword `fn`\n  --> /tmp/tmpu0eimcfs.rs:89:1\n\
    \   |\n87 | }\n   |  - expected one of `.`, `;`, `?`, `else`, or an operator\n\
    88 | \n89 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 2\
    \ previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp489nkggk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..length {\n        if length % i == 0 {\n \
    \           is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpan55za5o.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = (end - start + 1) as usize;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpaj4uwu2h.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if c > a {\n        start =\
    \ c;\n    }\n    if d < b {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n  \
    \  if len == 2 {\n        return \"YES\".to_string();\n    }\n    let mut i =\
    \ 2;\n    while i * i <= len {\n        if len % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4kt8fy9b.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let mut intersection = (0, 0);\n    if\
    \ i1_start <= i2_start && i2_start <= i1_end {\n        intersection.0 = i2_start;\n\
    \    } else if i2_start <= i1_start && i1_start <= i2_end {\n        intersection.0\
    \ = i1_start;\n    } else {\n        return \"NO\".to_string();\n    }\n    if\
    \ i1_start <= i2_end && i2_end <= i1_end {\n        intersection.1 = i2_end;\n\
    \    } else if i2_start <= i1_end && i1_end <= i2_end {\n        intersection.1\
    \ = i1_end;\n    } else {\n        return \"NO\".to_string();\n    }\n    let\
    \ length = intersection.1 - intersection.0;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpun9osrxx.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    if len == 2\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..len {\n     \
    \   if len % i == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpe1jotdo8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c { (a, b) } else { (c, d) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start >\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpn65qi_0z.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            is_prime = false;\n  \
    \          break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpudl62hxr.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4_0d9rfx.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    } else {\n \
    \       return \"NO\".to_string();\n    }\n    if b <= d && d <= b {\n       \
    \ end = b;\n    } else if d <= b && b <= d {\n        end = d;\n    } else {\n\
    \        return \"NO\".to_string();\n    }\n    if start == end {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut count = 0;\n    for i in start..=end\
    \ {\n        count += 1;\n    }\n    if count == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..count {\n        if count % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpmyeuth4y.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a < c {\n        if b < c {\n            return \"\
    NO\".to_string();\n        }\n        (c, b)\n    } else {\n        if d < a {\n\
    \            return \"NO\".to_string();\n        }\n        (a, d)\n    };\n \
    \   let len = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2vccjur7.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (start, end) = if a > c { (a, b) } else { (c, d) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start > end { (end, start) } else { (start, end) };\n    let (start,\
    \ end) = if start >\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpb52i_mad.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbin6hwtw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let mut count = 0;\n\
    \    for i in start..end + 1 {\n        if i == 1 {\n            continue;\n \
    \       }\n        let mut is_prime = true;\n        for j in 2..i {\n       \
    \     if i % j == 0 {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if is_prime {\n            count += 1;\n  \
    \      }\n    }\n    if count == 0 {\n        return \"NO\".to_string();\n   \
    \ }\n    let mut is_prime = true;\n    for i in 2..count {\n        if count %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpeffxc8xd.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > b || c > d {\n        return \"NO\".to_string();\n    }\n    let (mut\
    \ start, mut end) = (a, b);\n    if c > a {\n        start = c;\n    }\n    if\
    \ d < b {\n        end = d;\n    }\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..len {\n        if len % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0b8jt7ie.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len {\n  \
    \      if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpeqkhpm67.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let diff\
    \ = end - start;\n    if diff == 0 {\n        return \"NO\".to_string();\n   \
    \ }\n    if diff == 1 {\n        return \"YES\".to_string();\n    }\n    if diff\
    \ == 2 {\n        return \"NO\".to_string();\n    }\n    if diff % 2 == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    for i in 3..diff {\n        if\
    \ diff % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplo7yji_8.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbsnq3wqn.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = end - start + 1;\n    if len == 1 {\n    \
    \    return \"NO\".to_string();\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpn3qgbfig.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqzbcrpqz.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpn64z9iwt.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3gun_qsi.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut intersection = (a, b);\n    if a > c {\n        intersection = (c,\
    \ b);\n    }\n    if b < d {\n        intersection = (a, d);\n    }\n    if a\
    \ > d || b < c {\n        return \"NO\".to_string();\n    }\n    let (a, b) =\
    \ intersection;\n    let length = b - a + 1;\n    if length <= 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcdv0zqq4.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (max(start1, start2), min(end1, end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp8n10p3g6.rs:20:25\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmp8n10p3g6.rs:20:46\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n36 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n20 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmppr4db73g.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ x = c;\n    if a > x {\n        x = a;\n    }\n    let mut y = d;\n    if b\
    \ < y {\n        y = b;\n    }\n    if x == y {\n        return \"NO\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= y {\n        if x % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpha62c640.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if start > end {\n        start = interval1.1;\n        end = interval1.0;\n\
    \    }\n    let (mut start2, mut end2) = (interval2.0, interval2.1);\n    if start2\
    \ > end2 {\n        start2 = interval2.1;\n        end2 = interval2.0;\n    }\n\
    \    if start > end2 || start2 > end {\n        return \"NO\".to_string();\n \
    \   }\n    let (mut start, mut end) = (start.max(start2), end.min(end2));\n  \
    \  if start > end {\n        start = end;\n    }\n    if start == end {\n    \
    \    return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..start {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..end {\n        if end % i == 0 {\n     \
    \       is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..(end - start)\
    \ {\n        if (end - start) % i == 0 {\n            is_prime = false;\n    \
    \        break;\n        }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6_lficr1.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = (max(start1, start2), min(end1, end2));\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp1v5o64qy.rs:20:25\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmp1v5o64qy.rs:20:46\n\
    \   |\n20 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n36 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n20 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if start1 > start2 { start1 } else\
    \ { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let length\
    \ = end - start + 1;\n    if length <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwrtnmv2b.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp36on0dae.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9mphqyup.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if start == 0 && end == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..len {\n  \
    \      if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpncwksx94.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let len = end - start + 1;\n  \
    \  if len <= 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..len\
    \ {\n        if len % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_n_q0v0a.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n\
    \    for i in 3..length {\n        if length % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp78w5xhpr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = a;\n    let mut end = b;\n    if a > c {\n        start =\
    \ c;\n    }\n    if b < d {\n        end = d;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let mut length = end - start;\n\
    \    if length == 0 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 1 {\n        return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n\
    \        length /= 2;\n    }\n    if length % 3 == 0 {\n        length /= 3;\n\
    \    }\n    if length % 5 == 0 {\n        length /= 5;\n    }\n    if length %\
    \ 7 == 0 {\n        length /= 7;\n    }\n    if length == 1 {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9enms0ft.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length {\n\
    \        if length % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptnecc85u.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (a, b) = if a > b { (b, a) } else { (a, b) };\n    let (c, d) = if c\
    \ > d { (d, c) } else { (c, d) };\n    if a > d || b < c {\n        return \"\
    NO\".to_string();\n    }\n    let (mut x, mut y) = (a, b);\n    if x < c {\n \
    \       x = c;\n    }\n    if y > d {\n        y = d;\n    }\n    let len = y\
    \ - x + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n    }\n   \
    \ for i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpay9p_dd6.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
