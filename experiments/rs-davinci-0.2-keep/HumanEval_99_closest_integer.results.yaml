name: HumanEval_99_closest_integer
language: rust
results:
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcaca3p98.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpf3so9_4p.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpeok_nyik.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.is_sign_negative() {\n        value -= 1.0;\n    }\n    value as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpy4_h3frv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpttap402p.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp1d6rx9xe.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let mut num_int = num.round()\
    \ as isize;\n    if num_int == 0 {\n        num_int = num.ceil() as isize;\n \
    \   }\n    num_int\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() == 0.5 {\n \
    \       if value.is_sign_positive() {\n            return (value + 0.5).floor()\
    \ as isize;\n        } else {\n            return (value - 0.5).ceil() as isize;\n\
    \        }\n    }\n    value.round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpkdvt49pj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp6sjpbqoa.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    if value_abs - value_floor < value_ceil - value_abs {\n        value_floor\
    \ as isize * value.signum() as isize\n    } else {\n        value_ceil as isize\
    \ * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    if value_floor == value_ceil {\n        value.round() as isize\n    } else\
    \ if value_abs - value_floor < value_ceil - value_abs {\n        value_floor as\
    \ isize\n    } else {\n        value_ceil as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmplnshrfbe.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v = value.parse::<f64>().unwrap();\n    if v > 0.0 {\n        v.ceil()\
    \ as isize\n    } else {\n        v.floor() as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp4c41eria.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let rounded_value = float_value.round();\n\
    \    rounded_value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let rounded = num.round();\n  \
    \  rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.is_sign_negative()\
    \ {\n        value = value.abs();\n        if value.fract() == 0.5 {\n       \
    \     value = value.floor();\n            value -= 1.0;\n            value *=\
    \ -1.0;\n        } else {\n            value = value.round();\n            value\
    \ *= -1.0;\n        }\n    } else {\n        if value.fract() == 0.5 {\n     \
    \       value = value.floor();\n            value += 1.0;\n        } else {\n\
    \            value = value.round();\n        }\n    }\n    value as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-14`,\n right: `-16`', /tmp/tmpkyetkwdu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.is_sign_negative()\
    \ {\n        value = -value;\n    }\n    let mut result = value.floor();\n   \
    \ if value - result >= 0.5 {\n        result += 1.0;\n    }\n    if value.is_sign_negative()\
    \ {\n        -result as isize\n    } else {\n        result as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmp7o_7g4w7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_floor = num_abs.floor();\n    let num_ceil = num_abs.ceil();\n    let num_diff_floor\
    \ = num_abs - num_floor;\n    let num_diff_ceil = num_ceil - num_abs;\n    if\
    \ num_diff_floor < num_diff_ceil {\n        num_floor as isize * num.signum()\
    \ as isize\n    } else {\n        num_ceil as isize * num.signum() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round();\n\
    \    if result == value {\n        result as isize\n    } else {\n        if value\
    \ > 0.0 {\n            result as isize + 1\n        } else {\n            result\
    \ as isize - 1\n        }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmptr4m2wd0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round();\n\
    \    if result < value {\n        result += 1.0;\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpjju7sm5l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpwx09xqev.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value < 0.0 {\n        value -= 1.0;\n    }\n    value as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpky9nu3ix.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.is_sign_negative() {\n        value -= 1.0;\n    }\n    value as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmppc93_hy3.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpfha0plf_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_int = value.round()\
    \ as isize;\n    if value_int > value as isize {\n        value_int - 1\n    }\
    \ else {\n        value_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp8fco0rev.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp1593k7jy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    num.round() as isize\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmptwwprb9_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpauoz2c89.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmph0kqj7vh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpx_2y5s1p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmprobh4_v4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    let v_abs = v.abs();\n    let v_floor\
    \ = v_abs.floor();\n    let v_ceil = v_abs.ceil();\n    if v_abs - v_floor < v_ceil\
    \ - v_abs {\n        v_floor as isize * v.signum() as isize\n    } else {\n  \
    \      v_ceil as isize * v.signum() as isize\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpqohvbbr1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let rounded_value = float_value.round();\n\
    \    rounded_value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.abs() < 0.5 {\n        value = 0.0;\n    }\n    value as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp_n9lxjul.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let mut num_int = num.round() as\
    \ isize;\n    if num_int > num as isize {\n        num_int -= 1;\n    }\n    num_int\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpp5ik2yz5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpw2tbawb6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut result = value.round();\n\
    \    if result < value {\n        result += 1.0;\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmprd2q_vjp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if value < 0.0 {\n       \
    \     result -= 1;\n        } else {\n            result += 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp_avigifo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num < 0.0 {\n        return\
    \ (num - 0.5).ceil() as isize;\n    }\n    (num + 0.5).floor() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpsgawlyjh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpb7lw81oz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut closest = value.round()\
    \ as isize;\n    if value.fract() == 0.5 {\n        if closest < 0 {\n       \
    \     closest -= 1;\n        } else {\n            closest += 1;\n        }\n\
    \    }\n    closest\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp_gyjaixg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.abs() < 0.5 {\n        value = 0.0;\n    }\n    value as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp5c5whmo0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value > 0.0 {\n\
    \        value + 0.5\n    } else {\n        value - 0.5\n    };\n    value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpcu0nr6tm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut result = value.round();\n\
    \    if result < value {\n        result += 1.0;\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpgvbxh1uz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp8v8kl9kr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round();\n\
    \    if result > value {\n        result -= 1.0;\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp34te6vkm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpih1j4f13.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpkmlxhm13.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpq9_49un8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_ceil = num.ceil();\n  \
    \  let num_floor = num.floor();\n    if num_ceil - num < num - num_floor {\n \
    \       num_ceil as isize\n    } else {\n        num_floor as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpg20ubtc8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        return\
    \ (num + 0.5).floor() as isize;\n    }\n    (num - 0.5).ceil() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpcp9xrw9u.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value < 0.0 {\n        value -= 1.0;\n    }\n    value as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmpfrmo0dqs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpx32tqssj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpeb1d9ftf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_dec = num - num_int as f64;\n    if num_dec < 0.5 {\n        num_int\n\
    \    } else {\n        num_int + 1\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmp1r5pqszg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num < 0.0 {\n        return\
    \ (num - 0.5).floor() as isize;\n    }\n    (num + 0.5).floor() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val: f64 = value.parse().unwrap();\n    if val.fract() >= 0.5 {\n     \
    \   val.ceil() as isize\n    } else {\n        val.floor() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp9rxe_cq0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value < 0.0 {\n\
    \        value - 0.5\n    } else {\n        value + 0.5\n    };\n    value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp6b3qxjc0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_decimal = num - num_int as f64;\n    if num_decimal > 0.5 {\n   \
    \     num_int + 1\n    } else if num_decimal < -0.5 {\n        num_int - 1\n \
    \   } else {\n        num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpprdxzplk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() > 0.5 {\n  \
    \      (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() >= 0.5 {\n   \
    \     return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp7eqaw773.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpf8hiqurk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    let value_diff_floor = value_abs - value_floor;\n    let value_diff_ceil\
    \ = value_ceil - value_abs;\n    if value_diff_floor < value_diff_ceil {\n   \
    \     value_floor as isize\n    } else {\n        value_ceil as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmpzurb21r8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpfxk680ir.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpnhd3s0wa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    let value_floor_diff = value_abs - value_floor;\n    let value_ceil_diff\
    \ = value_ceil - value_abs;\n    if value_floor_diff < value_ceil_diff {\n   \
    \     value_floor as isize\n    } else if value_floor_diff > value_ceil_diff {\n\
    \        value_ceil as isize\n    } else {\n        if value_floor == value_ceil\
    \ {\n            value_floor as isize\n        } else {\n            if value\
    \ < 0.0 {\n                value_floor as isize\n            } else {\n      \
    \          value_ceil as isize\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `-16`', /tmp/tmpm8vr6293.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let mut num_int = num.round() as\
    \ isize;\n    if num_int == 0 {\n        num_int = num.ceil() as isize;\n    }\n\
    \    num_int\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp37h1groi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp3wkgdtwy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp6fn9dm9x.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpbrycwxe4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value >= 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpbc111wxo.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.is_sign_positive()\
    \ {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n    value\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpbspuyemk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_ceil = value.ceil();\n\
    \    let value_floor = value.floor();\n    if value_ceil - value == value - value_floor\
    \ {\n        if value_ceil.abs() > value_floor.abs() {\n            value_ceil\
    \ as isize\n        } else {\n            value_floor as isize\n        }\n  \
    \  } else if value_ceil - value < value - value_floor {\n        value_ceil as\
    \ isize\n    } else {\n        value_floor as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp0bk3tl9v.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value < 0.0 {\n\
    \        value - 0.5\n    } else {\n        value + 0.5\n    };\n    value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp4viwkmph.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp01yxub8f.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp20x2gu9k.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_dec = num.fract();\n    if num_dec >= 0.5 {\n        num_int + 1\n\
    \    } else {\n        num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpip0membg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   return (num + 1.0).round() as isize;\n    }\n    num.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpiaalyqci.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let rounded = number.round();\n\
    \    rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    number.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    if value_abs - value_floor < value_ceil - value_abs {\n        value_floor\
    \ as isize * value.signum() as isize\n    } else {\n        value_ceil as isize\
    \ * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.is_sign_positive()\
    \ {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n    value\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpjspy9fhy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpj7nyp9_i.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_ceil = num_abs.ceil();\n    let num_floor = num_abs.floor();\n    if num_ceil\
    \ - num_abs > num_abs - num_floor {\n        num_floor as isize * num.signum()\
    \ as isize\n    } else {\n        num_ceil as isize * num.signum() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    let rounded_up = rounded.ceil();\n    let rounded_down = rounded.floor();\n\
    \    let rounded_up_diff = (value - rounded_up).abs();\n    let rounded_down_diff\
    \ = (value - rounded_down).abs();\n    if rounded_up_diff == rounded_down_diff\
    \ {\n        if value < 0.0 {\n            rounded_down as isize\n        } else\
    \ {\n            rounded_up as isize\n        }\n    } else if rounded_up_diff\
    \ < rounded_down_diff {\n        rounded_up as isize\n    } else {\n        rounded_down\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_abs = num.abs();\n    let\
    \ num_floor = num_abs.floor();\n    let num_ceil = num_abs.ceil();\n    let num_round\
    \ = num_abs.round();\n    if num_abs - num_floor < num_ceil - num_abs {\n    \
    \    if num_abs - num_floor < num_round - num_abs {\n            if num < 0.0\
    \ {\n                return -num_floor as isize;\n            }\n            return\
    \ num_floor as isize;\n        }\n    }\n    if num_abs - num_floor > num_ceil\
    \ - num_abs {\n        if num_abs - num_floor > num_round - num_abs {\n      \
    \      if num < 0.0 {\n                return -num_ceil as isize;\n          \
    \  }\n            return num_ceil as isize;\n        }\n    }\n    if num_abs\
    \ - num_floor == num_ceil - num_abs {\n        if num < 0.0 {\n            return\
    \ -num_ceil as isize;\n        }\n        return num_ceil as isize;\n    }\n \
    \   if num < 0.0 {\n        return -num_round as isize;\n    }\n    return num_round\
    \ as isize;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value.is_sign_positive()\
    \ {\n        value.ceil()\n    } else {\n        value.floor()\n    };\n    value\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp2ulmwq8e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value < 0.0 {\n        value -= 1.0;\n    }\n    value as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp81ddw25j.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpljwtt16p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num < 0.0 {\n        return\
    \ (num - 0.5).floor() as isize;\n    }\n    (num + 0.5).floor() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round()\
    \ as isize;\n    if value.abs() - value.round().abs() == 0.5 {\n        result\
    \ += value.signum() as isize;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_int = value.round()\
    \ as isize;\n    if value - value_int as f64 >= 0.5 {\n        value_int + 1\n\
    \    } else {\n        value_int\n    }\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpvz5dw6ft.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded: isize = value.round()\
    \ as isize;\n    let value_ceiled: isize = value.ceil() as isize;\n    let value_floored:\
    \ isize = value.floor() as isize;\n\n    if value_rounded == value_ceiled {\n\
    \        value_ceiled\n    } else if value_rounded == value_floored {\n      \
    \  value_floored\n    } else {\n        if value > 0.0 {\n            value_ceiled\n\
    \        } else {\n            value_floored\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let integer = number.round()\
    \ as isize;\n    if number.abs() - integer.abs() as f64 == 0.5 {\n        if number\
    \ > 0.0 {\n            integer + 1\n        } else {\n            integer - 1\n\
    \        }\n    } else {\n        integer\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let int_value = float_value.round()\
    \ as isize;\n    if int_value > float_value as isize {\n        int_value - 1\n\
    \    } else {\n        int_value\n    }\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp9sfo8ng8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp5ud2s297.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpyh1faz9q.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_int_abs = num_int.abs();\n    let num_abs = num.abs();\n    if num_abs\
    \ - num_int_abs < 0.5 {\n        num_int\n    } else {\n        num_int + num_int.signum()\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `isize` from `f64`\n  --> /tmp/tmpilp0os2d.rs:19:16\n\
    \   |\n19 |     if num_abs - num_int_abs < 0.5 {\n   |                ^ no implementation\
    \ for `f64 - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut value = value.round();\n\
    \    if value.abs() < 1.0 {\n        value = value.signum();\n    }\n    value\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpmfmdwvww.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp7fk4phmt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpsgo3aycs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let rounded = num.round();\n  \
    \  rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let rounded_number = number.round();\n\
    \    rounded_number as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let result = value.round();\n\
    \    result as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded > value {\n        rounded as isize - 1\n    } else {\n      \
    \  rounded as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpaqysewcg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() < 0.5 {\n      \
    \  num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if num_int > num as isize {\n        num_int - 1\n    } else {\n        num_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp7zwep_oq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmphqokat1l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_rounded = value.round();\n\
    \    if value_rounded > value {\n        value_rounded as isize - 1\n    } else\
    \ {\n        value_rounded as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpuzmcqb97.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = if value < 0.0 {\n\
    \        value - 0.5\n    } else {\n        value + 0.5\n    };\n    value.trunc()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_abs_floor = value_abs.floor();\n    let value_abs_ceil = value_abs.ceil();\n\
    \    if value_abs - value_abs_floor < value_abs_ceil - value_abs {\n        value_abs_floor\
    \ as isize * value.signum() as isize\n    } else {\n        value_abs_ceil as\
    \ isize * value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let int_value = value.round()\
    \ as isize;\n    if value - int_value as f64 == 0.5 {\n        if int_value <\
    \ 0 {\n            int_value - 1\n        } else {\n            int_value + 1\n\
    \        }\n    } else {\n        int_value\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp2i1ckjj7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        value += 1.0;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut result = value.round();\n\
    \    if result < value {\n        result += 1.0;\n    }\n    result as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpoptepor5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut closest_int = value.round()\
    \ as isize;\n    if value.abs() - closest_int as f64 > 0.5 {\n        closest_int\
    \ = (value.round() + 1.0) as isize;\n    }\n    closest_int\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpkfg1y8dx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_as_int = value as isize;\n\
    \    let value_as_float = value as f64;\n    if value_as_float - value_as_int\
    \ as f64 > 0.5 {\n        value_as_int + 1\n    } else {\n        value_as_int\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmppfbof8fu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_dec = num - num_int as f64;\n    if num_dec >= 0.5 {\n        num_int\
    \ + 1\n    } else {\n        num_int\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpuc1zent5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_ceil = num.ceil();\n  \
    \  let num_floor = num.floor();\n    if num_ceil - num == num - num_floor {\n\
    \        if num_ceil.abs() > num_floor.abs() {\n            num_ceil as isize\n\
    \        } else {\n            num_floor as isize\n        }\n    } else if num_ceil\
    \ - num < num - num_floor {\n        num_ceil as isize\n    } else {\n       \
    \ num_floor as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f = value.parse::<f64>().unwrap();\n    if f.fract() < 0.5 {\n        f\
    \ as isize\n    } else {\n        (f + 1.0) as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpbgpr57ba.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value_abs = value.abs();\n\
    \    let value_floor = value_abs.floor();\n    let value_ceil = value_abs.ceil();\n\
    \    let value_round = value_abs.round();\n    if value_round - value_floor <\
    \ value_ceil - value_round {\n        value_floor as isize\n    } else {\n   \
    \     value_ceil as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `-16`', /tmp/tmp0b7psqfi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.abs() - value.abs().floor()\
    \ < 0.5 {\n        value.floor() as isize\n    } else {\n        value.ceil()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpy3ia7ypn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    let ceiled = value.ceil();\n    let floored = value.floor();\n    if rounded\
    \ - value == 0.5 {\n        if rounded > 0.0 {\n            return ceiled as isize;\n\
    \        } else {\n            return floored as isize;\n        }\n    }\n  \
    \  rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n     \
    \   (num + 1.0).round() as isize\n    } else {\n        num.round() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpvkq23vb0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let value = value.round();\n\
    \    value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpxpaqkje9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    if (num - num_int as f64).abs() == 0.5 {\n        if num_int < 0 {\n    \
    \        num_int - 1\n        } else {\n            num_int + 1\n        }\n \
    \   } else {\n        num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp0v0ca1zh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n  \
    \      value.floor() as isize\n    } else {\n        value.ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num.fract() == 0.5 {\n     \
    \   if num < 0.0 {\n            return (num - 0.5).floor() as isize;\n       \
    \ }\n        return (num + 0.5).ceil() as isize;\n    }\n    num.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmphyinzl_h.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_int = num.round() as isize;\n\
    \    let num_decimal = num - num_int as f64;\n    if num_decimal > 0.5 {\n   \
    \     num_int + 1\n    } else if num_decimal < -0.5 {\n        num_int - 1\n \
    \   } else {\n        num_int\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() >= 0.5 {\n \
    \       (value + 1.0).round() as isize\n    } else {\n        value.round() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpqvdr3o53.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.fract() < 0.5 {\n    \
    \    num.floor() as isize\n    } else {\n        num.ceil() as isize\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.fract() == 0.5 {\n \
    \       if value.is_sign_positive() {\n            value.ceil() as isize\n   \
    \     } else {\n            value.floor() as isize\n        }\n    } else {\n\
    \        value.round() as isize\n    }\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n   \
    \ assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
