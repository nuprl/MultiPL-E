name: HumanEval_105_by_length
language: rust
results:
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| x.abs()\
    \ < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        if i == 1 {\n \
    \           result.push(\"One\".to_string());\n        } else if i == 2 {\n  \
    \          result.push(\"Two\".to_string());\n        } else if i == 3 {\n   \
    \         result.push(\"Three\".to_string());\n        } else if i == 4 {\n  \
    \          result.push(\"Four\".to_string());\n        } else if i == 5 {\n  \
    \          result.push(\"Five\".to_string());\n        } else if i == 6 {\n  \
    \          result.push(\"Six\".to_string());\n        } else if i == 7 {\n   \
    \         result.push(\"Seven\".to_string());\n        } else if i == 8 {\n  \
    \          result.push(\"Eight\".to_string());\n        } else if i == 9 {\n \
    \           result.push(\"Nine\".to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.iter().filter(|x| x > &&0 && x <\
    \ &&10).map(|x| x.to_string()).collect::<Vec<String>>();\n    result.sort();\n\
    \    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpqaxjay_1.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpv729e79l.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut sorted_arr:\
    \ Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => (),\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|&x| x != \"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        if i > 0 && i < 10 {\n            match i\
    \ {\n                1 => result.push(\"One\".to_string()),\n                2\
    \ => result.push(\"Two\".to_string()),\n                3 => result.push(\"Three\"\
    .to_string()),\n                4 => result.push(\"Four\".to_string()),\n    \
    \            5 => result.push(\"Five\".to_string()),\n                6 => result.push(\"\
    Six\".to_string()),\n                7 => result.push(\"Seven\".to_string()),\n\
    \                8 => result.push(\"Eight\".to_string()),\n                9 =>\
    \ result.push(\"Nine\".to_string()),\n                _ => (),\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x >= 1 && x <= 9).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp33bpc62o.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.iter().filter(|&x| *x > 0 && *x <\
    \ 10).cloned().collect::<Vec<isize>>();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut arr: Vec<isize>\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr {\n        match\
    \ i {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpllsxrq_s.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr\n        .into_iter()\n        .filter(|&x|\
    \ x >= 1 && x <= 9)\n        .collect::<Vec<isize>>();\n    result.sort();\n \
    \   result.reverse();\n    result.into_iter()\n        .map(|x| match x {\n  \
    \          1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        })\n        .map(|x| x.to_string())\n\
    \        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpi1dqz59u.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x >= 1 && x <= 9).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp_6al0leo.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    sorted.reverse();\n    for i in sorted {\n        if\
    \ i > 0 && i < 10 {\n            match i {\n                1 => result.push(\"\
    One\".to_string()),\n                2 => result.push(\"Two\".to_string()),\n\
    \                3 => result.push(\"Three\".to_string()),\n                4 =>\
    \ result.push(\"Four\".to_string()),\n                5 => result.push(\"Five\"\
    .to_string()),\n                6 => result.push(\"Six\".to_string()),\n     \
    \           7 => result.push(\"Seven\".to_string()),\n                8 => result.push(\"\
    Eight\".to_string()),\n                9 => result.push(\"Nine\".to_string()),\n\
    \                _ => (),\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ >= 1 && *x <= 9).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp7x2h1hul.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter()\n\
    \        .filter(|&x| x > &0 && x < &10)\n        .map(|x| match x {\n       \
    \     1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n\
    \            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => \"\",\n        })\n        .map(|x| x.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp5ea8_nic.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x|\
    \ x != &\"\").map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut arr: Vec<isize>\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr {\n        match\
    \ i {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp976b_thh.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr {\n      \
    \  match i {\n            1 => result.push(\"One\".to_string()),\n           \
    \ 2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"Three\"\
    .to_string()),\n            4 => result.push(\"Four\".to_string()),\n        \
    \    5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.iter().filter(|&x| x >= &1 && x <=\
    \ &9).map(|x| x.to_string()).collect::<Vec<String>>();\n    result.sort();\n \
    \   result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpmbaqtf2j.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.iter().filter(|&x| *x > 0 && *x <\
    \ 10).map(|x| x.to_string()).collect::<Vec<String>>();\n    result.sort();\n \
    \   result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp45gq1ff0.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted: Vec<isize> = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    for i in sorted {\n        if i == 1 {\n            result.push(\"One\".to_string());\n\
    \        } else if i == 2 {\n            result.push(\"Two\".to_string());\n \
    \       } else if i == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        if i >= 1 && i\
    \ <= 9 {\n            result.push(match i {\n                1 => \"One\",\n \
    \               2 => \"Two\",\n                3 => \"Three\",\n             \
    \   4 => \"Four\",\n                5 => \"Five\",\n                6 => \"Six\"\
    ,\n                7 => \"Seven\",\n                8 => \"Eight\",\n        \
    \        9 => \"Nine\",\n                _ => \"\",\n            }.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x >= &1 && x <= &9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpoa1qc1mh.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.iter().filter(|&x| x > &0\
    \ && x < &10).cloned().collect();\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|&x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp0ba5y68f.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x >= 1 && x <= 9).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|&x| x != \"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| *x > &0 && *x < &10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        if i == 1 {\n            result.push(\"One\"\
    .to_string());\n        } else if i == 2 {\n            result.push(\"Two\".to_string());\n\
    \        } else if i == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut sorted_arr:\
    \ Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        if i == 1 {\n            result.push(\"One\"\
    .to_string());\n        } else if i == 2 {\n            result.push(\"Two\".to_string());\n\
    \        } else if i == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmprj5azut2.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        if i == 1 {\n            result.push(\"One\"\
    .to_string());\n        } else if i == 2 {\n            result.push(\"Two\".to_string());\n\
    \        } else if i == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp3l7ot3im.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&i| match i {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&s| s != \"\").map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut res = Vec::new();\n    for i in arr {\n        match i {\n      \
    \      1 => res.push(\"One\".to_string()),\n            2 => res.push(\"Two\"\
    .to_string()),\n            3 => res.push(\"Three\".to_string()),\n          \
    \  4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\".to_string()),\n\
    \            6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"\
    Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n   \
    \         9 => res.push(\"Nine\".to_string()),\n            _ => (),\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.clone();\n    result.sort();\n  \
    \  result.reverse();\n    result.iter().map(|x| match x {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x|\
    \ x != &\"\").map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp4t3awu4o.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<_> = arr.into_iter().filter(|x| *x >=\
    \ 1 && *x <= 9).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpibzp0qlz.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x|\
    \ x != \"\").map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut sorted_arr:\
    \ Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => (),\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&&x| x > 0 && x < 10).map(|&x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp8uybvi7p.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr\n        .into_iter()\n        .filter(|&x|\
    \ x >= 1 && x <= 9)\n        .collect::<Vec<isize>>();\n    result.sort();\n \
    \   result.reverse();\n    result.into_iter()\n        .map(|x| match x {\n  \
    \          1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        })\n        .filter(|&x| x !=\
    \ \"\")\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x >= &1 && x <= &9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.iter().filter(|x| **x >= 1 && **x\
    \ <= 9).cloned().collect::<Vec<isize>>();\n    result.sort();\n    result.reverse();\n\
    \    result.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp4kwxorfu.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = arr.clone();\n    v.sort();\n    v.reverse();\n\
    \    v.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 => \"\
    One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        if i >= 1 && i <= 9 {\n            match i\
    \ {\n                1 => result.push(\"One\".to_string()),\n                2\
    \ => result.push(\"Two\".to_string()),\n                3 => result.push(\"Three\"\
    .to_string()),\n                4 => result.push(\"Four\".to_string()),\n    \
    \            5 => result.push(\"Five\".to_string()),\n                6 => result.push(\"\
    Six\".to_string()),\n                7 => result.push(\"Seven\".to_string()),\n\
    \                8 => result.push(\"Eight\".to_string()),\n                9 =>\
    \ result.push(\"Nine\".to_string()),\n                _ => (),\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| match x {\n        1\
    \ => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"\
    Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x|\
    \ x != &\"\").map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&n| match n {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&s| s != \"\").map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    sorted.reverse();\n    for i in sorted {\n        if\
    \ i > 0 && i < 10 {\n            result.push(match i {\n                1 => \"\
    One\",\n                2 => \"Two\",\n                3 => \"Three\",\n     \
    \           4 => \"Four\",\n                5 => \"Five\",\n                6\
    \ => \"Six\",\n                7 => \"Seven\",\n                8 => \"Eight\"\
    ,\n                9 => \"Nine\",\n                _ => \"\",\n            }.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| *x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr\
    \ {\n        match i {\n            1 => result.push(\"One\".to_string()),\n \
    \           2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr\n        .iter()\n        .filter(|&x|\
    \ x >= &1 && x <= &9)\n        .map(|&x| x.to_string())\n        .collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp9m8m9tzg.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp_xbrrrvy.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<_> = arr.into_iter().filter(|x| x > &0\
    \ && x < &10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpv4wvsbqt.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| x != &\"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
