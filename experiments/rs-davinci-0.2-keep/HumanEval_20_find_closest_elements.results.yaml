name: HumanEval_20_find_closest_elements
language: rust
results:
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpa197366r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvj2kd7fu.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpchsj3y5w.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut result = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min {\n                min = diff;\n                result = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpv2ds7jlv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpmboi_tcn.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    min_distance_elements\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_bbupe7k.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpem9i9mw1.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_diff = numbers[1] - numbers[0];\n\
    \    let mut closest_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < closest_diff\
    \ {\n            closest_diff = diff;\n            closest_pair = (numbers[i],\
    \ numbers[i + 1]);\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpj76dmjb5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpu67vd6hw.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpadq330ub.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4wg3fwj9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqx97eoaz.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3cxp2c6m.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpj8plx2ih.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_955chml.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_distance = distance;\n            }\n        }\n    }\n\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6kn75dr0.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpnq0gt331.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppbjcxb7u.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp7qlhnpmp.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpgct7169p.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpclx871up.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpzva6zn5i.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxq9vfho_.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_pair = (numbers[i],\
    \ numbers[i + 1]);\n            closest_distance = distance;\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmprzg88k7t.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptsg88os4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpg89pwkvg.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpc1obdcqp.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[i] - numbers[j]).abs();\n            if distance <\
    \ closest_distance {\n                closest_pair = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6mczlpcl.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_pair = (numbers[i], numbers[j]);\n            }\n \
    \       }\n    }\n    min_distance_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpsn9n4mxc.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp0c8q4l2i.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_3axua5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxqo3mgda.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpizvo40o8.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpacgyfjew.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfvp2dcfa.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqky5sa5z.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n       \
    \     let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp65axlw8l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvt95nt3x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp17o5rnis.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvvoefe1v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyv58610b.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp1_yfehya.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpv5juek2r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpwcwfzyfa.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfb9qy23o.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplki0h8pz.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpwc4eip97.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8lr0z8nl.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkd_kok8y.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp4ykt48ju.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpdpv7ndu9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_distance = distance;\n           \
    \ closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpso7zz63p.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppmkzodl2.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_9bboq0g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpsndtuvjq.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpgk799q72.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for (i, a) in numbers.iter().enumerate() {\n        for b\
    \ in numbers.iter().skip(i + 1) {\n            let distance = (a - b).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (*a, *b);\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp2rfsqfla.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpe9ab8n60.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len()\
    \ {\n            if i != j {\n                let distance = (numbers[i] - numbers[j]).abs();\n\
    \                if distance < min_distance {\n                    min_distance\
    \ = distance;\n                    closest_elements = (numbers[i], numbers[j]);\n\
    \                }\n            }\n        }\n    }\n    closest_elements\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp0fpjkh4o.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbmfmiesr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpalvwg0x5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        let diff = (numbers[i + 1] - numbers[i]).abs();\n        if diff\
    \ < closest_diff {\n            closest = (numbers[i], numbers[i + 1]);\n    \
    \        closest_diff = diff;\n        }\n    }\n    closest\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp23_2v9k8.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpnex1jt36.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpkxpzt9px.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmplkzu5iah.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[i] - numbers[j]).abs();\n            if distance <\
    \ closest_distance {\n                closest_pair = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbe_4r4i1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw72ulxid.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut smallest_difference = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let difference = (numbers[j]\
    \ - numbers[i]).abs();\n            if difference < smallest_difference {\n  \
    \              smallest_difference = difference;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpq0f4l46y.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpdcsrwf7x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpu511q2jf.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpaiieof9d.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpru8mmzmn.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxu562j8n.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpy28oap5e.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpobw6w0q4.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpg3xjlwwq.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp1kq3h12p.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpmcqqw_ql.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpf7gdxm4m.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4e0igcwk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpt9zw4l2z.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpj89hwq0s.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkgpioc7z.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_uo50vyk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptm9zajn9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpsz8up8c9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp7pqhlhiu.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptog0bon9.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_od5zrdh.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyjgo_u07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpsuosltja.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp59tu7xig.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkkr9odh3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfbn6dkyw.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_elements = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_elements\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmps9tsel3x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpx3vislp0.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_pair.1 - closest_pair.0;\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpejupaner.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_pair = (numbers[i], numbers[j]);\n            }\n \
    \       }\n    }\n    min_distance_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp9ooznsoj.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfx5kjawt.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp52_4d40x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if\
    \ i != j {\n                let distance = (numbers[i] - numbers[j]).abs();\n\
    \                if distance < closest_distance {\n                    closest_distance\
    \ = distance;\n                    closest_pair = (numbers[i], numbers[j]);\n\
    \                }\n            }\n        }\n    }\n    closest_pair\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmplnh_4ri1.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpzfc5u_3k.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmplxx4b006.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp9c0dbz9t.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp11jiob8o.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpftdyqs6f.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpo8s369io.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::INFINITY;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4f02t1hc.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8deiw89j.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfjeyq5xn.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_u8kwewm.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp6s0rpt2_.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpng_nv6n6.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_elements = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp2pmytra1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppji82gtv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpoorl89gk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpnbcfqb56.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpdzwbza5g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpf6wxah8h.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (0.0, 0.0);\n    let\
    \ mut closest_distance: f64 = std::f64::MAX;\n    for i in 0..numbers.len() {\n\
    \        for j in i + 1..numbers.len() {\n            let distance = (numbers[i]\
    \ - numbers[j]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmphvn8wipn.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkgnnfsfw.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (0.0, 0.0);\n    let\
    \ mut closest_distance: f64 = std::f64::MAX;\n    for i in 0..numbers.len() {\n\
    \        for j in i + 1..numbers.len() {\n            let distance = (numbers[i]\
    \ - numbers[j]).abs();\n            if distance < closest_distance {\n       \
    \         closest_distance = distance;\n                closest_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpswxt9shb.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = (numbers[j] - numbers[i]).abs();\n            if distance\
    \ < closest_distance {\n                closest_distance = distance;\n       \
    \         closest_elements = (numbers[i], numbers[j]);\n            }\n      \
    \  }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmphrvaxa9z.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpik9u0lv3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp08e575a5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptz2xqujy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpwbly2az_.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = numbers[1] - numbers[0];\n    for i in 0..numbers.len()\
    \ - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n        if distance\
    \ < closest_distance {\n            closest_distance = distance;\n           \
    \ closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_pair = (numbers[i], numbers[j]);\n            }\n \
    \       }\n    }\n    min_distance_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpn13_v7qy.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_zhn8oja.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp32scv6uu.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpn8metpi1.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxjqq2e0y.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbc7woeq6.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpe22stwpq.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpuzaovb5u.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpbws7k_zo.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpa69811ix.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = closest_elements.1 - closest_elements.0;\n \
    \   for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n   \
    \         let difference = numbers[j] - numbers[i];\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpb49gmho5.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyaxj81ip.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n \
    \           let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjrpfs9l9.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8dp0cnl0.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpd2dv1ju1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmppyyfa25p.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpy3bidols.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpsz6y0bi7.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ difference = (numbers[j] - numbers[i]).abs();\n            if difference < closest_difference\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_difference = difference;\n            }\n        }\n    }\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp7_iqc22a.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let dist = (numbers[i] - numbers[j]).abs();\n            if dist\
    \ < min_dist {\n                min_dist = dist;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp743o6uwd.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw3k2w2tn.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpwjepvotx.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpj_ejm7gu.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpg62k_zcj.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpqoelen94.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp923mghsv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4yg9kjwi.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmputtsvfm5.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpc4nuoxc9.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpytt367pk.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpklsrtdf0.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n       \
    \     let distance = (numbers[j] - numbers[i]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpucujzrsf.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp92g2zma3.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut result = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min {\n                min = diff;\n                result = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmps5nvgfjv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmporcfpu4r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < closest_distance {\n              \
    \  closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpbuwl7bjx.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjlkov9i3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             closest_elements = (numbers[i], numbers[j]);\n            }\n  \
    \      }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmppp5wmhs8.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpk88n_mmo.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp03pw1cwj.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut min_distance_numbers\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_numbers = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    min_distance_numbers\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvt7yhtnd.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n          \
    \  let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_numbers = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \n    closest_numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp4d5s99p3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpayki10xm.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp0pi2x98h.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8t2x1_0n.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpk61kqus1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp8y_aunom.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_joh_bce.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_distance_pair = (numbers[i], numbers[j]);\n            }\n \
    \       }\n    }\n    min_distance_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpljo6b76o.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5zwe7h3w.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpwz_nul9b.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpo6ugzviv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpxm3b3bw2.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3h32nlwp.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut min_diff_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_diff_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptuyhszb4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp413jcxmz.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp8p7gtcnc.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpifu_gc28.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmposmt0qzs.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_distance = distance;\n            }\n        }\n    }\n\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp2avpqn51.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference: f64 = (numbers[1] - numbers[0]).abs();\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpvt08kuem.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n \
    \   let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ difference = (numbers[j] - numbers[i]).abs();\n            if difference < closest_difference\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_difference = difference;\n            }\n        }\n    }\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpp7uezmfh.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = (numbers[j]\
    \ - numbers[i]).abs();\n            if distance < closest_distance {\n       \
    \         closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmphg1bqdjw.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpxh3zyvyq.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmptjanauza.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let distance = (numbers[i] - numbers[j]).abs();\n           \
    \ if distance < min_distance {\n                min_distance = distance;\n   \
    \             min_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_ubpgu48.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair: (f64, f64) = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance: f64 = closest_pair.1 - closest_pair.0;\n    for\
    \ i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpadvgpqua.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkutxrrli.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
