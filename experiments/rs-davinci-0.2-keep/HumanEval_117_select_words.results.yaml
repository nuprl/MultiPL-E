name: HumanEval_117_select_words
language: rust
results:
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             count += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if count == n {\n                result.push(word);\n  \
    \          }\n            count = 0;\n            word = String::new();\n    \
    \    }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp2ycw4e3r.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        consonants += 1;\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpz13tboiy.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|word|\
    \ word.chars().filter(|c| !is_vowel(*c)).count() as isize == n)\n        .map(|word|\
    \ word.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp9h9hijqp.rs:14:49\n\
    \   |\n14 |         .filter(|word| word.chars().filter(|c| !is_vowel(*c)).count()\
    \ as isize == n)\n   |                                                 ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpe_vboum7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2leu4cyy.rs:17:17\n\
    \   |\n17 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      count = 0;\n            word = String::new();\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmponhcoxmq.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    for word\
    \ in s.split_whitespace() {\n        let mut count = 0;\n        for ch in word.chars()\
    \ {\n            if ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch !=\
    \ 'u' {\n                count += 1;\n            }\n        }\n        if count\
    \ == n {\n            res.push(word.to_string());\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmplkdtiw3a.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp_kyaou5f.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    continue;\n                }\n            }\n           \
    \ count += 1;\n            word.push(c);\n        } else {\n            if count\
    \ == n {\n                result.push(word);\n            }\n            count\
    \ = 0;\n            word = String::new();\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmpdi1u9ekm.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                consonants += 1;\n            }\n        } else\
    \ {\n            if consonants == n {\n                result.push(word);\n  \
    \          }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsfmqj488.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if is_consonant(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmphc6x_enc.rs:24:16\n   |\n24 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmppgfbrvcw.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp72rv0uu8.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpv8lizaax.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n  \
    \      if c == ' ' {\n            if count == n {\n                res.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if is_consonant(c) {\n\
    \                count += 1;\n            }\n        }\n    }\n    if count ==\
    \ n {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpu10vkwbf.rs:25:16\n   |\n25 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             count += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if count == n {\n                result.push(word);\n  \
    \          }\n            count = 0;\n            word = String::new();\n    \
    \    }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpr2_m4nzg.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !c.is_vowel() {\n                consonants += 1;\n            }\n        }\
    \ else {\n            if consonants == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8qw3zsy0.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpalhvt6kg.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpief5onj4.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut v: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if count == n {\n                v.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        v.push(word);\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpuhxmmc4_.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y' {\n                count +=\
    \ 1;\n            }\n        }\n    }\n    if count == n {\n        result.push(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpv3vyzmbv.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !c.is_ascii_vowel() {\n                count += 1;\n            }\n     \
    \   }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmprs1e55jd.rs:25:45\n   |\n25 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpzn_nm9_n.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if consonants ==\
    \ n {\n                words.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpbl5ft61z.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp76nu28q6.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp3_1iflyw.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !is_vowel(c) {\n         \
    \       consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsq2o3fwn.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpqdltrlox.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp5zr1rb74.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if !is_vowel(c) {\n               \
    \ count += 1;\n            }\n            word.push(c);\n        } else {\n  \
    \          if count == n {\n                res.push(word);\n            }\n \
    \           count = 0;\n            word = String::new();\n        }\n    }\n\
    \    if count == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpvg0w2qx1.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !c.is_vowel() {\n \
    \               count += 1;\n            }\n        }\n    }\n    if count ==\
    \ n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgynpgq6l.rs:25:19\n   |\n25 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if !is_vowel(c) {\n                consonants += 1;\n            }\n   \
    \     }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpg566d_en.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1d296a0p.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if is_consonant(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp2b84iw8x.rs:25:16\n   |\n25 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `consonants`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if is_consonant(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpsvpe46g2.rs:24:16\n   |\n24 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1f2m5p57.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp890pp8sy.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmplvscnolc.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             count += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if count == n {\n                result.push(word);\n  \
    \          }\n            count = 0;\n            word = String::new();\n    \
    \    }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpkb8lf26w.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ words.push(word);\n            }\n            word = String::new();\n      \
    \      consonants = 0;\n        } else {\n            word.push(c);\n        \
    \    consonants += 1;\n        }\n    }\n    if consonants == n {\n        words.push(word);\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpfzmi0pfq.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n     \
    \           if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n  \
    \                  count += 1;\n                }\n            } else {\n    \
    \            if c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U' {\n \
    \                   count += 1;\n                }\n            }\n          \
    \  word.push(c);\n        } else {\n            if count == n {\n            \
    \    res.push(word);\n            }\n            count = 0;\n            word\
    \ = String::new();\n        }\n    }\n    if count == n {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !c.is_vowel() {\n                consonants += 1;\n            }\n        }\
    \ else {\n            if consonants == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpt2ixh9am.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpw8w7c_6b.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !is_vowel(c) {\n         \
    \       consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2kw77myq.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      count = 0;\n            word = String::new();\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp5b_cgzgs.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp6_2raoai.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpb6x7947c.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_vowel() {\n             \
    \   count = 0;\n                word.clear();\n            } else {\n        \
    \        count += 1;\n                word.push(c);\n            }\n        }\
    \ else {\n            if count == n {\n                result.push(word.clone());\n\
    \            }\n            count = 0;\n            word.clear();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp18wyh3jv.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpawbshuxa.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_918ifqz.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n\
    \                    count += 1;\n                }\n            } else {\n  \
    \              if c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U' {\n\
    \                    count += 1;\n                }\n            }\n         \
    \   word.push(c);\n        } else {\n            if count == n {\n           \
    \     result.push(word);\n            }\n            count = 0;\n            word\
    \ = String::new();\n        }\n    }\n    if count == n {\n        result.push(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             count += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if count == n {\n                result.push(word);\n  \
    \          }\n            count = 0;\n            word = String::new();\n    \
    \    }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpy8i1e_st.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpwbm14nf5.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            consonants = 0;\n           \
    \ word = String::new();\n        } else {\n            word.push(c);\n       \
    \     if !is_vowel(c) {\n                consonants += 1;\n            }\n   \
    \     }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpvfs4llxf.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3whg1ybi.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|w|\
    \ w.chars().filter(|c| c.is_ascii_alphabetic() && !c.is_ascii_vowel()).count()\
    \ as isize == n)\n        .map(|w| w.to_string())\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpl5tutdy8.rs:14:72\n   |\n14 |         .filter(|w|\
    \ w.chars().filter(|c| c.is_ascii_alphabetic() && !c.is_ascii_vowel()).count()\
    \ as isize == n)\n   |                                                       \
    \                 ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if !is_vowel(c) {\n               \
    \ count += 1;\n            }\n            word.push(c);\n        } else {\n  \
    \          if count == n {\n                res.push(word);\n            }\n \
    \           count = 0;\n            word = String::new();\n        }\n    }\n\
    \    if count == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc58ditb7.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        consonants += 1;\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpvkcu2qll.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp8f0hb2gw.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n\
    \                    count += 1;\n                }\n            } else {\n  \
    \              if c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U' {\n\
    \                    count += 1;\n                }\n            }\n         \
    \   word.push(c);\n        } else {\n            if count == n {\n           \
    \     result.push(word);\n            }\n            count = 0;\n            word\
    \ = String::new();\n        }\n    }\n    if count == n {\n        result.push(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwf14bz7k.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     consonants += if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n                0\n            } else {\n                1\n            };\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpu9rywy_5.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_vowel() {\n         \
    \       consonants = 0;\n                word.push(c);\n            } else {\n\
    \                consonants += 1;\n                word.push(c);\n           \
    \ }\n        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpap1_24o4.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp04f2axit.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                consonants += 1;\n            }\n        } else\
    \ {\n            if consonants == n {\n                result.push(word);\n  \
    \          }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpjp3m2fq3.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut cnt: isize = 0;\n    for\
    \ c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !is_vowel(c) {\n                cnt += 1;\n            }\n   \
    \     } else {\n            if cnt == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            cnt = 0;\n    \
    \    }\n    }\n    if cnt == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6t9j4qlt.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n  \
    \      if c == ' ' {\n            if count == n {\n                res.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpnzh2ykqi.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsdtarb37.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpia_usc84.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n            \
    \    count += 1;\n            }\n        } else {\n            if count == n {\n\
    \                result.push(word);\n            }\n            word = String::new();\n\
    \            count = 0;\n        }\n    }\n    if count == n {\n        result.push(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp8palp6r6.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n  \
    \      if c == ' ' {\n            if count == n {\n                res.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpflpd98h7.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c == ' ' {\n            if count == n {\n\
    \                result.push(word);\n            }\n            word = String::new();\n\
    \            count = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        count += 1;\n            }\n        }\n    }\n    if count == n {\n \
    \       result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp_p32g3n_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     consonants += match c {\n                'a' | 'e' | 'i' | 'o' | 'u' | 'y'\
    \ => 0,\n                _ => 1,\n            };\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmptsp_d4wp.rs:40:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !is_vowel(c) {\n                count += 1;\n            }\n        }\n \
    \   }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpcjyv7rar.rs:25:43\n\
    \   |\n25 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             match c {\n                    'a' | 'e' | 'i' | 'o' | 'u' => {},\n\
    \                    _ => count += 1,\n                }\n            } else {\n\
    \                match c {\n                    'A' | 'E' | 'I' | 'O' | 'U' =>\
    \ {},\n                    _ => count += 1,\n                }\n            }\n\
    \            word.push(c);\n        } else {\n            if count == n {\n  \
    \              result.push(word);\n            }\n            count = 0;\n   \
    \         word = String::new();\n        }\n    }\n    if count == n {\n     \
    \   result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                count += 1;\n            }\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            word = String::new();\n            count = 0;\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpaewgxrv1.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if consonants ==\
    \ n {\n                result.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp06v9jb16.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() && !c.is_vowel()\
    \ {\n                consonants += 1;\n            }\n            word.push(c);\n\
    \        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprb5eztzx.rs:18:39\n   |\n18 |             if c.is_lowercase()\
    \ && !c.is_vowel() {\n   |                                       ^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !c.is_vowel() {\n                consonants += 1;\n          \
    \  }\n        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptl4u8ppj.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpckdck7y1.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut count = 0;\n    let mut\
    \ word = String::new();\n    for c in s.chars() {\n        if c == ' ' {\n   \
    \         if count == n {\n                result.push(word);\n            }\n\
    \            count = 0;\n            word = String::new();\n        } else {\n\
    \            if !vowels.contains(&c) {\n                count += 1;\n        \
    \    }\n            word.push(c);\n        }\n    }\n    if count == n {\n   \
    \     result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmptnn_c2wm.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmps6e3hwst.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !c.is_vowel() {\n                consonants += 1;\n          \
    \  }\n        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp20meyvqe.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if !is_vowel(c) {\n                consonants += 1;\n            }\n   \
    \     }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpby09l27e.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                res.push(word);\n            }\n         \
    \   word = String::new();\n            count = 0;\n        }\n    }\n    if count\
    \ == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_2w400tn.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                count += 1;\n            }\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            word = String::new();\n            count = 0;\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpeep995hu.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|w|\
    \ w.chars().filter(|c| !c.is_vowel()).count() as isize == n)\n        .map(|w|\
    \ w.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp2_vsckn6.rs:14:45\n   |\n14 |         .filter(|w|\
    \ w.chars().filter(|c| !c.is_vowel()).count() as isize == n)\n   |           \
    \                                  ^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut consonants = 0;\n    for c in\
    \ s.chars() {\n        if c == ' ' {\n            if consonants == n {\n     \
    \           result.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2w3797mo.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjvlltrve.rs:17:45\n   |\n17 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut consonants = 0;\n    for c in\
    \ s.chars() {\n        if c == ' ' {\n            if consonants == n {\n     \
    \           words.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpzh94nj3y.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp96a2uqb_.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpwqpbv910.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                consonants += 1;\n            }\n        } else\
    \ {\n            if consonants == n {\n                words.push(word);\n   \
    \         }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpku5q3d8e.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmput9i1gzv.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if c.is_ascii_alphabetic() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp_oiq2lh7.rs:17:46\n   |\n17 |             if\
    \ c.is_ascii_alphabetic() && !c.is_ascii_vowel() {\n   |                     \
    \                         ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n            \
    \    count += 1;\n            }\n        }\n    }\n    if count == n {\n     \
    \   result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmps63a7hyl.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n     \
    \           if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n  \
    \                  count = 0;\n                } else {\n                    count\
    \ += 1;\n                }\n            } else {\n                if c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                    count\
    \ = 0;\n                } else {\n                    count += 1;\n          \
    \      }\n            }\n            word.push(c);\n        } else {\n       \
    \     if count == n {\n                res.push(word);\n            }\n      \
    \      count = 0;\n            word = String::new();\n        }\n    }\n    if\
    \ count == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpkrgsmw_o.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !is_vowel(c) {\n                consonants += 1;\n            }\n        } else\
    \ {\n            if consonants == n {\n                result.push(word);\n  \
    \          }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6srs543v.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !is_vowel(c) {\n                count += 1;\n            }\n        }\n \
    \   }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmplkqa4epf.rs:25:43\n\
    \   |\n25 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpcogl2wrb.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ words.push(word);\n            }\n            word = String::new();\n      \
    \      consonants = 0;\n        } else {\n            word.push(c);\n        \
    \    if !is_vowel(c) {\n                consonants += 1;\n            }\n    \
    \    }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n  \
    \  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpac2zayvx.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !is_vowel(c)\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp461c_eln.rs:18:43\n\
    \   |\n18 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_vowel() {\n         \
    \       consonants = 0;\n            } else {\n                consonants += 1;\n\
    \            }\n            word.push(c);\n        } else {\n            if consonants\
    \ == n {\n                result.push(word);\n            }\n            word\
    \ = String::new();\n            consonants = 0;\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkugq3n6d.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpee1_6ji0.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4sglcuyr.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpy13z13aj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_vowel() {\n             \
    \   count = 0;\n                word.push(c);\n            } else {\n        \
    \        count += 1;\n                word.push(c);\n            }\n        }\
    \ else {\n            if count == n {\n                result.push(word);\n  \
    \          }\n            count = 0;\n            word = String::new();\n    \
    \    }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnvq2o6dp.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7s26tizi.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !c.is_vowel() {\n \
    \               count += 1;\n            }\n        }\n    }\n    if count ==\
    \ n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn84ot5ls.rs:25:19\n   |\n25 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpcg6b7072.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c.is_ascii_lowercase() && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n            word.push(c);\n        }\n    }\n    if count == n {\n  \
    \      result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp3b_va_9i.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        words.push(word);\n  \
    \  }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp14jjw3t9.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|w|\
    \ w.chars().filter(|c| !\"aeiou\".contains(*c)).count() as isize == n)\n     \
    \   .map(|w| w.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpt528_c1s.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp10ct9h2k.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp8dgy5pyg.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmphoeqhgzu.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    continue;\n                }\n            }\n           \
    \ count += 1;\n            word.push(c);\n        } else {\n            if count\
    \ == n {\n                result.push(word);\n            }\n            count\
    \ = 0;\n            word = String::new();\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmpvd1qb6nc.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        words.push(word);\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp82a8slkj.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|word|\
    \ word.chars().filter(|c| is_consonant(*c)).count() as isize == n)\n        .map(|word|\
    \ word.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpdighvtof.rs:14:48\n   |\n14 |         .filter(|word| word.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n)\n   |                             \
    \                   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpg76xeh33.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpclejig00.rs:17:17\n\
    \   |\n17 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if !c.is_vowel() {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgzeogc7u.rs:17:19\n   |\n17 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpqoije2dt.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpknl14mua.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if c.is_ascii_lowercase() && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpjg41vnqd.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpsdbi__cr.rs:17:45\n   |\n17 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if is_consonant(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpr3qcadhs.rs:24:16\n   |\n24 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for ch in\
    \ word.chars() {\n            if !is_vowel(ch) {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpbimov0_v.rs:17:17\n\
    \   |\n17 |             if !is_vowel(ch) {\n   |                 ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      count = 0;\n            word = String::new();\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpvcrgqvxn.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmplxk_h4q6.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c == ' ' {\n            if count == n {\n\
    \                result.push(word);\n            }\n            word = String::new();\n\
    \            count = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        count += 1;\n            }\n        }\n    }\n    if count == n {\n \
    \       result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpawr_kvn3.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmprzr8oim8.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut words = s.split_whitespace();\n    for word in words {\n        let mut\
    \ count = 0;\n        for c in word.chars() {\n            if !c.is_vowel() {\n\
    \                count += 1;\n            }\n        }\n        if count == n\
    \ {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8dlsgc_4.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if consonants ==\
    \ n {\n                result.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2uqx22_n.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3fb8s0ik.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            word = String::new();\n            count = 0;\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpqw_ldbsp.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if consonants ==\
    \ n {\n                result.push(word);\n            }\n            word = String::new();\n\
    \            consonants = 0;\n        } else {\n            word.push(c);\n  \
    \          if !is_vowel(c) {\n                consonants += 1;\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_zjlkjoy.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !c.is_vowel() {\n                consonants += 1;\n          \
    \  }\n        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp1vjcrar_.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if !c.is_vowel() {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpfk74c1ys.rs:17:19\n   |\n17 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpd5ewxvwn.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if c.is_ascii_alphabetic() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpmmutvct9.rs:17:46\n   |\n17 |             if\
    \ c.is_ascii_alphabetic() && !c.is_ascii_vowel() {\n   |                     \
    \                         ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3lbafalu.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmps3biwmim.rs:18:45\n   |\n18 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                words.push(word);\n            }\n       \
    \     word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        words.push(word);\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpghhikmiw.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    for word\
    \ in s.split_whitespace() {\n        let mut count = 0;\n        for c in word.chars()\
    \ {\n            if !c.is_vowel() {\n                count += 1;\n           \
    \ }\n        }\n        if count == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp7jc6ygro.rs:17:19\n   |\n17 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut consonants: isize = 0;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !is_vowel(c) {\n                consonants += 1;\n           \
    \ }\n        } else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3ymof0rt.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp7z1ct7in.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqt2ocdn1.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ consonants = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if consonants == n {\n                res.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        } else {\n            word.push(c);\n            if c != 'a' && c !=\
    \ 'e' && c != 'i' && c != 'o' && c != 'u' {\n                consonants += 1;\n\
    \            }\n        }\n    }\n    if consonants == n {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpjy8lqytg.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if c.is_lowercase() {\n           \
    \     count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                res.push(word);\n            }\n\
    \            count = 0;\n            word = String::new();\n        }\n    }\n\
    \    if count == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpzs5nc6hv.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let mut count = 0;\n        for c in\
    \ word.chars() {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp00ssxotu.rs:17:17\n\
    \   |\n17 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     consonants += if \"bcdfghjklmnpqrstvwxyz\".contains(c) { 1 } else { 0 };\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpr4g5y_u_.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        consonants += 1;\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmptqe3mkct.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !is_vowel(c) {\n                count += 1;\n            }\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmprg043bo3.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !c.is_vowel() {\n                count += 1;\n            }\n\
    \        } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpivb7dm9e.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut word: String = String::new();\n    let mut count: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            if c.is_lowercase()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmph5zep6fd.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !is_vowel(c) {\n                count += 1;\n            }\n        }\n \
    \   }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6_2p6l4f.rs:25:43\n\
    \   |\n25 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut current_word = String::new();\n    let mut current_consonants = 0;\n   \
    \ for c in s.chars() {\n        if c.is_alphabetic() {\n            current_word.push(c);\n\
    \            if !is_vowel(c) {\n                current_consonants += 1;\n   \
    \         }\n        } else {\n            if current_consonants == n {\n    \
    \            result.push(current_word);\n            }\n            current_word\
    \ = String::new();\n            current_consonants = 0;\n        }\n    }\n  \
    \  if current_consonants == n {\n        result.push(current_word);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8ahkb2cp.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' {\n                count += 1;\n            }\n            word.push(c);\n\
    \        }\n    }\n    if count == n {\n        result.push(word);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp2uac_u4s.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    for word\
    \ in s.split_whitespace() {\n        let mut cnt = 0;\n        for c in word.chars()\
    \ {\n            if !c.is_vowel() {\n                cnt += 1;\n            }\n\
    \        }\n        if cnt == n {\n            res.push(word.to_string());\n \
    \       }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmplly0l402.rs:17:19\n   |\n17 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c.is_ascii_lowercase() && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n            word.push(c);\n        }\n    }\n    if count == n {\n  \
    \      result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp40ldfenm.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprglve02a.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && !is_vowel(c)\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       } else {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      }\n    }\n    if count == n {\n        result.push(word);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpip25tqcp.rs:18:43\n\
    \   |\n18 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpqiwwyqap.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' {\n                count += 1;\n            }\n            word.push(c);\n\
    \        }\n    }\n    if count == n {\n        result.push(word);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpzcbw4jif.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if !is_vowel(c) {\n               \
    \ count += 1;\n            }\n            word.push(c);\n        } else {\n  \
    \          if count == n {\n                res.push(word);\n            }\n \
    \           count = 0;\n            word = String::new();\n        }\n    }\n\
    \    if count == n {\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpwwj9zweu.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_vowel() {\n             \
    \   count = 0;\n                word.clear();\n            } else {\n        \
    \        count += 1;\n                word.push(c);\n            }\n        }\
    \ else {\n            if count == n {\n                result.push(word.clone());\n\
    \            }\n            count = 0;\n            word.clear();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpygdo5t0j.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    continue;\n                }\n            }\n           \
    \ count += 1;\n            word.push(c);\n        } else {\n            if count\
    \ == n {\n                result.push(word);\n            }\n            count\
    \ = 0;\n            word = String::new();\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmpfovwx8gq.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpa9tg_6ht.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !is_vowel(c) {\n                count += 1;\n            }\n        }\n \
    \   }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7kikykue.rs:25:43\n\
    \   |\n25 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !c.is_vowel() {\n                consonants += 1;\n            }\n        }\
    \ else {\n            if consonants == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmps08037t1.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut v: Vec<String> = Vec::new();\n\
    \    let mut c: isize = 0;\n    let mut w: String = String::new();\n    for c\
    \ in s.chars() {\n        if c == ' ' {\n            if count_consonants(&w) ==\
    \ n {\n                v.push(w.clone());\n            }\n            w = String::new();\n\
    \        } else {\n            w.push(c);\n        }\n    }\n    if count_consonants(&w)\
    \ == n {\n        v.push(w);\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpg12wn2oa.rs:18:16\n   |\n18 |             if count_consonants(&w)\
    \ == n {\n   |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_consonants` in this scope\n  --> /tmp/tmpg12wn2oa.rs:26:8\n\
    \   |\n26 |     if count_consonants(&w) == n {\n   |        ^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       }\n    }\n    if count == n {\n        result.push(word);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpvuh54req.rs:24:45\n   |\n24 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ result.push(word);\n            }\n            word = String::new();\n     \
    \       consonants = 0;\n        } else {\n            word.push(c);\n       \
    \     if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n        \
    \        consonants += 1;\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpl36dpksz.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7t8qfawy.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !is_vowel(c) {\n         \
    \       consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpw6voef1g.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && c !=\
    \ 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n                count\
    \ += 1;\n            }\n            word.push(c);\n        } else {\n        \
    \    if count == n {\n                result.push(word);\n            }\n    \
    \        count = 0;\n            word = String::new();\n        }\n    }\n   \
    \ if count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmppyzl_81v.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    for word\
    \ in s.split_whitespace() {\n        let mut count = 0;\n        for c in word.chars()\
    \ {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n        \
    \        count += 1;\n            }\n        }\n        if count == n {\n    \
    \        res.push(word.to_string());\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp7nhbk1m6.rs:17:45\n   |\n17 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgsqrhzry.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      count = 0;\n            word = String::new();\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2ubvceqo.rs:19:17\n\
    \   |\n19 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            word.push(c);\n            if !c.is_vowel()\
    \ {\n                count += 1;\n            }\n        } else {\n          \
    \  if count == n {\n                result.push(word);\n            }\n      \
    \      word = String::new();\n            count = 0;\n        }\n    }\n    if\
    \ count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmphk9f3f6j.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpnq0t3ivy.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if !is_vowel(c) {\n             \
    \   count += 1;\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp61og3ll3.rs:18:17\n\
    \   |\n18 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            word.push(c);\n            if c.is_ascii_lowercase()\
    \ && !is_vowel(c) {\n                count += 1;\n            }\n        }\n \
    \   }\n    if count == n {\n        words.push(word);\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7sz4bt89.rs:25:43\n\
    \   |\n25 |             if c.is_ascii_lowercase() && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut consonants = 0;\n    let mut word = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if !c.is_vowel() {\n        \
    \        consonants += 1;\n            }\n            word.push(c);\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            consonants = 0;\n            word = String::new();\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6piarvyu.rs:18:19\n   |\n18 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            word.push(c);\n            if\
    \ !c.is_vowel() {\n                consonants += 1;\n            }\n        }\
    \ else {\n            if consonants == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_n9xvbyf.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmptq14701p.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut word = String::new();\n    let mut consonants = 0;\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            if consonants == n {\n               \
    \ words.push(word);\n            }\n            word = String::new();\n      \
    \      consonants = 0;\n        } else {\n            word.push(c);\n        \
    \    consonants += if \"bcdfghjklmnpqrstvwxyz\".contains(c) { 1 } else { 0 };\n\
    \        }\n    }\n    if consonants == n {\n        words.push(word);\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpive3myz5.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    continue;\n                }\n            }\n           \
    \ count += 1;\n            word.push(c);\n        } else {\n            if count\
    \ == n {\n                result.push(word);\n            }\n            count\
    \ = 0;\n            word = String::new();\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmpqu8_2xfl.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_vowel() {\n             \
    \   count = 0;\n                word.clear();\n            } else {\n        \
    \        count += 1;\n                word.push(c);\n            }\n        }\
    \ else {\n            if count == n {\n                result.push(word.clone());\n\
    \            }\n            count = 0;\n            word.clear();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpe4fs1gb1.rs:18:18\n   |\n18 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1f4qcxcz.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp_qsvn6vx.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() && c !=\
    \ 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n                count\
    \ += 1;\n            }\n            word.push(c);\n        } else {\n        \
    \    if count == n {\n                result.push(word);\n            }\n    \
    \        count = 0;\n            word = String::new();\n        }\n    }\n   \
    \ if count == n {\n        result.push(word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp3_hfugax.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n  \
    \      if c == ' ' {\n            if count == n {\n                res.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if c.is_ascii_lowercase() && !c.is_ascii_vowel()\
    \ {\n                count += 1;\n            }\n            word.push(c);\n \
    \       }\n    }\n    if count == n {\n        res.push(word);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpwiy_i0ee.rs:24:45\n   |\n24 |             if\
    \ c.is_ascii_lowercase() && !c.is_ascii_vowel() {\n   |                      \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1ovr98uz.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_ascii_lowercase() {\n   \
    \             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                    count = 0;\n                } else {\n                  \
    \  count += 1;\n                }\n            } else {\n                if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                 \
    \   count = 0;\n                } else {\n                    count += 1;\n  \
    \              }\n            }\n            word.push(c);\n        } else {\n\
    \            if count == n {\n                result.push(word);\n           \
    \ }\n            count = 0;\n            word = String::new();\n        }\n  \
    \  }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpvts8t5y6.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' {\n                count += 1;\n       \
    \     }\n        }\n    }\n    if count == n {\n        result.push(word);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpoy3jspwa.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if !is_vowel(c) {\n  \
    \              count += 1;\n            }\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpeio58e4h.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            if count == n {\n                result.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            if !is_vowel(c) {\n                count += 1;\n\
    \            }\n            word.push(c);\n        }\n    }\n    if count == n\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpeit6qrnm.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       count += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if count == n {\n                result.push(word);\n       \
    \     }\n            count = 0;\n            word = String::new();\n        }\n\
    \    }\n    if count == n {\n        result.push(word);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpo_twjcrr.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
