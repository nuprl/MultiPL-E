name: HumanEval_109_move_one_ball
language: rust
results:
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n        while\
    \ j < arr.len() {\n            if arr[i] > arr[j] {\n                let tmp =\
    \ arr[i];\n                arr[i] = arr[j];\n                arr[j] = tmp;\n \
    \           }\n            j += 1;\n        }\n        i += 1;\n    }\n    let\
    \ mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiowx26mf.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] == i as isize + 1 {\n \
    \           i += 1;\n        } else {\n            let tmp = arr[i];\n       \
    \     arr[i] = arr[tmp as usize - 1];\n            arr[tmp as usize - 1] = tmp;\n\
    \        }\n    }\n    for i in 0..arr.len() {\n        if arr[i] != i as isize\
    \ + 1 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 9', /tmp/tmpwufaa8ba.rs:28:22\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4a10900k.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            arr.rotate_right(1);\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            arr.remove(i);\n\
    \            arr.insert(0, arr[arr.len() - 1]);\n            arr.remove(arr.len()\
    \ - 1);\n            i = 0;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyqka0_5g.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppxwwfwmc.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    while count < arr.len() {\n        let mut i = arr.len() - 1;\n\
    \        while i > 0 {\n            if arr[i] < arr[i - 1] {\n               \
    \ arr.swap(i, i - 1);\n            }\n            i -= 1;\n        }\n       \
    \ count += 1;\n    }\n    arr == arr.iter().sorted().collect::<Vec<_>>()\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp165j_2re.rs:33:23\n   |\n33 |     arr ==\
    \ arr.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppmnnofej.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    let\
    \ mut min = arr[0];\n    for i in 0..arr.len() {\n        if arr[i] < min {\n\
    \            min = arr[i];\n            count += 1;\n        }\n    }\n    if\
    \ count > 1 {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppch1u4mr.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    for i in\
    \ 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmowlw0ew.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            arr.remove(i);\n        \
    \    arr.insert(0, arr[arr.len() - 1]);\n            arr.pop();\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkjb1qm92.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjtp3n9yo.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n  \
    \          if arr[j] < arr[j - 1] {\n                return false;\n         \
    \   }\n            arr.swap(i, j);\n            j -= 1;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdliknw0t.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_fredqr0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzroj9ul_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm46sqx7a.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    let mut\
    \ arr = arr;\n    arr.sort();\n    let mut count = 0;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] != i as isize + 1 {\n            count += 1;\n        }\n\
    \    }\n    if count > 1 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl8si0fxm.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8wtza53a.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu17dhe2m.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    let\
    \ mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    if count <= 1\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp30p51ywh.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy2z7tq16.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut j = arr.len()\
    \ - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n            arr.swap(i,\
    \ j);\n            j -= 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    arr.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph7pxbxpv.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgd6l5g4k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzb211kfz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4finqw54.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjwj3ialk.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min {\n    \
    \        return false;\n        }\n        min = arr[i];\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppg_3jien.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    while count < arr.len() {\n        let mut i = 0;\n        while\
    \ i < arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n                let\
    \ temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i\
    \ + 1] = temp;\n            }\n            i += 1;\n        }\n        count +=\
    \ 1;\n    }\n    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7srgz_jh.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr.iter().cloned().rev().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8vyz43yh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..arr.len() {\n        if arr[i] != i as isize + 1 {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7ciwsrjg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5_rvwwq_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5zxjrjak.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz866lvy1.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2hl1lt2j.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp457kc4o9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkxcwxelh.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb6p_auai.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg9unaa76.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmaf_eos1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp74yg5pea.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp10vmasyv.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ let mut min_index = 0;\n    for i in 1..arr.len() {\n        if arr[i] < min\
    \ {\n            min = arr[i];\n            min_index = i;\n        }\n    }\n\
    \    let mut max = arr[0];\n    let mut max_index = 0;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max {\n            max = arr[i];\n            max_index\
    \ = i;\n        }\n    }\n    if min_index == 0 && max_index == arr.len() - 1\
    \ {\n        return true;\n    }\n    if min_index == 0 && max_index == arr.len()\
    \ - 2 {\n        return true;\n    }\n    if min_index == 1 && max_index == arr.len()\
    \ - 1 {\n        return true;\n    }\n    if min_index == 1 && max_index == arr.len()\
    \ - 2 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1m0xzmdm.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfyp43udf.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] != i as isize + 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjtnsli9c.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt_37pcj7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwn8zwihv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphdschn6k.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip6ntrmp.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9v44cavr.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpehj2y2tt.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6kejxpik.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptk3in5ti.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6lx4plzj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    while count < arr.len() {\n        let mut min = arr[0];\n \
    \       let mut min_index = 0;\n        for i in 0..arr.len() {\n            if\
    \ arr[i] < min {\n                min = arr[i];\n                min_index = i;\n\
    \            }\n        }\n        if min_index == count {\n            count\
    \ += 1;\n        } else {\n            arr.remove(min_index);\n            arr.insert(0,\
    \ min);\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqrzpllgc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg8_ri4we.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5xkpgpk.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpsdda4bmk.rs:23:9\n\
    \   |\n23 |     arr == arr.iter().rev().collect::<Vec<_>>()\n   |         ^^ no\
    \ implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4je10o8.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.dedup();\n    arr.len() == 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6z1c_ocm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i += 1;\n        } else if arr[j] < arr[j - 1] {\n\
    \            let temp = arr[j];\n            arr[j] = arr[j - 1];\n          \
    \  arr[j - 1] = temp;\n            j -= 1;\n        } else {\n            i +=\
    \ 1;\n            j -= 1;\n        }\n    }\n    for i in 0..arr.len() - 1 {\n\
    \        if arr[i] > arr[i + 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpog8_r1e6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n        }\n        i += 1;\n    }\n    if count > 1 {\n\
    \        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    while j < arr.len()\
    \ {\n        if arr[i] > arr[j] {\n            count += 1;\n        }\n      \
    \  i += 1;\n        j += 1;\n    }\n    if count > 1 {\n        return false;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp816kpjbq.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n  \
    \          break;\n        }\n        i += 1;\n    }\n    while j > i {\n    \
    \    if arr[j] < arr[j - 1] {\n            break;\n        }\n        j -= 1;\n\
    \    }\n    if i == j {\n        return true;\n    }\n    let mut k = i + 1;\n\
    \    while k < j {\n        if arr[k] < arr[k - 1] {\n            return false;\n\
    \        }\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ n = arr.len();\n    if n == 0 {\n        return true;\n    }\n    let mut i\
    \ = 0;\n    while i < n - 1 {\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..n - 1 {\n        if arr[i] > arr[i + 1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp90lnqbjn.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          arr.rotate_right(1);\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpw5xhvyjv.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk62epilt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyj7lwny0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5uxqp9_k.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp649u4lbd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjwxj9kf5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyd8_fvaw.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr_copy = arr.clone();\n    arr_copy.sort();\n\
    \    arr == arr_copy\n}\n\nfn main() {\n    let candidate = move_one_ball;\n \
    \   assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjsjm86_n.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8mgjqb1e.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpso3i2ojn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptj3905jt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkjjfpwy4.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] != sorted_arr[i]\
    \ {\n            count += 1;\n        }\n    }\n    if count == 1 {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb458fobw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            arr.rotate_right(1);\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7orpv0sw.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2vb9uzct.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i + 1 < arr.len() && arr[i] >\
    \ arr[i + 1] {\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i = 0;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuzv0k4q1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i\
    \ < j {\n        if arr[i] > arr[j] {\n            count += 1;\n            i\
    \ += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    count <=\
    \ 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfjm9uigq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo5nae367.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr.iter().cloned().rev().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn_pcwdi1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpme3qc5q8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdohwhe0s.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4_om06dz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    let mut min_index = 0;\n    for i in 1..arr.len() {\n   \
    \     if arr[i] < min {\n            min = arr[i];\n            min_index = i;\n\
    \        }\n    }\n    let mut max = arr[0];\n    let mut max_index = 0;\n   \
    \ for i in 1..arr.len() {\n        if arr[i] > max {\n            max = arr[i];\n\
    \            max_index = i;\n        }\n    }\n    if min_index < max_index {\n\
    \        return false;\n    }\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        if arr[i] > arr[i + 1] {\n            return false;\n        }\n    \
    \    i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw6dmi89m.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpecq_50b4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgc4919zv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1zzouzqq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph2kcql_b.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    let mut i = 0;\n    while i < arr.len() {\n        if i\
    \ != min_index {\n            if arr[i] > arr[i + 1] {\n                return\
    \ false;\n            }\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptbtihqml.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp409pugad.rs:24:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg8ji_6d2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.dedup();\n    arr.len() == 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptoqmxfoz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr.iter().cloned().rev().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjkr7_2qw.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut sorted = arr.clone();\n    sorted.sort();\n\
    \    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] != sorted[i]\
    \ {\n            count += 1;\n        }\n    }\n    if count == 1 {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmp391lqf.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0uhsjx22.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnfiujimx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    let\
    \ mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    if count > 1\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    let\
    \ mut i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n   \
    \         if arr[i] < arr[0] {\n                count += 1;\n            }\n \
    \           i += 1;\n        } else {\n            if arr[i] > arr[i + 1] {\n\
    \                count += 1;\n            }\n            i += 1;\n        }\n\
    \    }\n    if count == 1 {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv364dqns.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            if count == 0 {\n                return true;\n         \
    \   } else {\n                return false;\n            }\n        }\n      \
    \  if arr[i] > arr[i + 1] {\n            count += 1;\n            if count > 1\
    \ {\n                return false;\n            }\n            let temp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n          \
    \  i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpixf_srdw.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ let mut max = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min\
    \ {\n            min = arr[i];\n        }\n        if arr[i] > max {\n       \
    \     max = arr[i];\n        }\n    }\n    if max - min == arr.len() as isize\
    \ - 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4e0v0fd0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpolpjuvs5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i + 1 < arr.len() && arr[i] >\
    \ arr[i + 1] {\n            arr.rotate_right(1);\n            i = 0;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    arr.windows(2).all(|w|\
    \ w[0] <= w[1])\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3kb02d1u.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    let mut temp = arr[0];\n    for i in 0..arr.len() {\n  \
    \      if i == arr.len() - 1 {\n            arr[i] = temp;\n        } else {\n\
    \            arr[i] = arr[i + 1];\n        }\n    }\n    let mut count = 0;\n\
    \    for i in 0..arr.len() {\n        if arr[i] < arr[i + 1] {\n            count\
    \ += 1;\n        }\n    }\n    if count == arr.len() - 1 {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmp5tg8dfee.rs:48:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpducnyntk.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n        }\n        i += 1;\n    }\n    if count == 1 {\n\
    \        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp440xo9w0.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ sorted = false;\n    let mut count = 0;\n    while !sorted {\n        sorted\
    \ = true;\n        for i in 0..arr.len()-1 {\n            if arr[i] > arr[i+1]\
    \ {\n                sorted = false;\n                count += 1;\n          \
    \      let temp = arr[i];\n                arr[i] = arr[i+1];\n              \
    \  arr[i+1] = temp;\n            }\n        }\n    }\n    count == 1\n}\n\nfn\
    \ main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxbdpbm2l.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut max_idx = 0;\n    let\
    \ mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] > max_val\
    \ {\n            max_val = arr[i];\n            max_idx = i;\n        }\n    }\n\
    \    let mut min_idx = 0;\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            min_val = arr[i];\n          \
    \  min_idx = i;\n        }\n    }\n    if max_idx == min_idx {\n        return\
    \ true;\n    }\n    let mut min_idx_2 = 0;\n    let mut min_val_2 = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] < min_val_2 && i != min_idx {\n\
    \            min_val_2 = arr[i];\n            min_idx_2 = i;\n        }\n    }\n\
    \    if min_idx_2 > max_idx {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvkdiy2pv.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpglj_iwck.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.dedup();\n    arr.len() == 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpelkt83in.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n        while\
    \ j < arr.len() {\n            if arr[i] > arr[j] {\n                let temp\
    \ = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    let\
    \ mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf0_w257i.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9i_yip5f.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvd6pcy5h.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ let mut max = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min\
    \ {\n            min = arr[i];\n        }\n        if arr[i] > max {\n       \
    \     max = arr[i];\n        }\n    }\n    if max - min == arr.len() as isize\
    \ - 1 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjivswrg9.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp99wt6mai.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    let mut l = 3;\n    let\
    \ mut m = 4;\n    let mut n = 5;\n    let mut o = 6;\n    let mut p = 7;\n   \
    \ let mut q = 8;\n    let mut r = 9;\n    let mut s = 10;\n    let mut t = 11;\n\
    \    let mut u = 12;\n    let mut v = 13;\n    let mut w = 14;\n    let mut x\
    \ = 15;\n    let mut y = 16;\n    let mut z = 17;\n    let mut aa = 18;\n    let\
    \ mut bb = 19;\n    let mut cc = 20;\n    let mut dd = 21;\n    let mut ee = 22;\n\
    \    let mut ff = 23;\n    let mut gg = 24;\n    let mut hh = 25;\n    let mut\
    \ ii = 26;\n    let mut jj = 27;\n    let mut kk = 28;\n    let mut ll = 29;\n\
    \    let mut mm = 30;\n    let mut nn = 31;\n    let mut oo = 32;\n    let mut\
    \ pp = 33;\n    let mut qq = 34;\n    let mut rr = 35;\n    let mut ss = 36;\n\
    \    let mut tt = 37;\n    let mut uu = 38;\n    let mut vv = 39;\n    let mut\
    \ ww = 40;\n    let mut xx = 41;\n    let mut yy = 42;\n    let mut zz = 43;\n\
    \    let mut aaa = 44;\n    let mut bbb = 45;\n    let mut ccc = 46;\n    let\
    \ mut ddd = 47;\n    let mut eee = 48;\n    let mut fff = 49;\n    let mut ggg\
    \ = 50;\n    let mut hhh = 51;\n    let mut iii = 52;\n    let mut jjj = 53;\n\
    \    let mut kkk = 54;\n    let mut lll = 55;\n    let mut mmm = 56;\n    let\
    \ mut nnn = 57;\n    let mut ooo = 58;\n\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdv19iz60.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < max_val {\n            return false;\n        }\n   \
    \     max_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuhjytpdw.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnnlnfxfn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz5wx554q.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min_val = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_val {\n            return false;\n        }\n   \
    \     min_val = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwfnr3oya.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut min = arr[0];\n    let mut max = arr[0];\n    for k in 0..arr.len()\
    \ {\n        if arr[k] < min {\n            min = arr[k];\n            i = k;\n\
    \        }\n        if arr[k] > max {\n            max = arr[k];\n           \
    \ j = k;\n        }\n    }\n    if i == j {\n        return true;\n    }\n   \
    \ let mut temp = arr[i];\n    for k in (i..j).rev() {\n        arr[k + 1] = arr[k];\n\
    \    }\n    arr[j] = temp;\n    let mut flag = true;\n    for k in 0..arr.len()\
    \ - 1 {\n        if arr[k] > arr[k + 1] {\n            flag = false;\n       \
    \     break;\n        }\n    }\n    flag\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl8rv9rbu.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvfaj0gyv.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n   \
    \ let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n\
    \    let mut eee = 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut\
    \ hhh = 0;\n    let mut iii = 0;\n    let mut jjj = 0;\n    let mut kkk = 0;\n\
    \    let mut lll = 0;\n    let mut mmm = 0;\n    let mut nnn = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdnxruijl.rs:20:38\n   |\n\
    20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------      \
    \               ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            if count == 0 {\n                return true;\n         \
    \   } else {\n                return false;\n            }\n        }\n      \
    \  if arr[i] > arr[i + 1] {\n            count += 1;\n            if count > 1\
    \ {\n                return false;\n            }\n            let temp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n          \
    \  i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4mznf13e.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n    }\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n \
    \       if arr[i] == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    let mut new_arr = vec![];\n    for i in min_index..arr.len()\
    \ {\n        new_arr.push(arr[i]);\n    }\n    for i in 0..min_index {\n     \
    \   new_arr.push(arr[i]);\n    }\n    let mut new_arr = new_arr;\n    let mut\
    \ flag = true;\n    for i in 1..new_arr.len() {\n        if new_arr[i] < new_arr[i\
    \ - 1] {\n            flag = false;\n            break;\n        }\n    }\n  \
    \  flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6wl_4d_w.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = temp;\n            i = 0;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpipbr_6de.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzy7ib3v7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj2iyn9rm.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp815wtjx4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqz6sem63.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr1oge7_c.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    let mut\
    \ arr = arr;\n    let mut count = 0;\n    while count < arr.len() {\n        let\
    \ mut i = 0;\n        while i < arr.len() - 1 {\n            if arr[i] > arr[i\
    \ + 1] {\n                let temp = arr[i];\n                arr[i] = arr[i +\
    \ 1];\n                arr[i + 1] = temp;\n            }\n            i += 1;\n\
    \        }\n        count += 1;\n    }\n    for i in 0..arr.len() - 1 {\n    \
    \    if arr[i] > arr[i + 1] {\n            return false;\n        }\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7o3b5zfc.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    if arr.len()\
    \ == 0 {\n        return true;\n    }\n    arr.sort();\n    let mut count = 0;\n\
    \    for i in 0..arr.len() {\n        if arr[i] != i as isize + 1 {\n        \
    \    count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp80uicfri.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n  \
    \          break;\n        }\n        i += 1;\n    }\n    while j > i {\n    \
    \    if arr[j] < arr[j - 1] {\n            break;\n        }\n        j -= 1;\n\
    \    }\n    if i == j {\n        return true;\n    }\n    let mut k = i + 1;\n\
    \    while k < j {\n        if arr[k] < arr[k - 1] {\n            return false;\n\
    \        }\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbu_5v0jq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n  \
    \          let tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i\
    \ + 1] = tmp;\n            i = 0;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfnzwd_t6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() < 2 {\n        return\
    \ true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] < min {\n            return false;\n        }\n        min = arr[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnjo_1g4_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let temp = arr[i];\n    \
    \        arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n   \
    \     i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp70i3shu6.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i + 1\
    \ < arr.len() && arr[i] > arr[i + 1] {\n            count += 1;\n            if\
    \ count > 1 {\n                return false;\n            }\n            let temp\
    \ = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn9vb8gdj.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr.iter().cloned().rev().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaib3e9qq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl__cgnhx.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu94kkun4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptm2i2ldr.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 0..arr.len() {\n        if arr[i] < min {\n            min = arr[i];\n\
    \        }\n        if arr[i] > min {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi7d5owya.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwxv0tulv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            arr.rotate_right(1);\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while count < arr.len() {\n        if arr[i]\
    \ > arr[i + 1] {\n            let temp = arr[i];\n            arr[i] = arr[i +\
    \ 1];\n            arr[i + 1] = temp;\n            i = 0;\n            count =\
    \ 0;\n        } else {\n            count += 1;\n            i += 1;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n \
    \   assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpwa2uequr.rs:25:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_hli1cru.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi95gp41b.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() <= 1 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplxiq1ptc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] == i as isize + 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count == arr.len() {\n        return true;\n\
    \    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i]\
    \ < min {\n            min = arr[i];\n        }\n    }\n    let mut index = 0;\n\
    \    for i in 0..arr.len() {\n        if arr[i] == min {\n            index =\
    \ i;\n            break;\n        }\n    }\n    let mut temp = arr[index];\n \
    \   for i in index..arr.len() - 1 {\n        arr[i] = arr[i + 1];\n    }\n   \
    \ arr[arr.len() - 1] = temp;\n    let mut count = 0;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] == i as isize + 1 {\n            count += 1;\n        }\n\
    \    }\n    if count == arr.len() {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpglga8n9e.rs:47:9\n\
    \   |\n47 |     let mut temp = arr[index];\n   |         ----^^^^\n   |      \
    \   |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `arr` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpglga8n9e.rs:51:9\n   |\n51 |     arr[arr.len()\
    \ - 1] = temp;\n   |     ----^^^^^^^^^-----\n   |     |   |\n   |     |   immutable\
    \ borrow occurs here\n   |     mutable borrow occurs here\n   |     mutable borrow\
    \ later used here\n   |\nhelp: try adding a local storing this...\n  --> /tmp/tmpglga8n9e.rs:51:9\n\
    \   |\n51 |     arr[arr.len() - 1] = temp;\n   |         ^^^^^^^^^\nhelp: ...and\
    \ then using that local here\n  --> /tmp/tmpglga8n9e.rs:51:5\n   |\n51 |     arr[arr.len()\
    \ - 1] = temp;\n   |     ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkkwsu2uq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1,\
    \ 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiide0qyl.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            if arr[i] < arr[0] {\n                count += 1;\n     \
    \       }\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n \
    \           count += 1;\n        }\n        i += 1;\n    }\n    count <= 1\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4r2s9acm.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i < j {\n        if arr[i] > arr[i + 1] {\n  \
    \          break;\n        }\n        i += 1;\n    }\n    while j > i {\n    \
    \    if arr[j] < arr[j - 1] {\n            break;\n        }\n        j -= 1;\n\
    \    }\n    if i == j {\n        return true;\n    }\n    let mut k = i + 1;\n\
    \    while k < j {\n        if arr[k] < arr[k - 1] {\n            return false;\n\
    \        }\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps3wrrtsw.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    let mut\
    \ j = 1;\n    while j < arr.len() {\n        if arr[i] > arr[j] {\n          \
    \  return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqkkpubhw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg0549lju.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut min = arr[0];\n   \
    \ for i in 1..arr.len() {\n        if arr[i] < min {\n            return false;\n\
    \        }\n        min = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvsj8tjo6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptuqds83o.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] == i as isize + 1 {\n            count\
    \ += 1;\n        }\n    }\n    if count == arr.len() {\n        return true;\n\
    \    }\n    arr.sort();\n    let mut count = 0;\n    for i in 0..arr.len() {\n\
    \        if arr[i] == i as isize + 1 {\n            count += 1;\n        }\n \
    \   }\n    if count == arr.len() {\n        return true;\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph7h8tzlh.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8alydyft.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n   \
    \ while k < arr.len() {\n        if arr[i] > arr[j] {\n            if arr[j] >\
    \ arr[k] {\n                count += 1;\n                arr.remove(j);\n    \
    \            arr.insert(0, arr[arr.len() - 1]);\n                arr.pop();\n\
    \                i = 0;\n                j = 1;\n                k = 2;\n    \
    \        } else {\n                i += 1;\n                j += 1;\n        \
    \        k += 1;\n            }\n        } else {\n            i += 1;\n     \
    \       j += 1;\n            k += 1;\n        }\n    }\n    if count == 1 {\n\
    \        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8r0bmb36.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ temp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9qxv2sfv.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() - 1 && arr[j] > arr[j + 1] {\n                j +=\
    \ 1;\n            }\n            i = j;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwf3smkvn.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min {\n    \
    \        return false;\n        }\n        min = arr[i];\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptjwg3yr8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr == arr\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj906xj33.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() <= 1 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp435mp78y.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ca50gfp.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0 {\n        if arr[i] < arr[i - 1] {\n  \
    \          let temp = arr[i];\n            arr[i] = arr[i - 1];\n            arr[i\
    \ - 1] = temp;\n            i += 1;\n        }\n        i -= 1;\n    }\n    arr\
    \ == arr.iter().sorted().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp6u34tpia.rs:32:23\n   |\n32 |     arr ==\
    \ arr.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let temp =\
    \ arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb0vr7g7t.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut max = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < max {\n            return false;\n        }\n        max\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpttn321rc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        if arr[i]\
    \ > arr[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_9n6bvio.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ min = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min {\n    \
    \        return false;\n        }\n        min = arr[i];\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8k_j9csz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1frbsh16.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp367eq06t.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i]\
    \ > arr[i + 1] {\n            count += 1;\n            if count > 1 {\n      \
    \          return false;\n            }\n            let mut j = i + 1;\n    \
    \        while j < arr.len() - 1 && arr[j] > arr[j + 1] {\n                j +=\
    \ 1;\n            }\n            if j == arr.len() - 1 {\n                return\
    \ false;\n            }\n            let tmp = arr[j];\n            for k in (i..j).rev()\
    \ {\n                arr[k + 1] = arr[k];\n            }\n            arr[i] =\
    \ tmp;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk21cw1ub.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n        }\n        i += 1;\n    }\n    if count > 1 {\n\
    \        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.dedup();\n    arr.len() == 1\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq5ij57k2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            let temp = arr[i];\n            arr[i] = arr[i\
    \ + 1];\n            arr[i + 1] = temp;\n            i = 0;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    count == 1\n}\n\nfn main() {\n   \
    \ let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]),\
    \ true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkxhe8hvx.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if i == arr.len()\
    \ - 1 {\n            break;\n        }\n        if arr[i] > arr[i + 1] {\n   \
    \         count += 1;\n            if count > 1 {\n                return false;\n\
    \            }\n            let temp = arr[i];\n            arr[i] = arr[i + 1];\n\
    \            arr[i + 1] = temp;\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n  \
    \  assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnhvbtx48.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut temp = 0;\n\
    \    let mut flag = false;\n    let mut flag1 = false;\n    let mut flag2 = false;\n\
    \    let mut flag3 = false;\n    let mut flag4 = false;\n    let mut flag5 = false;\n\
    \    let mut flag6 = false;\n    let mut flag7 = false;\n    let mut flag8 = false;\n\
    \    let mut flag9 = false;\n    let mut flag10 = false;\n    let mut flag11 =\
    \ false;\n    let mut flag12 = false;\n    let mut flag13 = false;\n    let mut\
    \ flag14 = false;\n    let mut flag15 = false;\n    let mut flag16 = false;\n\
    \    let mut flag17 = false;\n    let mut flag18 = false;\n    let mut flag19\
    \ = false;\n    let mut flag20 = false;\n    let mut flag21 = false;\n    let\
    \ mut flag22 = false;\n    let mut flag23 = false;\n    let mut flag24 = false;\n\
    \    let mut flag25 = false;\n    let mut flag26 = false;\n    let mut flag27\
    \ = false;\n    let mut flag28 = false;\n    let mut flag29 = false;\n    let\
    \ mut flag30 = false;\n    let mut flag31 = false;\n    let mut flag32 = false;\n\
    \    let mut flag33 = false;\n    let mut flag34 = false;\n    let mut flag35\
    \ = false;\n    let mut flag36 = false;\n    let mut flag37 = false;\n    let\
    \ mut flag38 = false;\n    let mut flag39 = false;\n    let mut flag40 = false;\n\
    \    let mut flag41 = false;\n    let mut flag42 = false;\n    let mut flag43\
    \ = false;\n    let mut flag44 = false;\n    let mut flag45 = false;\n    let\
    \ mut flag46 = false;\n    let mut flag47 = false;\n    let mut flag48 = false;\n\
    \    let mut flag49 = false;\n    let mut flag50 = false;\n    let mut flag51\
    \ = false;\n    let mut flag\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoufkibwj.rs:78:17\n   |\n\
    78 |     let mut flag\n   |                 ^ help: add `;` here\n79 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoufkibwj.rs:20:38\n\
    \   |\n20 | fn move_one_ball(arr: Vec<isize>) -> bool {\n   |    -------------\
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6y6zbcd0.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk_vv5e01.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if i == arr.len() - 1 {\n       \
    \     return true;\n        }\n        if arr[i] > arr[i + 1] {\n            let\
    \ tmp = arr[i];\n            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n\
    \            i = 0;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp55dsci5i.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut count = 0;\n    let\
    \ mut i = 0;\n    while i < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    if count > 1\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4,\
    \ 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    // Your code here!\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3,\
    \ 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n\
    \    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplv2nh6e4.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut arr = arr;\n    let mut i = 0;\n    while i\
    \ < arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            let tmp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = tmp;\n           \
    \ i = 0;\n        } else {\n            i += 1;\n        }\n    }\n    for i in\
    \ 0..arr.len() - 1 {\n        if arr[i] > arr[i + 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi1sls9i3.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.len() == 0 {\n       \
    \ return true;\n    }\n    let mut min = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] < min {\n            return false;\n        }\n        min\
    \ = arr[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = move_one_ball;\n\
    \    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3,\
    \ 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n\
    \    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplk6fgam5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpli28jyrk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    /// numbers in the array will be randomly ordered. Your task is to determine if\n\
    /// it is possible to get an array sorted in non-decreasing order by performing\
    \ \n/// the following operation on the given array:\n/// You are allowed to perform\
    \ right shift operation any number of times.\n/// One right shift operation means\
    \ shifting all elements of the array by one\n/// position in the right direction.\
    \ The last element of the array will be moved to\n/// the starting position in\
    \ the array i.e. 0th index. \n/// If it is possible to obtain the sorted array\
    \ by performing the above operation\n/// then return True else return False.\n\
    /// If the given array is empty then return True.\n/// Note: The given list is\
    \ guaranteed to have unique elements.\n/// For Example:\n/// move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n/// Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n/// be achieved for the given array.\n/// move_one_ball([3,\
    \ 5, 4, 1, 2])==>False\n/// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n/// array by performing any number of right shift operations.\n\
    fn move_one_ball(arr: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5,\
    \ 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n   \
    \ assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3,\
    \ 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjlsg5hkr.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
