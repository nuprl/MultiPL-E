name: HumanEval_115_max_fill
language: rust
results:
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n      \
    \      if sum > capacity {\n                sum = capacity;\n            }\n \
    \       }\n        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp0bohspbl.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                height += 1;\n            } else\
    \ {\n                height = 0;\n            }\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for row in grid {\n        let mut height =\
    \ 0;\n        for &cell in &row {\n            if cell == 1 {\n              \
    \  height += 1;\n            } else {\n                height = 0;\n         \
    \   }\n            let fill = min(height, max_height);\n            result +=\
    \ fill;\n            max_height = max(0, max_height - capacity);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpklrmh_6s.rs:39:26\n\
    \   |\n39 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmpklrmh_6s.rs:50:24\n   |\n50 |           \
    \  let fill = min(height, max_height);\n   |                        ^^^\n...\n\
    58 | fn main() {\n   | --------- similarly named function `main` defined here\n\
    \   |\nhelp: a function with a similar name exists\n   |\n50 |             let\
    \ fill = main(height, max_height);\n   |                        ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpklrmh_6s.rs:52:26\n\
    \   |\n52 |             max_height = max(0, max_height - capacity);\n   |    \
    \                      ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    (max_fill + capacity - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpsymb13qj.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    for row in &grid {\n       \
    \ for col in row {\n            if *col > max_col {\n                max_col =\
    \ *col;\n            }\n        }\n        if row.iter().sum::<isize>() > max_row\
    \ {\n            max_row = row.iter().sum::<isize>();\n        }\n    }\n    for\
    \ _ in 0..max_row {\n        for row in &mut grid {\n            for col in row\
    \ {\n                if *col > 0 {\n                    *col -= 1;\n         \
    \           count += 1;\n                }\n            }\n        }\n    }\n\
    \    for _ in 0..max_col {\n        for row in &mut grid {\n            for col\
    \ in row {\n                if *col > 0 {\n                    *col -= 1;\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpkx3q446l.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + max_fill %\
    \ capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpz_cpyi2h.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max = 0;\n    for row\
    \ in grid {\n        for &well in &row {\n            if well == 1 {\n       \
    \         max += 1;\n            }\n        }\n    }\n    let mut filled = 0;\n\
    \    while filled < max {\n        for row in grid {\n            for &well in\
    \ &row {\n                if well == 1 {\n                    filled += 1;\n \
    \                   if filled == max {\n                        break;\n     \
    \               }\n                }\n            }\n            if filled ==\
    \ max {\n                break;\n            }\n            count += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpq9_8v_nm.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpq9_8v_nm.rs:40:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n40  |         for row in grid {\n    |                    ^^^^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    let mut max_fill_index = 0;\n    let mut max_fill_row\
    \ = 0;\n    let mut max_fill_col = 0;\n    let mut max_fill_row_index = 0;\n \
    \   let mut max_fill_col_index = 0;\n    let mut max_fill_row_count = 0;\n   \
    \ let mut max_fill_col_count = 0;\n    let mut max_fill_row_count_index = 0;\n\
    \    let mut max_fill_col_count_index = 0;\n    let mut max_fill_row_count_max\
    \ = 0;\n    let mut max_fill_col_count_max = 0;\n    let mut max_fill_row_count_max_index\
    \ = 0;\n    let mut max_fill_col_count_max_index = 0;\n    let mut max_fill_row_count_max_index_index\
    \ = 0;\n    let mut max_fill_col_count_max_index_index = 0;\n    let mut max_fill_row_count_max_index_index_index\
    \ = 0;\n    let mut max_fill_col_count_max_index_index_index = 0;\n    let mut\
    \ max_fill_row_count_max_index_index_index_index = 0;\n    let mut max_fill_col_count_max_index_index_index_index\
    \ = 0;\n    let mut max_fill_row_count_max_index_index_index_index_index = 0;\n\
    \    let mut max_fill_col_count_max_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_row_count_max_index_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_col_count_max_index_index_index_index_index_index = 0;\n    let\
    \ mut max_fill_row_count_max_index_index_index_index_index_index_index = 0;\n\
    \    let mut max_fill_col_count_max_index_index_index_index_index_\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpen7rt7_q.rs:56:66\n   |\n\
    56 |     let mut max_fill_col_count_max_index_index_index_index_index_\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpen7rt7_q.rs:28:56\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |    --------                              \
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            if well == 1 {\n   \
    \             fill += 1;\n            } else {\n                max_fill = max_fill.max(fill);\n\
    \                fill = 0;\n            }\n        }\n        max_fill = max_fill.max(fill);\n\
    \        fill = 0;\n    }\n    (max_fill + capacity - 1) / capacity\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpm_vdkenk.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ n = grid.len();\n    let m = grid[0].len();\n    for i in 0..n {\n        for\
    \ j in 0..m {\n            if grid[i][j] == 1 {\n                count += 1;\n\
    \                let mut k = i;\n                while k < n && grid[k][j] ==\
    \ 1 {\n                    grid[k][j] = 0;\n                    k += 1;\n    \
    \            }\n                if k == n {\n                    break;\n    \
    \            }\n                let mut l = j;\n                while l < m &&\
    \ grid[k][l] == 1 {\n                    grid[k][l] = 0;\n                   \
    \ l += 1;\n                }\n                if l == m {\n                  \
    \  break;\n                }\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpmfl0045n.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += fill - capacity;\n\
    \                fill = capacity;\n            }\n        }\n        fill = 0;\n\
    \    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpdh4f5t_x.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut total_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                fill += 1;\n            }\n     \
    \   }\n        total_fill += fill;\n        max_fill = max_fill.max(fill);\n \
    \   }\n    let mut buckets = 0;\n    while max_fill > 0 {\n        buckets +=\
    \ 1;\n        max_fill -= capacity;\n    }\n    buckets + total_fill\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `6`', /tmp/tmpi7dbol57.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = 0;\n            }\n        }\n        if fill > 0 {\n          \
    \  max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpatjd_b4c.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n      \
    \      if sum > capacity {\n                sum = capacity;\n            }\n \
    \       }\n        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp5hvhouae.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut cur = 0;\n        for &c in &row {\n            cur += c;\n            if\
    \ cur > capacity {\n                cur = capacity;\n            }\n        }\n\
    \        max = max.max(cur);\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp4f20ylbr.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                height += 1;\n            } else\
    \ {\n                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        if max_height > capacity {\n         \
    \   result += max_height - capacity;\n            max_height = capacity;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpbn0dhsug.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpbn0dhsug.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2b4_bq8k.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpe6h66pqd.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + max_fill % capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpdnnwpm9e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpo5aqfn1k.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    for row in grid.iter_mut() {\n        let mut sum = 0;\n\
    \        for cell in row.iter_mut() {\n            sum += *cell;\n           \
    \ *cell = 0;\n        }\n        if sum > max_row {\n            max_row = sum;\n\
    \        }\n    }\n    for _ in 0..max_row {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell < capacity\
    \ {\n                    *cell += 1;\n                    count += 1;\n      \
    \          }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmpkq3ow4b6.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpm6j4yuzg.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + max_fill %\
    \ capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp0a8q2pvu.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    count + max - 1\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpkkwf503b.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp2epcx_6k.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmplgfxylbv.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpjtej__cw.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp4_k_3_hf.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpxahm6o_y.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    count + (max - 1) * capacity\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpnxwuu12z.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    (max_fill + capacity - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp556ky2lu.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in &grid {\n        let mut row_max = 0;\n\
    \        for &cell in row {\n            if cell > row_max {\n               \
    \ row_max = cell;\n            }\n        }\n        if row_max > max_height {\n\
    \            max_height = row_max;\n        }\n    }\n    for _ in 0..max_height\
    \ {\n        for row in &mut grid {\n            for cell in row {\n         \
    \       if *cell > 0 {\n                    *cell -= 1;\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpuxnn7jml.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp3uf_yd_e.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        if v == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &v in max_row.iter() {\n        let mut c = v;\n        while\
    \ c > 0 {\n            count += 1;\n            c -= capacity;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp5wpl3h_i.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n     \
    \       sum += cell;\n        }\n        max_row = max(max_row, sum);\n    }\n\
    \    for row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n\
    \            sum += cell;\n        }\n        result += max_row - sum;\n    }\n\
    \    result / capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppkk65es3.rs:36:19\n\
    \   |\n36 |         max_row = max(max_row, sum);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpxzeu9j1p.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = capacity;\n         \
    \       count += 1;\n            }\n            max = max.max(*cell);\n      \
    \  }\n    }\n    if max == 0 {\n        return 0;\n    }\n    let mut i = 0;\n\
    \    while i < grid.len() {\n        let mut j = 0;\n        while j < grid[i].len()\
    \ {\n            if grid[i][j] > 0 {\n                let mut k = i + 1;\n   \
    \             while k < grid.len() && grid[k][j] > 0 {\n                    grid[k][j]\
    \ -= 1;\n                    k += 1;\n                }\n                count\
    \ += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `6`', /tmp/tmp3fv1z3go.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut row_max\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              row_max += 1;\n            }\n        }\n        if row_max > max_height\
    \ {\n            max_height = row_max;\n        }\n    }\n    for _ in 0..max_height\
    \ {\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell == 1 {\n                    *cell = 0;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp86lwg9a7.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            max_fill = max_fill.max(fill);\n        }\n    }\n\
    \    max_fill / capacity + max_fill % capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp635gi5cx.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpmsdn47oe.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &x in &row {\n            sum += x;\n            if\
    \ sum > capacity {\n                sum = capacity;\n            }\n        }\n\
    \        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp3x9avn_k.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp7tfev1pm.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpauoywqj7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpu60xtjug.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = 0;\n            }\n        }\n        if fill > 0 {\n          \
    \  max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpusuju4jy.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpaehyk9cq.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpe99yzxi7.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut count = 0;\n        for &cell in &row {\n            if cell == 1 {\n  \
    \              count += 1;\n            }\n        }\n        max = max.max(count);\n\
    \    }\n    max / capacity + (max % capacity != 0) as isize\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpt80a_ku3.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        max_height = capacity;\n            }\n        }\n    }\n    while max_height\
    \ > 0 {\n        let mut next_max_height = 0;\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == max_height\
    \ {\n                    *cell -= 1;\n                    next_max_height = max(next_max_height,\
    \ *cell);\n                    count += 1;\n                }\n            }\n\
    \        }\n        max_height = next_max_height;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpnu8_vns5.rs:46:39\n\
    \   |\n46 |                     next_max_height = max(next_max_height, *cell);\n\
    \   |                                       ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            max_fill = max_fill.max(fill);\n        }\n    }\n\
    \    max_fill / capacity + max_fill % capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpxlhnyehd.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp_nbg00ss.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    if max > capacity {\n        return -1;\n    }\n    let mut result\
    \ = 0;\n    while count > 0 {\n        for row in grid.iter_mut() {\n        \
    \    for cell in row.iter_mut() {\n                if *cell > 0 {\n          \
    \          *cell -= 1;\n                    count -= 1;\n                }\n \
    \           }\n        }\n        result += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmplespkt1g.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &cell in &row {\n            if cell == 1 {\n   \
    \             max_fill += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    let mut row_idx = 0;\n    while fill < max_fill {\n        let row\
    \ = &grid[row_idx];\n        let mut col_idx = 0;\n        while col_idx < row.len()\
    \ {\n            if row[col_idx] == 1 {\n                fill += 1;\n        \
    \        count += 1;\n                col_idx += capacity as usize;\n        \
    \    } else {\n                col_idx += 1;\n            }\n        }\n     \
    \   row_idx += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpe4hsztq2.rs:41:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n41  |         let row = &grid[row_idx];\n    |                    ^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `grid`\nhelp: consider iterating over a slice of\
    \ the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n    |\n\
    31  |     for row in &grid {\n    |                +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n      \
    \      if sum > capacity {\n                sum = capacity;\n            }\n \
    \       }\n        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpu0i_mau4.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpvacb2dba.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpj2bbt4sn.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut row_max\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              row_max += 1;\n            }\n        }\n        max_height = max(max_height,\
    \ row_max);\n    }\n    for _ in 0..max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == 1 {\n\
    \                    *cell = 0;\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpjv5jsqpa.rs:39:22\n\
    \   |\n39 |         max_height = max(max_height, row_max);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp15f_avkm.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp0cmfinh1.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + if max_fill % capacity\
    \ == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmppiqh5f0x.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n      \
    \      if sum > capacity {\n                sum = capacity;\n            }\n \
    \       }\n        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpgh35i_db.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpnr70artm.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpkymt1em7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    let mut max_fill_index = 0;\n    for row in grid.iter_mut()\
    \ {\n        let mut fill = 0;\n        for (i, &cell) in row.iter().enumerate()\
    \ {\n            if cell == 1 {\n                fill += 1;\n            }\n \
    \           if fill > max_fill {\n                max_fill = fill;\n         \
    \       max_fill_index = i;\n            }\n        }\n        if fill > 0 {\n\
    \            count += 1;\n            for i in 0..=max_fill_index {\n        \
    \        row[i] = 0;\n            }\n        }\n        max_fill = 0;\n      \
    \  max_fill_index = 0;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpckg6mm2i.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp0547ugl1.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + (max_fill % capacity\
    \ != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp2kbq34n1.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpz8367no0.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    let mut max_index = 0;\n    for i in 0..grid.len() {\n   \
    \     for j in 0..grid[i].len() {\n            if grid[i][j] > max {\n       \
    \         max = grid[i][j];\n                max_index = j;\n            }\n \
    \       }\n        if max > 0 {\n            count += 1;\n            for j in\
    \ 0..grid[i].len() {\n                grid[i][j] = grid[i][j].saturating_sub(capacity);\n\
    \            }\n            grid[i][max_index] = 0;\n            max = 0;\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp2v_0mnsz.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &x in &row {\n            if x == 1 {\n    \
    \            fill += 1;\n            } else {\n                fill = 0;\n   \
    \         }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    if max_fill > capacity {\n        max_fill\
    \ - capacity\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpgzvjl5cm.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    let mut max_row = grid.len();\n    let\
    \ mut max_col = grid[0].len();\n    while row < max_row {\n        while col <\
    \ max_col {\n            if grid[row][col] == 1 {\n                count += 1;\n\
    \                let mut row_ = row;\n                while row_ < max_row &&\
    \ grid[row_][col] == 1 {\n                    grid[row_][col] = 0;\n         \
    \           row_ += 1;\n                }\n                let mut col_ = col;\n\
    \                while col_ < max_col && grid[row][col_] == 1 {\n            \
    \        grid[row][col_] = 0;\n                    col_ += 1;\n              \
    \  }\n            }\n            col += 1;\n        }\n        col = 0;\n    \
    \    row += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpg9axr8_i.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                height += 1;\n            } else\
    \ {\n                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        if max_height > capacity {\n            result += max_height - capacity;\n\
    \            max_height = capacity;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpzyhondvc.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpzyhondvc.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + (max_fill % capacity\
    \ != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpv_72terq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        let mut max = 0;\n        for &cell in &row {\n\
    \            max = std::cmp::max(max, cell);\n        }\n        row_max.push(max);\n\
    \    }\n    for &max in &row_max {\n        result += max / capacity;\n      \
    \  if max % capacity != 0 {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpghaet099.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpq36g4ru4.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &cell in &row {\n            sum += cell;\n      \
    \      if sum > capacity {\n                sum = capacity;\n            }\n \
    \       }\n        max = max.max(sum);\n    }\n    max\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpltvkwo9y.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            if well == 1 {\n   \
    \             max_fill += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    while fill < max_fill {\n        for row in grid {\n            for\
    \ &well in &row {\n                if well == 1 {\n                    fill +=\
    \ 1;\n                    if fill == max_fill {\n                        return\
    \ count;\n                    }\n                }\n            }\n          \
    \  count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpa9opapr3.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpa9opapr3.rs:40:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n40  |         for row in grid {\n    |                    ^^^^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        let mut row_max = 0;\n\
    \        for cell in row.iter_mut() {\n            if *cell > 0 {\n          \
    \      *cell -= 1;\n                row_max += 1;\n                count += 1;\n\
    \            }\n        }\n        max = max.max(row_max);\n    }\n    count +\
    \ (max + capacity - 1) / capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `6`', /tmp/tmpopee1jz8.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmptu96j60b.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    let mut max_fill_index = 0;\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               count += 1;\n            }\n        }\n        if count > max_fill\
    \ {\n            max_fill = count;\n            max_fill_index = i;\n        }\n\
    \        count = 0;\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                count += 1;\n         \
    \   }\n        }\n        if count == max_fill {\n            for j in 0..grid[i].len()\
    \ {\n                if grid[i][j] == 1 {\n                    grid[i][j] = 0;\n\
    \                }\n            }\n        }\n        count = 0;\n    }\n    let\
    \ mut count = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp621wrwl7.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp8eftwbc3.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity > 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmppd7v6xyi.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpxbbppn_e.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            if well == 1 {\n   \
    \             max_fill += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    for row in grid {\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            }\n            if fill == max_fill\
    \ {\n                count += 1;\n                fill = 0;\n            }\n \
    \       }\n        if fill > 0 {\n            count += 1;\n            fill =\
    \ 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmprgpexllj.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmprgpexllj.rs:39:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n39  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for &well in row.iter() {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max = max.max(fill);\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpq55qdfco.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n     \
    \       sum += cell;\n        }\n        max_row = max(max_row, sum);\n    }\n\
    \    for row in grid {\n        let mut sum = 0;\n        for &cell in &row {\n\
    \            sum += cell;\n        }\n        result += max_row - sum;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2z7jx4fm.rs:36:19\n\
    \   |\n36 |         max_row = max(max_row, sum);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    let mut max_row = vec![0; m];\n    for i in 0..n {\n\
    \        for j in 0..m {\n            max_row[j] = max(max_row[j], grid[i][j]);\n\
    \        }\n    }\n    for i in 0..n {\n        for j in 0..m {\n            result\
    \ += max_row[j] - grid[i][j];\n        }\n    }\n    result / capacity + if result\
    \ % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpqvbday_i.rs:35:26\n\
    \   |\n35 |             max_row[j] = max(max_row[j], grid[i][j]);\n   |      \
    \                    ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmplutu85b_.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut row_max = vec![0; grid.len()];\n\
    \    for row in grid {\n        let mut max = 0;\n        for &cell in &row {\n\
    \            max = max.max(cell);\n        }\n        row_max.push(max);\n   \
    \ }\n    let mut col_max = vec![0; grid[0].len()];\n    for col in 0..grid[0].len()\
    \ {\n        let mut max = 0;\n        for row in &grid {\n            max = max.max(row[col]);\n\
    \        }\n        col_max.push(max);\n    }\n    for row in 0..grid.len() {\n\
    \        for col in 0..grid[0].len() {\n            let max = row_max[row].min(col_max[col]);\n\
    \            result += max - grid[row][col];\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpzpy9gigg.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpzpy9gigg.rs:38:31\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n38  |     let mut col_max = vec![0; grid[0].len()];\n    |              \
    \                 ^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n31  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp053csm5q.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp_q3kf5q_.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut res = 0;\n    let mut max_height = 0;\n    for\
    \ row in grid {\n        let mut height = 0;\n        for &well in &row {\n  \
    \          if well == 1 {\n                height += 1;\n            } else {\n\
    \                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \    }\n    for row in grid {\n        let mut height = 0;\n        for &well\
    \ in &row {\n            if well == 1 {\n                height += 1;\n      \
    \      } else {\n                res += max(0, max_height - height);\n       \
    \         height = 0;\n            }\n        }\n        res += max(0, max_height\
    \ - height);\n    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpcsvvxmul.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpcsvvxmul.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpcsvvxmul.rs:49:24\n   |\n49 |                 res += max(0,\
    \ max_height - height);\n   |                        ^^^ not found in this scope\n\
    \   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpcsvvxmul.rs:53:16\n\
    \   |\n53 |         res += max(0, max_height - height);\n   |                ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpi6bbxpp2.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &x) in row.iter().enumerate() {\n    \
    \        if x == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &x in max_row.iter() {\n        result += (x + capacity -\
    \ 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpwlk2eex6.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp9zg53e9k.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpi8_mqta8.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + max_fill\
    \ % capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmptyt9lqc9.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = capacity;\n         \
    \       count += 1;\n            }\n            max = max.max(*cell);\n      \
    \  }\n    }\n    if max == 0 {\n        return 0;\n    }\n    let mut i = 0;\n\
    \    while i < grid.len() {\n        let mut j = 0;\n        while j < grid[i].len()\
    \ {\n            if grid[i][j] == max {\n                grid[i][j] = 0;\n   \
    \             let mut k = i + 1;\n                while k < grid.len() {\n   \
    \                 if grid[k][j] > 0 {\n                        grid[k][j] -= 1;\n\
    \                    }\n                    k += 1;\n                }\n     \
    \           count += 1;\n            }\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `6`', /tmp/tmp3z8quoy1.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    while row < grid.len() {\n        while\
    \ col < grid[row].len() {\n            if grid[row][col] == 1 {\n            \
    \    let mut water = capacity;\n                while water > 0 && row < grid.len()\
    \ {\n                    if grid[row][col] == 1 {\n                        grid[row][col]\
    \ = 0;\n                        water -= 1;\n                    }\n         \
    \           row += 1;\n                }\n                count += 1;\n      \
    \          row -= 1;\n            }\n            col += 1;\n        }\n      \
    \  col = 0;\n        row += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpr0ndh71d.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            max_fill = max_fill.max(fill);\n        }\n    }\n\
    \    max_fill / capacity + (max_fill % capacity != 0) as isize\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp7713cx6j.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpourrt2n4.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                height += 1;\n            } else\
    \ {\n                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        if max_height > capacity {\n         \
    \   result += max_height - capacity;\n            max_height = capacity;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpy7p7m1kd.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpy7p7m1kd.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    (max_fill - 1) / capacity + 1\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpcsv4lvfh.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut max_fill_count = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in row.iter()\
    \ {\n            fill += well;\n            if fill > capacity {\n           \
    \     max_fill_count += 1;\n                fill = capacity;\n            }\n\
    \        }\n        max_fill = max(max_fill, fill);\n    }\n    max_fill_count\
    \ + max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp9hr3lje0.rs:40:20\n\
    \   |\n40 |         max_fill = max(max_fill, fill);\n   |                    ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            max_fill = max_fill.max(fill);\n        }\n    }\n\
    \    max_fill / capacity + max_fill % capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmphsmmhn8k.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmparwot0kx.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpkvjdtc_7.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpst2xopul.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut water = 0;\n    let mut max_height = 0;\n   \
    \ for row in grid {\n        for &cell in &row {\n            water += cell;\n\
    \            max_height = max(max_height, cell);\n        }\n    }\n    let mut\
    \ low = 0;\n    let mut high = max_height;\n    while low < high {\n        let\
    \ mid = low + (high - low) / 2;\n        let mut count = 0;\n        for row in\
    \ grid {\n            for &cell in &row {\n                count += max(0, cell\
    \ - mid);\n            }\n        }\n        if count > capacity {\n         \
    \   low = mid + 1;\n        } else {\n            high = mid;\n        }\n   \
    \ }\n    water - low * capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpb8dtvhtv.rs:34:26\n\
    \   |\n34 |             max_height = max(max_height, cell);\n   |            \
    \              ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `max` in this scope\n  --> /tmp/tmpb8dtvhtv.rs:44:26\n   |\n44 |           \
    \      count += max(0, cell - mid);\n   |                          ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            max_fill = max_fill.max(fill);\n        }\n    }\n\
    \    max_fill / capacity + max_fill % capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp2kbszv2z.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpzfjv5lk6.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut curr = 0;\n        for &cell in &row {\n            if cell == 1 {\n   \
    \             curr += 1;\n            } else {\n                max = max.max(curr);\n\
    \                curr = 0;\n            }\n        }\n        max = max.max(curr);\n\
    \    }\n    max / capacity + (max % capacity != 0) as isize\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmph5uw3uep.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = 0;\n            }\n        }\n        if fill > 0 {\n          \
    \  max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp8_659s59.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_fill = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        count += 1;\n            }\n        }\n    }\n    while count > 0 {\n\
    \        count = 0;\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell > 0 {\n                    *cell\
    \ -= 1;\n                    count += 1;\n                }\n            }\n \
    \       }\n        max_fill += 1;\n    }\n    max_fill\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpt160ppza.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut min_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &cell in &row {\n\
    \            height += cell;\n        }\n        let fill = min(height, capacity);\n\
    \        result += fill - min_height;\n        min_height = fill;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpktsxgjae.rs:36:20\n\
    \   |\n36 |         let fill = min(height, capacity);\n   |                  \
    \  ^^^\n...\n43 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n36 |\
    \         let fill = main(height, capacity);\n   |                    ~~~~\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_row = 0;\n    for\
    \ row in grid {\n        let mut row_max = 0;\n        for &col in &row {\n  \
    \          if col > row_max {\n                row_max = col;\n            }\n\
    \        }\n        if row_max > max_row {\n            max_row = row_max;\n \
    \       }\n    }\n    for _ in 0..max_row {\n        for row in &grid {\n    \
    \        for &col in row {\n                if col > 0 {\n                   \
    \ count += 1;\n                }\n            }\n        }\n        for row in\
    \ &mut grid {\n            for col in row {\n                if *col > 0 {\n \
    \                   *col -= 1;\n                }\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp9uidtkup.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmp9uidtkup.rs:43:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n43  |         for row in &grid {\n    |                    ^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror[E0596]: cannot borrow `grid` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmp9uidtkup.rs:50:20\n   |\n28\
    \ | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |     \
    \        ---- help: consider changing this to be mutable: `mut grid`\n...\n50\
    \ |         for row in &mut grid {\n   |                    ^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    Some errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    while count > 0 {\n        let mut\
    \ new_count = 0;\n        for row in grid.iter_mut() {\n            for cell in\
    \ row.iter_mut() {\n                if *cell > 0 {\n                    *cell\
    \ = 0;\n                    count -= 1;\n                } else if *cell == -1\
    \ {\n                    *cell = 1;\n                    new_count += 1;\n   \
    \             }\n            }\n        }\n        count += new_count;\n     \
    \   max += 1;\n        for row in grid.iter_mut() {\n            for cell in row.iter_mut()\
    \ {\n                if *cell == 1 {\n                    if capacity > 0 {\n\
    \                        *cell = -1;\n                        capacity -= 1;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmpenw_9b7v.rs:60:25\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n60 |                         capacity -= 1;\n\
    \   |                         ^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut total_fill = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n            if fill > capacity {\n               \
    \ max_fill += 1;\n                fill = well;\n            }\n        }\n   \
    \     total_fill += fill;\n    }\n    max_fill + (total_fill + capacity - 1) /\
    \ capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpgobco97m.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = std::cmp::max(max_fill, fill);\n    }\n\
    \    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpu5mwp8lt.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp0ekmqzu7.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpf9hikkj7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            for cell in row.iter_mut() {\n       \
    \         if *cell >= height {\n                    *cell -= height;\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpa_dch0df.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        if v == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &v in max_row.iter() {\n        result += (v + capacity -\
    \ 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpij27h9v6.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpy5nyg_js.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        let mut sum = 0;\n \
    \       for cell in row.iter_mut() {\n            sum += *cell;\n            *cell\
    \ = 0;\n        }\n        if sum > max {\n            max = sum;\n        }\n\
    \    }\n    for _ in 0..max {\n        for row in grid.iter_mut() {\n        \
    \    for cell in row.iter_mut() {\n                if *cell < capacity {\n   \
    \                 *cell += 1;\n                    count += 1;\n             \
    \   }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmpkczcqzf0.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        if v == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &v in max_row.iter() {\n        result += v / capacity;\n\
    \        if v % capacity != 0 {\n            result += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpl9gj71p5.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell == 1 {\n                *cell = capacity;\n        \
    \        max_height = capacity;\n            }\n        }\n    }\n    for row\
    \ in grid.iter_mut() {\n        for cell in row.iter_mut() {\n            if *cell\
    \ > 0 {\n                *cell -= 1;\n                count += 1;\n          \
    \  }\n        }\n    }\n    count + max_height\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpkmk2vwjn.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                height += 1;\n            } else\
    \ {\n                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        max_height = max_height.saturating_sub(capacity);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpnev3fied.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpnev3fied.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpnev3fied.rs:43:33\n   |\n\
    43 |         max_height = max_height.saturating_sub(capacity);\n   |         \
    \                        ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n30 |     let mut max_height: i32 = 0;\n   |\
    \         ~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut row_max\
    \ = 0;\n        for col in row.iter_mut() {\n            if *col == 1 {\n    \
    \            row_max += 1;\n            }\n        }\n        max_height = max(max_height,\
    \ row_max);\n    }\n    for _ in 0..max_height {\n        let mut row_max = 0;\n\
    \        for row in grid.iter_mut() {\n            let mut col_max = 0;\n    \
    \        for col in row.iter_mut() {\n                if *col == 1 {\n       \
    \             col_max += 1;\n                }\n            }\n            row_max\
    \ = max(row_max, col_max);\n        }\n        for row in grid.iter_mut() {\n\
    \            for col in row.iter_mut() {\n                if *col == 1 {\n   \
    \                 *col = 0;\n                }\n            }\n        }\n   \
    \     for row in grid.iter_mut() {\n            for col in row.iter_mut() {\n\
    \                if *col == 0 {\n                    *col = 1;\n             \
    \   }\n            }\n        }\n        count += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpio__v_xy.rs:39:22\n\
    \   |\n39 |         max_height = max(max_height, row_max);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max`\
    \ in this scope\n  --> /tmp/tmpio__v_xy.rs:50:23\n   |\n50 |             row_max\
    \ = max(row_max, col_max);\n   |                       ^^^ not found in this scope\n\
    \   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpdfojw7lj.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmphxd2b318.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpdtf7afvz.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            if well == 1 {\n   \
    \             max_fill += 1;\n            }\n        }\n    }\n    let mut fill\
    \ = 0;\n    for row in grid {\n        for &well in &row {\n            if well\
    \ == 1 {\n                fill += 1;\n            }\n            if fill == max_fill\
    \ {\n                count += 1;\n                fill = 0;\n            }\n \
    \       }\n        if fill > 0 {\n            count += 1;\n            fill =\
    \ 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpiuvki7t6.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpiuvki7t6.rs:39:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n39  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_height = 0;\n   \
    \ for row in grid {\n        let mut height = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                height += 1;\n            } else\
    \ {\n                height = 0;\n            }\n            max_height = max(max_height,\
    \ height);\n        }\n        count += max_height;\n        max_height = max(0,\
    \ max_height - capacity);\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpbcs7o4a0.rs:39:26\n\
    \   |\n39 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `max` in this scope\n  --> /tmp/tmpbcs7o4a0.rs:42:22\n   |\n42 |         max_height\
    \ = max(0, max_height - capacity);\n   |                      ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpq9ld1nru.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpus9nny3k.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp6edoji6a.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + max_fill\
    \ % capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp8lv51lr0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut well_max = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &well) in row.iter().enumerate() {\n \
    \           if well == 1 {\n                well_max[i] += 1;\n            }\n\
    \        }\n    }\n    for &max in well_max.iter() {\n        result += (max +\
    \ capacity - 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp2c2b0rc8.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpwdrpqe64.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        if v == 1 {\n                max_row[i] += 1;\n            }\n      \
    \  }\n    }\n    for &v in max_row.iter() {\n        result += (v + capacity -\
    \ 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpvtfkl552.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                height += 1;\n            } else\
    \ {\n                height = 0;\n            }\n            max_height = max(max_height,\
    \ height);\n        }\n        result += max_height;\n        max_height = max(0,\
    \ max_height - capacity);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpol1mdjv7.rs:39:26\n\
    \   |\n39 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `max` in this scope\n  --> /tmp/tmpol1mdjv7.rs:42:22\n   |\n42 |         max_height\
    \ = max(0, max_height - capacity);\n   |                      ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + max_fill % capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpug8jma7k.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    (max_fill + capacity - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp9_8kvnm4.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut max_fill_count = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                fill += 1;\n            } else {\n\
    \                if fill > max_fill {\n                    max_fill = fill;\n\
    \                    max_fill_count = 1;\n                } else if fill == max_fill\
    \ {\n                    max_fill_count += 1;\n                }\n           \
    \     fill = 0;\n            }\n        }\n        if fill > max_fill {\n    \
    \        max_fill = fill;\n            max_fill_count = 1;\n        } else if\
    \ fill == max_fill {\n            max_fill_count += 1;\n        }\n    }\n   \
    \ max_fill_count * capacity + max_fill - capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpdm26fihu.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut max_fill = 0;\n    for i in 0..n {\n        let mut fill = 0;\n    \
    \    for j in 0..m {\n            if grid[i][j] == 1 {\n                fill +=\
    \ 1;\n            }\n        }\n        max_fill = max_fill.max(fill);\n    }\n\
    \    let mut count = 0;\n    for i in 0..n {\n        let mut fill = 0;\n    \
    \    for j in 0..m {\n            if grid[i][j] == 1 {\n                fill +=\
    \ 1;\n            }\n            if fill == max_fill {\n                count\
    \ += 1;\n                fill = 0;\n            }\n        }\n        if fill\
    \ > 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpll0yumkv.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_row = 0;\n    let mut max_col = 0;\n    for row in &grid {\n       \
    \ for col in row {\n            if *col > max_col {\n                max_col =\
    \ *col;\n            }\n        }\n        if row.iter().sum::<isize>() > max_row\
    \ {\n            max_row = row.iter().sum::<isize>();\n        }\n    }\n    for\
    \ i in 0..max_row {\n        for j in 0..max_col {\n            for row in &mut\
    \ grid {\n                if row[j] > 0 {\n                    row[j] -= 1;\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpphojk80s.rs:46:20\n\
    \   |\n46 |                 if row[j] > 0 {\n   |                    ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpphojk80s.rs:47:21\n   |\n47 |  \
    \                   row[j] -= 1;\n   |                     ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + (max_fill %\
    \ capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpanubzk8w.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    max_fill / capacity + max_fill %\
    \ capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmphoic1pp0.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity > 0 { 1 } else { 0 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpke6bw77e.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    while\
    \ !grid.iter().all(|row| row.iter().all(|&x| x == 0)) {\n        for row in grid.iter_mut()\
    \ {\n            for x in row.iter_mut() {\n                if *x > 0 {\n    \
    \                *x -= capacity;\n                    if *x < 0 {\n          \
    \              *x = 0;\n                    }\n                }\n           \
    \ }\n        }\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmppshcwd5h.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    let mut min = count;\n    for i in 1..=max {\n        let mut c = 0;\n\
    \        for row in grid.iter() {\n            for cell in row.iter() {\n    \
    \            if *cell > 0 {\n                    c += 1;\n                }\n\
    \                if *cell > i {\n                    c += 1;\n               \
    \ }\n            }\n        }\n        min = min.min(c);\n    }\n    min\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp581qjafs.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpsniv6yay.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp1v8cskdt.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ n = grid.len();\n    let m = grid[0].len();\n    for i in 0..n {\n        for\
    \ j in 0..m {\n            if grid[i][j] == 1 {\n                grid[i][j] =\
    \ 0;\n                count += 1;\n                let mut stack = vec![(i, j)];\n\
    \                while let Some((i, j)) = stack.pop() {\n                    if\
    \ i > 0 && grid[i - 1][j] == 1 {\n                        grid[i - 1][j] = 0;\n\
    \                        stack.push((i - 1, j));\n                    }\n    \
    \                if i < n - 1 && grid[i + 1][j] == 1 {\n                     \
    \   grid[i + 1][j] = 0;\n                        stack.push((i + 1, j));\n   \
    \                 }\n                    if j > 0 && grid[i][j - 1] == 1 {\n \
    \                       grid[i][j - 1] = 0;\n                        stack.push((i,\
    \ j - 1));\n                    }\n                    if j < m - 1 && grid[i][j\
    \ + 1] == 1 {\n                        grid[i][j + 1] = 0;\n                 \
    \       stack.push((i, j + 1));\n                    }\n                }\n  \
    \          }\n        }\n    }\n    count * capacity\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp77tkk7hg.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for &val in row.iter() {\n            sum += val;\n  \
    \          if sum > capacity {\n                max += 1;\n                sum\
    \ = val;\n            }\n        }\n        max += sum;\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpzsqpjshe.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += fill - capacity;\n\
    \                fill = capacity;\n            }\n        }\n        fill = 0;\n\
    \    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpab_nwka7.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpzicn1o3y.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    let mut max_height_index = 0;\n    for (i, row) in\
    \ grid.iter().enumerate() {\n        let height = row.iter().sum();\n        if\
    \ height > max_height {\n            max_height = height;\n            max_height_index\
    \ = i;\n        }\n    }\n    let mut max_height = max_height;\n    while max_height\
    \ > 0 {\n        let mut i = max_height_index;\n        while i < grid.len() &&\
    \ grid[i][0] > 0 {\n            let mut j = 0;\n            while j < grid[i].len()\
    \ && grid[i][j] > 0 {\n                grid[i][j] -= 1;\n                j +=\
    \ 1;\n            }\n            i += 1;\n        }\n        count += 1;\n   \
    \     max_height -= capacity;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpx8u68js_.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                max_fill += 1;\n          \
    \      fill = well;\n            }\n        }\n        max_fill += fill;\n   \
    \ }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpga5eqzkr.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    if max_fill == 0 {\n        return 0;\n\
    \    }\n    let mut count = 0;\n    for row in grid {\n        let mut fill =\
    \ 0;\n        for &well in &row {\n            if well == 1 {\n              \
    \  fill += 1;\n            } else {\n                fill = 0;\n            }\n\
    \            if fill == max_fill {\n                count += 1;\n            \
    \    fill = 0;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp9fuechwo.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmp9fuechwo.rs:47:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max_fill = 0;\n\
    30  |     for row in grid {\n    |                ---- `grid` moved due to this\
    \ implicit call to `.into_iter()`\n...\n47  |     for row in grid {\n    |   \
    \             ^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n30  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    for\
    \ row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n           \
    \ if *cell > 0 {\n                *cell -= capacity;\n                count +=\
    \ 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp3wg4hcv6.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    while row < grid.len() {\n        let mut col = 0;\n     \
    \   while col < grid[row].len() {\n            if grid[row][col] == 1 {\n    \
    \            let mut fill = capacity;\n                while fill > 0 {\n    \
    \                if row == 0 {\n                        grid[row][col] = 0;\n\
    \                        fill -= 1;\n                    } else if grid[row -\
    \ 1][col] == 1 {\n                        grid[row - 1][col] = 0;\n          \
    \              fill -= 1;\n                    } else {\n                    \
    \    break;\n                    }\n                }\n                result\
    \ += 1;\n            }\n            col += 1;\n        }\n        row += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp40prufh7.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut max_fill_count = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &cell in &row {\n\
    \            fill += cell;\n            if fill > capacity {\n               \
    \ max_fill = capacity;\n                max_fill_count += 1;\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n            max_fill_count += 1;\n        }\n    }\n  \
    \  max_fill_count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpjwx7q7c0.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut max_fill_row = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            if well == 1 {\n                fill += 1;\n            }\n     \
    \   }\n        if fill > max_fill {\n            max_fill = fill;\n          \
    \  max_fill_row = 1;\n        } else if fill == max_fill {\n            max_fill_row\
    \ += 1;\n        }\n    }\n    let mut fill = 0;\n    for row in grid {\n    \
    \    for &well in &row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            }\n        }\n        if fill == max_fill {\n            max_fill_row\
    \ -= 1;\n        }\n        if max_fill_row == 0 {\n            break;\n     \
    \   }\n    }\n    if max_fill == 0 {\n        return 0;\n    }\n    let mut fill\
    \ = 0;\n    let mut count = 0;\n    for row in grid {\n        for &well in &row\
    \ {\n            if well == 1 {\n                fill += 1;\n            }\n \
    \       }\n        if fill == max_fill {\n            count += 1;\n        }\n\
    \        if fill > max_fill {\n            count += 1;\n            fill = 0;\n\
    \        }\n    }\n    count * capacity - max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpc5jfscx6.rs:46:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n46  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror[E0382]: use of moved value: `grid`\n  -->\
    \ /tmp/tmpc5jfscx6.rs:64:16\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n   |             ---- move occurs because `grid` has type\
    \ `Vec<Vec<isize>>`, which does not implement the `Copy` trait\n...\n46 |    \
    \ for row in grid {\n   |                ---- `grid` moved due to this implicit\
    \ call to `.into_iter()`\n...\n64 |     for row in grid {\n   |              \
    \  ^^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n   |\n\
    46 |     for row in &grid {\n   |                +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut max_fill_row = 0;\n\
    \    for row in grid {\n        let mut fill = 0;\n        for &well in &row {\n\
    \            fill += well;\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n            max_fill_row = 1;\n        } else if fill ==\
    \ max_fill {\n            max_fill_row += 1;\n        }\n    }\n    max_fill *\
    \ max_fill_row\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpva_62tci.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut result = 0;\n    let\
    \ mut row = 0;\n    let mut col = 0;\n    while row < grid.len() {\n        if\
    \ grid[row][col] == 1 {\n            grid[row][col] = 0;\n            result +=\
    \ 1;\n        }\n        if col == grid[row].len() - 1 {\n            row += 1;\n\
    \            col = 0;\n        } else {\n            col += 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpobrujsxa.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill = 0;\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += fill - capacity;\n\
    \                fill = capacity;\n            }\n        }\n        fill = 0;\n\
    \    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpmpnhga32.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        max = 0;\n        for\
    \ cell in row.iter_mut() {\n            if *cell == 1 {\n                *cell\
    \ = 0;\n                count += 1;\n            }\n            max = max.max(*cell);\n\
    \        }\n        count += max;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpahffmjz3.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmphb3j_8jk.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmppiuvfcmz.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = capacity;\n         \
    \       count += 1;\n            }\n            max = max.max(*cell);\n      \
    \  }\n    }\n    if max == 0 {\n        return 0;\n    }\n    let mut total =\
    \ 0;\n    while total < count {\n        total = 0;\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell > 0 {\n\
    \                    *cell -= 1;\n                    total += 1;\n          \
    \      }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpq3r18cy1.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max_height = 0;\n    for row in grid.iter_mut() {\n        let mut height\
    \ = 0;\n        for cell in row.iter_mut() {\n            if *cell == 1 {\n  \
    \              height += 1;\n            } else {\n                height = 0;\n\
    \            }\n            *cell = height;\n            max_height = max(max_height,\
    \ height);\n        }\n    }\n    for height in 1..=max_height {\n        for\
    \ row in grid.iter_mut() {\n            let mut filled = 0;\n            for cell\
    \ in row.iter_mut() {\n                if *cell >= height {\n                \
    \    filled += 1;\n                } else {\n                    filled = 0;\n\
    \                }\n                if filled == capacity {\n                \
    \    count += 1;\n                    filled = 0;\n                }\n       \
    \     }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpwisyf42y.rs:41:26\n\
    \   |\n41 |             max_height = max(max_height, height);\n   |          \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + (max_fill % capacity\
    \ != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpnxumqf82.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    max_fill / capacity + max_fill % capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpk7hidq7e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut i = 0;\n    while i < grid.len() {\n        let mut j = 0;\n        while\
    \ j < grid[i].len() {\n            if grid[i][j] == 1 {\n                count\
    \ += 1;\n                let mut k = 0;\n                while k < grid.len()\
    \ {\n                    let mut l = 0;\n                    while l < grid[k].len()\
    \ {\n                        if grid[k][l] == 1 {\n                          \
    \  grid[k][l] = 0;\n                            if capacity == 1 {\n         \
    \                       break;\n                            }\n              \
    \              capacity -= 1;\n                        }\n                   \
    \     l += 1;\n                    }\n                    k += 1;\n          \
    \      }\n            }\n            j += 1;\n        }\n        i += 1;\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmpynqxxbsb.rs:46:29\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n46 |                             capacity -= 1;\n\
    \   |                             ^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                if fill > max_fill\
    \ {\n                    max_fill = fill;\n                }\n               \
    \ fill = 0;\n            }\n        }\n        if fill > max_fill {\n        \
    \    max_fill = fill;\n        }\n    }\n    (max_fill + capacity - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpbstcje6j.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut wells = grid;\n    let\
    \ mut max_height = 0;\n    for well in wells.iter() {\n        let height = well.iter().sum();\n\
    \        if height > max_height {\n            max_height = height;\n        }\n\
    \    }\n    for height in 0..max_height {\n        for well in wells.iter_mut()\
    \ {\n            for unit in well.iter_mut() {\n                if *unit > 0 {\n\
    \                    *unit -= 1;\n                    result += 1;\n         \
    \       }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpajfjzs4q.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_row = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &v) in row.iter().enumerate() {\n    \
    \        max_row[i] = max_row[i].max(v);\n        }\n    }\n    for row in grid\
    \ {\n        for (i, &v) in row.iter().enumerate() {\n            if v > 0 {\n\
    \                let fill = max_row[i].min(capacity);\n                max_row[i]\
    \ -= fill;\n                result += fill;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpzp3x2ubd.rs:36:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n36  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        let mut height = 0;\n        for &cell in &row {\n\
    \            if cell == 1 {\n                height += 1;\n            } else\
    \ {\n                max_height = max(max_height, height);\n                height\
    \ = 0;\n            }\n        }\n        max_height = max(max_height, height);\n\
    \        result += max_height;\n        max_height = max_height.saturating_sub(capacity);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2upifvqs.rs:37:30\n\
    \   |\n37 |                 max_height = max(max_height, height);\n   |      \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmp2upifvqs.rs:41:22\n   |\n41 |  \
    \       max_height = max(max_height, height);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmp2upifvqs.rs:43:33\n   |\n\
    43 |         max_height = max_height.saturating_sub(capacity);\n   |         \
    \                        ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n30 |     let mut max_height: i32 = 0;\n   |\
    \         ~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + max_fill\
    \ % capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp48k_nrl5.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + if max_fill\
    \ % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpqgy8mnr0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp_wmuye3k.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill > capacity {\n                fill = capacity;\n        \
    \    }\n        }\n        max_fill = max_fill.max(fill);\n    }\n    max_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpwcij4yaa.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut fill = 0;\n    for\
    \ row in grid {\n        for &well in &row {\n            fill += well;\n    \
    \        if fill > capacity {\n                max_fill += 1;\n              \
    \  fill = well;\n            }\n        }\n        max_fill += 1;\n        fill\
    \ = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp5d766o_0.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n     \
    \   for cell in row.iter() {\n            max = max.max(*cell);\n        }\n \
    \   }\n    if max == 0 {\n        return 0;\n    }\n    let mut sum = 0;\n   \
    \ for row in grid.iter() {\n        for cell in row.iter() {\n            sum\
    \ += cell;\n        }\n    }\n    let mut result = 0;\n    let mut i = 0;\n  \
    \  while sum > 0 {\n        let mut j = 0;\n        while j < grid.len() {\n \
    \           if grid[j][i] > 0 {\n                sum -= 1;\n                grid[j][i]\
    \ -= 1;\n            }\n            j += 1;\n        }\n        result += 1;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp6zji17ph.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                fill = 0;\n\
    \            }\n            if fill > max_fill {\n                max_fill = fill;\n\
    \            }\n        }\n    }\n    (max_fill + capacity - 1) / capacity\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpc8szmm70.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + max_fill\
    \ % capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpn1vai032.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            if well == 1 {\n\
    \                fill += 1;\n            } else {\n                max_fill =\
    \ max_fill.max(fill);\n                fill = 0;\n            }\n        }\n \
    \       max_fill = max_fill.max(fill);\n    }\n    max_fill / capacity + (max_fill\
    \ % capacity != 0) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp1sflnrn8.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut max = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut()\
    \ {\n            if *cell > 0 {\n                *cell = 1;\n                count\
    \ += 1;\n            }\n        }\n    }\n    if count == 0 {\n        return\
    \ 0;\n    }\n    for row in grid.iter() {\n        for cell in row.iter() {\n\
    \            if *cell > 0 {\n                max = max.max(*cell);\n         \
    \   }\n        }\n    }\n    let mut result = 0;\n    while max > 0 {\n      \
    \  let mut count = 0;\n        for row in grid.iter_mut() {\n            for cell\
    \ in row.iter_mut() {\n                if *cell == max {\n                   \
    \ *cell = 0;\n                    count += 1;\n                }\n           \
    \ }\n        }\n        result += count / capacity;\n        if count % capacity\
    \ > 0 {\n            result += 1;\n        }\n        max -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp4lwyk93o.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  let mut fill = 0;\n        for &well in &row {\n            fill += well;\n\
    \            if fill == capacity {\n                max_fill += 1;\n         \
    \       fill = 0;\n            }\n        }\n        if fill > 0 {\n         \
    \   max_fill += 1;\n        }\n    }\n    max_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
