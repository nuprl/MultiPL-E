name: HumanEval_68_pluck
language: rust
results:
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if *val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < min_even\
    \ {\n            min_even = n;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5i88u0l8.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min\
    \ {\n            min = *n;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n       \
    \ vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min\
    \ {\n            min = *v;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n    \
    \    vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min_even\
    \ {\n            min_even = *n;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = usize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i;\n        }\n \
    \   }\n    if min_even == isize::max_value() {\n        vec![]\n    } else {\n\
    \        vec![min_even, min_even_index as isize]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    evens.first().map(|&(i, x)| vec![x,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi_6eunu8.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_6eunu8.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        let (i, &x) = evens[0];\n        vec![x, i as isize]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    evens.first().map(|(i, &x)| vec![x,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min\
    \ {\n            min = v;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even_idx == std::isize::MAX {\n    \
    \    vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    evens.first().map(|&(i, x)| vec![x,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbpq5v17d.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbpq5v17d.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == isize::max_value() {\n     \
    \   vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_idx = -1;\n    for (idx,\
    \ val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val < &min {\n\
    \            min = *val;\n            min_idx = idx as isize;\n        }\n   \
    \ }\n    if min_idx == -1 {\n        return vec![];\n    }\n    vec![min, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &n)| n % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, n)| n);\n    evens.first().map(|&(i, n)| vec![n,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgll7gla9.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, n)| vec![n, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgll7gla9.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, n)| vec![n, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min\
    \ {\n            min = *n;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut index = 0;\n    for (i, &v)\
    \ in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min {\n          \
    \  min = v;\n            index = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    evens.first().map(|&(i, x)| vec![x,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpchjic8c4.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpchjic8c4.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min\
    \ {\n            min = *n;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n       \
    \ vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    match evens.first() {\n        Some(&(i,\
    \ x)) => vec![x, i as isize],\n        None => vec![],\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdlnjklk4.rs:30:31\n   |\n\
    30 |         Some(&(i, x)) => vec![x, i as isize],\n   |                     \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n30 |         Some(&(i, x)) => vec![*x, i as isize],\n   |\
    \                               +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = std::isize::MAX;\n    let mut smallest_even_index\
    \ = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate() {\n        if\
    \ x % 2 == 0 && x < smallest_even {\n            smallest_even = x;\n        \
    \    smallest_even_index = i as isize;\n        }\n    }\n    if smallest_even\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![smallest_even,\
    \ smallest_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|(_, &x)| x);\n    if even_nums.is_empty() {\n    \
    \    return vec![];\n    }\n    let (i, &x) = even_nums[0];\n    vec![x, i as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n     \
    \   vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n\
    \    vec![min, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|(_, &x)| x);\n    if even_nums.is_empty() {\n    \
    \    return vec![];\n    }\n    let (idx, &val) = even_nums[0];\n    vec![val,\
    \ idx as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpskqvcgqx.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = isize::max_value();\n    let mut smallest_even_index\
    \ = isize::max_value();\n    for (i, &v) in arr.iter().enumerate() {\n       \
    \ if v % 2 == 0 && v < smallest_even {\n            smallest_even = v;\n     \
    \       smallest_even_index = i as isize;\n        }\n    }\n    if smallest_even\
    \ == isize::max_value() {\n        return vec![];\n    }\n    vec![smallest_even,\
    \ smallest_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n < min_even\
    \ {\n            min_even = *n;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min_even\
    \ {\n            min_even = *n;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == isize::max_value() {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    evens.first().map(|(i, &x)| vec![x,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    evens.first().map(|(i, &x)| vec![x,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min\
    \ {\n            min = *x;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut min_even = isize::max_value();\n  \
    \  let mut min_even_index = isize::max_value();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 && *v < min_even {\n            min_even = *v;\n \
    \           min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ != isize::max_value() {\n        result.push(min_even);\n        result.push(min_even_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, &n) in arr.iter().enumerate() {\n  \
    \      if n % 2 == 0 {\n            evens.push((n, i));\n        }\n    }\n  \
    \  evens.sort_by_key(|&(n, _)| n);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].0, evens[0].1 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        let (i, &x) = evens[0];\n        vec![x, i as isize]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = None;\n    let mut min_even_idx = None;\n    for (idx,\
    \ &val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n            if\
    \ min_even.is_none() || val < min_even.unwrap() {\n                min_even =\
    \ Some(val);\n                min_even_idx = Some(idx);\n            }\n     \
    \   }\n    }\n    match (min_even, min_even_idx) {\n        (Some(min_even), Some(min_even_idx))\
    \ => vec![min_even, min_even_idx as isize],\n        _ => vec![],\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut index = 0;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < even {\n         \
    \   even = x;\n            index = i;\n        }\n    }\n    if even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![even, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n     \
    \   vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|(_, &x)| x);\n    if even_nums.is_empty() {\n    \
    \    return vec![];\n    }\n    let (i, &x) = even_nums[0];\n    vec![x, i as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    evens.first().map(|&(i, x)| vec![x,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxp1xw0x.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptxp1xw0x.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n\
    \    vec![min, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n   \
    \ } else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if *val % 2 == 0 && *val\
    \ < min {\n            min = *val;\n            min_idx = idx as isize;\n    \
    \    }\n    }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n\
    \    vec![min, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    evens.first().map(|&(i, x)| vec![x,\
    \ i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcyq299wt.rs:29:41\n   |\n\
    29 |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                         ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcyq299wt.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == isize::max_value() {\n        vec![]\n    } else\
    \ {\n        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|&(_,\
    \ x)| x);\n    vec![evens[0].1, evens[0].0 as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwsbfg_uf.rs:32:10\n   |\n\
    32 |     vec![evens[0].1, evens[0].0 as isize]\n   |          ^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |     vec![*evens[0].1, evens[0].0 as isize]\n   |          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_even\
    \ {\n            min_even = v;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even_index == std::isize::MAX {\n        vec![]\n \
    \   } else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min\
    \ {\n            min = *x;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_idx = 0;\n    for (i,\
    \ &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n      \
    \      min = x;\n            min_idx = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n     \
    \   vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n    for\
    \ (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n  \
    \          min = x;\n            idx = i as isize;\n        }\n    }\n    if min\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min, idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n    for\
    \ (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n  \
    \          min = x;\n            idx = i as isize;\n        }\n    }\n    if min\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min, idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_even\
    \ {\n            min_even = v;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        return\
    \ vec![];\n    }\n    let (i, &x) = evens[0];\n    vec![x, i as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even_idx == isize::max_value() {\n    \
    \    vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_3onwb2.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_idx = idx as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = std::isize::MAX;\n    let mut smallest_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < smallest\
    \ {\n            smallest = x;\n            smallest_index = i as isize;\n   \
    \     }\n    }\n    if smallest == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![smallest, smallest_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut idx = 0;\n    for (i, &x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n            min\
    \ = x;\n            idx = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, idx as isize]\n    }\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = 0;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n          \
    \  min = x;\n            min_idx = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut index = 0;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n          \
    \  min = x;\n            index = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min\
    \ {\n            min = v;\n            min_idx = idx as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min_even\
    \ {\n            min_even = *x;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, &n) in arr.iter().enumerate() {\n  \
    \      if n % 2 == 0 {\n            evens.push((n, i));\n        }\n    }\n  \
    \  if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|&(n,\
    \ _)| n);\n    let (n, i) = evens[0];\n    vec![n, i as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &n)| n % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &n)| n);\n    evens.first().map(|(i, &n)| vec![n,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = None;\n    let mut index = None;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            if let Some(y) = min {\n           \
    \     if x < y {\n                    min = Some(x);\n                    index\
    \ = Some(i);\n                }\n            } else {\n                min = Some(x);\n\
    \                index = Some(i);\n            }\n        }\n    }\n    match\
    \ (min, index) {\n        (Some(x), Some(i)) => vec![x, i as isize],\n       \
    \ _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = None;\n    let mut min_even_idx = None;\n    for (idx,\
    \ &val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n            if\
    \ min_even.is_none() || val < min_even.unwrap() {\n                min_even =\
    \ Some(val);\n                min_even_idx = Some(idx);\n            }\n     \
    \   }\n    }\n    match (min_even, min_even_idx) {\n        (Some(val), Some(idx))\
    \ => vec![val, idx as isize],\n        _ => vec![],\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkawj1d7e.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &x)| x);\n    if evens.is_empty() {\n        return\
    \ vec![];\n    }\n    let (idx, &val) = evens[0];\n    vec![val, idx as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min_even\
    \ {\n            min_even = *n;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|(_,\
    \ &x)| x);\n    vec![evens[0].1, evens[0].0 as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4wp59hdq.rs:32:10\n   |\n\
    32 |     vec![evens[0].1, evens[0].0 as isize]\n   |          ^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |     vec![*evens[0].1, evens[0].0 as isize]\n   |          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even_idx == std::isize::MAX {\n       \
    \ vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &n)| n % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, n)| n);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5gkzama.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even_idx == isize::max_value() {\n    \
    \    vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even_index == std::isize::MAX {\n        vec![]\n \
    \   } else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == isize::max_value() {\n     \
    \   vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|&(_, x)| x);\n    even_nums.first().map(|(i, x)| vec![*x,\
    \ *i as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkakkb7fk.rs:29:45\n   |\n\
    29 |     even_nums.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or_else(||\
    \ vec![])\n   |                                             ^^^^^^^^^^^ expected\
    \ `&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkakkb7fk.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     even_nums.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or_else(||\
    \ vec![])\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = std::isize::MAX;\n    let mut index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < smallest\
    \ {\n            smallest = x;\n            index = i as isize;\n        }\n \
    \   }\n    if smallest == std::isize::MAX {\n        vec![]\n    } else {\n  \
    \      vec![smallest, index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, v)| v.is_even()).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, v)| v);\n    evens.first().map(|(i, v)| vec![*v, *i\
    \ as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmp7ipgiekj.rs:27:62\n   |\n27 |     let mut evens\
    \ = arr.iter().enumerate().filter(|(_, v)| v.is_even()).collect::<Vec<_>>();\n\
    \   |                                                              ^^^^^^^ method\
    \ not found in `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ipgiekj.rs:29:41\n\
    \   |\n29 |     evens.first().map(|(i, v)| vec![*v, *i as isize]).unwrap_or_default()\n\
    \   |                                         ^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ipgiekj.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|(i, v)| vec![*v, *i as isize]).unwrap_or_default()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = isize::max_value();\n    let mut smallest_even_index\
    \ = isize::max_value();\n    for (i, v) in arr.iter().enumerate() {\n        if\
    \ *v % 2 == 0 && *v < smallest_even {\n            smallest_even = *v;\n     \
    \       smallest_even_index = i as isize;\n        }\n    }\n    if smallest_even\
    \ == isize::max_value() {\n        vec![]\n    } else {\n        vec![smallest_even,\
    \ smallest_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|(_,\
    \ &x)| x);\n    let (i, &x) = evens[0];\n    vec![x, i as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = usize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i;\n        }\n \
    \   }\n    if min_even_index == usize::max_value() {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index as isize]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n    for (i,\
    \ &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even {\n \
    \           min_even = x;\n            min_even_index = i as isize;\n        }\n\
    \    }\n    if min_even == std::isize::MAX {\n        return vec![];\n    }\n\
    \    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|(_, &x)| x);\n    if even_nums.is_empty() {\n    \
    \    return vec![];\n    }\n    let (i, &x) = even_nums[0];\n    vec![x, i as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = 0;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n          \
    \  min = x;\n            min_idx = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min, min_idx as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < min_even\
    \ {\n            min_even = n;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_even\
    \ {\n            min_even = v;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even_index == std::isize::MAX {\n        vec![]\n \
    \   } else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n    for\
    \ (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n  \
    \          min = x;\n            idx = i as isize;\n        }\n    }\n    if min\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min, idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|&(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrfc_oat.rs:32:14\n   |\n\
    32 |         vec![evens[0].1, evens[0].0 as isize]\n   |              ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         vec![*evens[0].1, evens[0].0 as isize]\n   |             \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut index = 0;\n    for (i, &x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n            min\
    \ = x;\n            index = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut index = 0;\n    for (i, &x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n            min\
    \ = x;\n            index = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = std::isize::MAX;\n    let mut smallest_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < smallest\
    \ {\n            smallest = x;\n            smallest_index = i as isize;\n   \
    \     }\n    }\n    if smallest == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![smallest, smallest_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0\
    \ && value < &min {\n            min = *value;\n            min_index = index\
    \ as isize;\n        }\n    }\n    if min == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min, min_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_index = i as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if *val % 2 == 0 && *val\
    \ < min_even {\n            min_even = *val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min {\n            min = *val;\n            min_idx = idx as isize;\n   \
    \     }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n    for (i,\
    \ v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even {\n \
    \           min_even = *v;\n            min_even_index = i as isize;\n       \
    \ }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n   \
    \ }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even_idx == isize::max_value() {\n \
    \       vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even_idx == std::isize::MAX {\n    \
    \    return vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut index = std::isize::MAX;\n  \
    \  for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min {\n\
    \            min = x;\n            index = i as isize;\n        }\n    }\n   \
    \ if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_idx = idx as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_idx = idx as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut index = std::isize::MAX;\n  \
    \  for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min {\n\
    \            min = *n;\n            index = i as isize;\n        }\n    }\n  \
    \  if min == std::isize::MAX {\n        return vec![];\n    }\n    vec![min, index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == isize::max_value() {\n        vec![]\n    }\
    \ else {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min\
    \ {\n            min = x;\n            min_idx = idx as isize;\n        }\n  \
    \  }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min,\
    \ min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_even\
    \ {\n            min_even = v;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min {\n            min = val;\n            min_idx = idx as isize;\n     \
    \   }\n    }\n    if min == std::isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even_idx == std::isize::MAX {\n    \
    \    vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even_idx == isize::max_value() {\n    \
    \    return vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_index = usize::max_value();\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i;\n        }\n \
    \   }\n    if min_even_index == usize::max_value() {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_index as isize]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == isize::max_value() {\n     \
    \   vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
