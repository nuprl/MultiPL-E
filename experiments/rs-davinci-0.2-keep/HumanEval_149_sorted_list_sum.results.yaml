name: HumanEval_149_sorted_list_sum
language: rust
results:
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpz1gvt8p9.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpymsiuh0w.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmppnrjrr1w.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmptsoc00cp.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5hm65vn_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpo3l66i5t.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmx8udqls.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpoj166ivg.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    let mut res: Vec<String> = Vec::new();\n   \
    \ let mut i = 0;\n    while i < lst.len() {\n        let mut j = i + 1;\n    \
    \    while j < lst.len() && lst[i].len() == lst[j].len() {\n            j += 1;\n\
    \        }\n        if (lst[i].len() % 2) == 0 {\n            res.push(lst[i].clone());\n\
    \        }\n        i = j;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpudhaox_d.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpe_de523g.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpl1mks_gb.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        a.len().cmp(&b.len())\n            .then(a.cmp(&b))\n    });\n  \
    \  lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpuk9qjdnc.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpdklvl8h3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpo1nyfeuk.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpeqd6q97z.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmptt5q3733.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp64iox1c3.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp3trb6ks3.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprw9bljc4.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpmy_5q6t_.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpheehhhe9.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpv9eg8qbs.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpt4034z4e.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpc5fiwk8k.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpiu6a0n5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprngnlb23.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpp15wezz7.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp1mtqjft6.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpl7i78c1u.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5bco6e55.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp4zwvmc2n.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpxdmjk9_x.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp4luolhm2.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpcxcgjxyt.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpjsxxb938.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpad8emer9.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp1mslmzty.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpezsk6yhr.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp69yl0j8f.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpii0is4xo.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp57e30wcr.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp98fwt7cz.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp4dkgxc7a.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmphebyh75b.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpkhh5kxj2.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut lst_len = lst.len();\n    let mut lst_len_copy = lst_len;\n    let\
    \ mut lst_copy = lst.clone();\n    let mut lst_copy_2 = lst.clone();\n    let\
    \ mut lst_copy_3 = lst.clone();\n    let mut lst_copy_4 = lst.clone();\n    let\
    \ mut lst_copy_5 = lst.clone();\n    let mut lst_copy_6 = lst.clone();\n    let\
    \ mut lst_copy_7 = lst.clone();\n    let mut lst_copy_8 = lst.clone();\n    let\
    \ mut lst_copy_9 = lst.clone();\n    let mut lst_copy_10 = lst.clone();\n    let\
    \ mut lst_copy_11 = lst.clone();\n    let mut lst_copy_12 = lst.clone();\n   \
    \ let mut lst_copy_13 = lst.clone();\n    let mut lst_copy_14 = lst.clone();\n\
    \    let mut lst_copy_15 = lst.clone();\n    let mut lst_copy_16 = lst.clone();\n\
    \    let mut lst_copy_17 = lst.clone();\n    let mut lst_copy_18 = lst.clone();\n\
    \    let mut lst_copy_19 = lst.clone();\n    let mut lst_copy_20 = lst.clone();\n\
    \    let mut lst_copy_21 = lst.clone();\n    let mut lst_copy_22 = lst.clone();\n\
    \    let mut lst_copy_23 = lst.clone();\n    let mut lst_copy_24 = lst.clone();\n\
    \    let mut lst_copy_25 = lst.clone();\n    let mut lst_copy_26 = lst.clone();\n\
    \    let mut lst_copy_27 = lst.clone();\n    let mut lst_copy_28 = lst.clone();\n\
    \    let mut lst_copy_29 = lst.clone();\n    let mut l\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7srnk118.rs:47:14\n   |\n\
    47 |     let mut l\n   |              ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7srnk118.rs:14:41\n \
    \  |\n14 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpg47m48x4.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpf_ufy741.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpx1cgkqlt.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmptc080jqz.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp7bxn1aze.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpyc_suo0l.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    let\
    \ mut result: Vec<String> = Vec::new();\n    let mut i = 0;\n    while i < lst.len()\
    \ {\n        let mut j = 0;\n        while j < lst.len() {\n            if lst[i].len()\
    \ == lst[j].len() {\n                result.push(lst[i].clone());\n          \
    \      lst.remove(i);\n                lst.remove(j);\n            }\n       \
    \     j += 1;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'removal index (is 1) should be < len (is 1)',\
    \ /tmp/tmppfy91wkp.rs:24:21\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp99xuh308.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmppw029tkm.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp_fsu32gz.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp2ao14y84.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmptz03f8oc.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpdgzrf305.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp1d2vtv3m.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpcedljk84.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmd54u24y.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmphk2shqmc.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpp9kbmynb.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpu3889gs6.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp87x3qbue.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmplj6_q0hl.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpl43lrswu.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps2shxdlf.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpdkx2unk6.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpnvpjve6k.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpigzfa4ud.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpl_jxrxhc.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpovw7qlau.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp3x7mt5xh.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmphjxwopee.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpgc5xbe08.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp6o_wcx9o.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpg2x1x6z8.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst_sorted = lst.clone();\n    lst_sorted.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst_sorted\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzhkmdyz0.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n\
    \    for i in lst {\n        if i.len() % 2 == 0 {\n            new_lst.push(i);\n\
    \        }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp_52ai_jr.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpoqk9ubi0.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp0r71z0wi.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmph_7i2au9.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let len_a = a.len();\n        let len_b = b.len();\n        if len_a\
    \ == len_b {\n            a.cmp(b)\n        } else {\n            len_a.cmp(&len_b)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9m8fwez6.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpc9hq1pul.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    let\
    \ mut result: Vec<String> = Vec::new();\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    for i in lst {\n        if i.len() % 2 == 0 {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"dcba\", \"abcd\"]`,\n right: `[\"abcd\", \"dcba\"]`', /tmp/tmpc0zsms49.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpl6143xyf.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpl9ein7ly.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpju_uw5ei.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpmqjdwuka.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    for i in\
    \ lst {\n        if i.len() % 2 == 0 {\n            result.push(i);\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpt72ekoze.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprx4egqxb.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpt3yvlw9o.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp549phut5.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp62qo8yjm.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        a.len().cmp(&b.len())\n            .then(a.cmp(&b))\n    });\n  \
    \  lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpgnyu8wxk.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp8nffclff.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7oqtuvly.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp39w_08ds.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp425w14ua.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpli0xejps.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpv87n3e13.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpus3lbmfh.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp42zq87ps.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpp735oe2f.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpa4ozfuty.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpvuu_hugl.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpm1pqef85.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpwv2u8m2h.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp081_suct.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp4eetk2fw.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp08hhotks.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpvomh8bra.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpj10vmzpb.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpaebkqteh.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpum9_79ko.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpr_vrob6r.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    for item\
    \ in lst {\n        if item.len() % 2 == 0 {\n            result.push(item);\n\
    \        }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpu6uj0lke.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp7r1_0gnu.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp60wnjbnm.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut lst_len: Vec<usize> = Vec::new();\n    for i in lst {\n        lst_len.push(i.len());\n\
    \    }\n    lst_len.sort();\n    let mut lst_len_set: HashSet<usize> = HashSet::new();\n\
    \    for i in lst_len {\n        lst_len_set.insert(i);\n    }\n    let mut lst_len_vec:\
    \ Vec<usize> = Vec::new();\n    for i in lst_len_set {\n        lst_len_vec.push(i);\n\
    \    }\n    lst_len_vec.sort();\n    for i in lst_len_vec {\n        for j in\
    \ lst {\n            if j.len() == i {\n                result.push(j);\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpo9702e3k.rs:21:26\n\
    \   |\n21 |     let mut lst_len_set: HashSet<usize> = HashSet::new();\n   |  \
    \                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpo9702e3k.rs:21:43\n\
    \   |\n21 |     let mut lst_len_set: HashSet<usize> = HashSet::new();\n   |  \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst_len = lst.len();\n    let mut\
    \ lst_sorted = lst.clone();\n    lst_sorted.sort();\n    let mut lst_sorted_len\
    \ = lst_sorted.len();\n    let mut lst_sorted_sum = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < lst_len {\n        while j < lst_sorted_len\
    \ {\n            if lst[i].len() == lst_sorted[j].len() {\n                lst_sorted_sum.push(lst_sorted[j].clone());\n\
    \                j += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        i += 1;\n    }\n    lst_sorted_sum\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpuyij80yw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpwsnaatk5.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps_xv4u4x.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpsu2sfon1.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps95v5gmo.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7itbf8lx.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpxde8_3xi.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut sorted_list: Vec<String> = lst.clone();\n    sorted_list.sort();\n\
    \    sorted_list.dedup();\n    for word in sorted_list {\n        if word.len()\
    \ % 2 == 0 {\n            result.push(word);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpwgiurlkz.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp8zavwygf.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpzetgwf1c.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9bgzsyos.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpckgeljan.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp_6en5q76.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5yc8xmj5.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9_8ewrgh.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpjssesed3.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmtti63ep.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        a.len().cmp(&b.len())\n            .then(a.cmp(&b))\n    });\n  \
    \  lst.dedup();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpysb5fvgo.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpxmen_53w.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpsmamu4py.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpx2dp3znr.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpd4veyxq6.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpdj9sqwh5.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpug966p41.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut new_lst: Vec<String> = Vec::new();\n\
    \    for i in lst {\n        if i.len() % 2 == 0 {\n            new_lst.push(i);\n\
    \        }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpvfyxvff4.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpzmsyz2vn.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut lst_copy = lst.clone();\n    lst_copy.sort();\n    let mut lst_len\
    \ = lst_copy.len();\n    let mut i = 0;\n    while i < lst_len {\n        let\
    \ mut j = i + 1;\n        while j < lst_len {\n            if lst_copy[i].len()\
    \ == lst_copy[j].len() {\n                lst_copy.remove(j);\n              \
    \  lst_len -= 1;\n            } else {\n                j += 1;\n            }\n\
    \        }\n        i += 1;\n    }\n    lst_copy.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    result = lst_copy;\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7rii5n22.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmy5j5txn.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpikadfzph.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpjlldtr2k.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpt152o_0y.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp3i38radv.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpjffauidd.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpqft9pg1c.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpd1cettzv.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmphw0ol_9l.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp2ag7de4t.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp1rg2da2x.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp8ri1hfcy.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpqyz99_qt.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzs0pnms5.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpvs2fne_q.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp121ufiih.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpcfcba4ds.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp0mvoymm7.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpersvsuq3.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp11y2oi9p.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpy84d1zhp.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp_rrprpjj.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpp69se3qk.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpy6_d0m12.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpodt5fjk3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpenkly7um.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzcv90vih.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5uusz5cg.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5ohiwpi8.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpnpqn5e_o.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzfmhny2h.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpestgqy3h.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp9ai41y_a.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp1zql9287.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp11pilwb4.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpu8w9eja7.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        if\
    \ a_len == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpld7l51cp.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpa03dna6f.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpknfhhac3.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpodaqp5vd.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp7dtrjo3a.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        a.len().cmp(&b.len())\n            .then(a.cmp(&b))\n    });\n  \
    \  lst.into_iter().filter(|s| s.len() % 2 == 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ a.len().cmp(&b.len()));\n    lst.dedup();\n    lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmphvj_gxs_.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpkl0nf88l.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else {\n\
    \            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpsr1y9las.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|s|\
    \ s.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmpavod1wzi.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst;\n    lst.sort_by(|a,\
    \ b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n        } else\
    \ {\n            a.len().cmp(&b.len())\n        }\n    });\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpc1cwkmz8.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpm8kmnqii.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst = lst;\n    lst.sort_by(|a, b|\
    \ {\n        let a_len = a.len();\n        let b_len = b.len();\n        if a_len\
    \ == b_len {\n            a.cmp(b)\n        } else {\n            a_len.cmp(&b_len)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpaallqisg.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().filter(|x|\
    \ x.len() % 2 == 0).collect();\n    lst.sort();\n    lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaaa\", \"bbbb\", \"cc\", \"dd\"]`,\n right: `[\"cc\", \"dd\", \"aaaa\"\
    , \"bbbb\"]`', /tmp/tmp0fm2h4l8.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert\
    \ list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    lst.sort_by(|a, b| {\n        if a.len() == b.len() {\n            a.cmp(b)\n\
    \        } else {\n            a.len().cmp(&b.len())\n        }\n    });\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp05g0wkzm.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
