name: HumanEval_6_parse_nested_parens
language: rust
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut max_depth_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_depth += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_depth -= 1;\n        } else if c == ' ' {\n            max_depth_vec.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    max_depth_vec.push(max_depth);\n\
    \    max_depth_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpyldy85rq.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut max_depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                max_depths.push(max_depth);\n     \
    \           max_depth = 0;\n                depth = 0;\n            }\n      \
    \      _ => {}\n        }\n    }\n    max_depths.push(max_depth);\n    max_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<char> = Vec::new();\n    let mut max_nesting: isize = 0;\n\
    \    let mut current_nesting: isize = 0;\n    let mut current_char: char;\n  \
    \  let mut paren_string = paren_string.chars();\n\n    while let Some(c) = paren_string.next()\
    \ {\n        current_char = c;\n        if current_char == '(' {\n           \
    \ paren_stack.push(current_char);\n            current_nesting += 1;\n       \
    \     if current_nesting > max_nesting {\n                max_nesting = current_nesting;\n\
    \            }\n        } else if current_char == ')' {\n            if paren_stack.is_empty()\
    \ {\n                panic!(\"Invalid input string. Unbalanced parentheses.\"\
    );\n            }\n            paren_stack.pop();\n            current_nesting\
    \ -= 1;\n        } else if current_char == ' ' {\n            if paren_stack.is_empty()\
    \ {\n                paren_vec.push(max_nesting);\n                max_nesting\
    \ = 0;\n                current_nesting = 0;\n            }\n        } else {\n\
    \            panic!(\"Invalid input string. Unrecognized character.\");\n    \
    \    }\n    }\n    if !paren_stack.is_empty() {\n        panic!(\"Invalid input\
    \ string. Unbalanced parentheses.\");\n    }\n    paren_vec.push(max_nesting);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                curr_nesting += 1;\n    \
    \            if curr_nesting > max_nesting {\n                    max_nesting\
    \ = curr_nesting;\n                }\n            }\n            ')' => {\n  \
    \              curr_nesting -= 1;\n            }\n            ' ' => {\n     \
    \           result.push(max_nesting);\n                max_nesting = 0;\n    \
    \            curr_nesting = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<char> = Vec::new();\n    let mut max_depth: isize = 0;\n  \
    \  let mut curr_depth: isize = 0;\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            paren_stack.push(c);\n            curr_depth +=\
    \ 1;\n            if curr_depth > max_depth {\n                max_depth = curr_depth;\n\
    \            }\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            curr_depth -= 1;\n        } else if c == ' ' {\n            paren_vec.push(max_depth);\n\
    \            max_depth = 0;\n            curr_depth = 0;\n        }\n    }\n \
    \   paren_vec.push(max_depth);\n    paren_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut paren_count: isize = 0;\n\
    \    let mut max_count: isize = 0;\n    let mut paren_string = paren_string.chars();\n\
    \    while let Some(paren) = paren_string.next() {\n        match paren {\n  \
    \          '(' => {\n                paren_stack.push(paren_count);\n        \
    \        paren_count += 1;\n                max_count = max(max_count, paren_count);\n\
    \            }\n            ')' => {\n                paren_stack.pop();\n   \
    \             paren_count -= 1;\n            }\n            ' ' => {\n       \
    \         paren_vec.push(max_count);\n                max_count = 0;\n       \
    \         paren_count = 0;\n            }\n            _ => {}\n        }\n  \
    \  }\n    paren_vec.push(max_count);\n    paren_vec\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppatbqbcn.rs:17:29\n\
    \   |\n17 |                 max_count = max(max_count, paren_count);\n   |   \
    \                          ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Invalid character in input string\"),\n    \
    \    }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_nesting: isize\
    \ = 0;\n    let mut nesting_vec: Vec<isize> = Vec::new();\n\n    for paren in\
    \ paren_vec {\n        if paren == '(' {\n            paren_stack.push(paren);\n\
    \            max_nesting += 1;\n        } else if paren == ')' {\n           \
    \ paren_stack.pop();\n            max_nesting -= 1;\n        } else if paren ==\
    \ ' ' {\n            nesting_vec.push(max_nesting);\n            max_nesting =\
    \ 0;\n        }\n    }\n\n    nesting_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpiz2p5fbs.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_depth: isize\
    \ = 0;\n    let mut depth: isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n\
    \n    while !paren_vec.is_empty() {\n        let paren = paren_vec.remove(0);\n\
    \        match paren {\n            '(' => {\n                paren_stack.push(paren);\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                if paren_stack.is_empty() {\n                  \
    \  panic!(\"Unbalanced parentheses!\");\n                }\n                paren_stack.pop();\n\
    \                depth -= 1;\n            }\n            ' ' => {\n          \
    \      if paren_stack.is_empty() {\n                    result.push(max_depth);\n\
    \                    max_depth = 0;\n                    depth = 0;\n        \
    \        }\n            }\n            _ => panic!(\"Invalid character in parentheses\
    \ string!\"),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgrt_k5uk.rs:45:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting += 1;\n    \
    \            if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_vec.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => (),\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_count: Vec<isize> = Vec::new();\n    let mut max_count: isize\
    \ = 0;\n    let mut curr_count: isize = 0;\n    let mut i: usize = 0;\n    while\
    \ i < paren_vec.len() {\n        if paren_vec[i] == '(' {\n            curr_count\
    \ += 1;\n            if curr_count > max_count {\n                max_count =\
    \ curr_count;\n            }\n        } else if paren_vec[i] == ')' {\n      \
    \      curr_count -= 1;\n        } else if paren_vec[i] == ' ' {\n           \
    \ paren_count.push(max_count);\n            max_count = 0;\n            curr_count\
    \ = 0;\n        }\n        i += 1;\n    }\n    paren_count.push(max_count);\n\
    \    paren_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                curr_nesting += 1;\n    \
    \            if curr_nesting > max_nesting {\n                    max_nesting\
    \ = curr_nesting;\n                }\n            }\n            ')' => {\n  \
    \              curr_nesting -= 1;\n            }\n            ' ' => {\n     \
    \           result.push(max_nesting);\n                max_nesting = 0;\n    \
    \            curr_nesting = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depth_vec: Vec<isize> = Vec::new();\n   \
    \ for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_depth += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_depth -= 1;\n        } else if c == ' ' {\n            depth_vec.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    depth_vec.push(max_depth);\n\
    \    depth_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpim0u8njx.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n                stack.push(c);\n            }\n          \
    \  ')' => {\n                depth -= 1;\n                stack.pop();\n     \
    \       }\n            ' ' => {\n                if stack.is_empty() {\n     \
    \               result.push(max_depth);\n                    max_depth = 0;\n\
    \                    depth = 0;\n                }\n            }\n          \
    \  _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp5oxr2reb.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    let mut max_nesting_level\
    \ = 0;\n    let mut nesting_level = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting_level += 1;\n\
    \                if nesting_level > max_nesting_level {\n                    max_nesting_level\
    \ = nesting_level;\n                }\n            }\n            ')' => {\n \
    \               nesting_level -= 1;\n            }\n            ' ' => {\n   \
    \             max_nesting_levels.push(max_nesting_level);\n                max_nesting_level\
    \ = 0;\n                nesting_level = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                if current_nesting > 0 {\n                    current_nesting\
    \ -= 1;\n                }\n            }\n            ' ' => {\n            \
    \    result.push(max_nesting);\n                max_nesting = 0;\n           \
    \     current_nesting = 0;\n            }\n            _ => {}\n        }\n  \
    \  }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                if current_nesting > 0 {\n                    current_nesting\
    \ -= 1;\n                }\n            }\n            ' ' => {\n            \
    \    result.push(max_nesting);\n                max_nesting = 0;\n           \
    \     current_nesting = 0;\n            }\n            _ => {}\n        }\n  \
    \  }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut max_depth_vec = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            depth += 1;\n            if depth > max_depth {\n\
    \                max_depth = depth;\n            }\n        } else if c == ')'\
    \ {\n            depth -= 1;\n        } else if c == ' ' {\n            max_depth_vec.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depth_vec.push(max_depth);\n\
    \    max_depth_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut max_depth:\
    \ isize = 0;\n    let mut current_depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_nesting =\
    \ 0;\n    let mut current_nesting = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n \
    \   let mut curr_depth: isize = 0;\n    let mut paren_string = paren_string.chars();\n\
    \    while let Some(c) = paren_string.next() {\n        match c {\n          \
    \  '(' => {\n                paren_stack.push(1);\n                curr_depth\
    \ += 1;\n                if curr_depth > max_depth {\n                    max_depth\
    \ = curr_depth;\n                }\n            }\n            ')' => {\n    \
    \            paren_stack.pop();\n                curr_depth -= 1;\n          \
    \  }\n            ' ' => {\n                if paren_stack.is_empty() {\n    \
    \                paren_vec.push(max_depth);\n                    max_depth = 0;\n\
    \                    curr_depth = 0;\n                }\n            }\n     \
    \       _ => {}\n        }\n    }\n    paren_vec.push(max_depth);\n    paren_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut curr_depth = 0;\n \
    \   let mut max_depths = Vec::new();\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            curr_depth += 1;\n            if curr_depth\
    \ > max_depth {\n                max_depth = curr_depth;\n            }\n    \
    \    } else if c == ')' {\n            curr_depth -= 1;\n            if curr_depth\
    \ == 0 {\n                max_depths.push(max_depth);\n                max_depth\
    \ = 0;\n            }\n        }\n    }\n    max_depths\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut max_depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                max_depths.push(max_depth);\n     \
    \           max_depth = 0;\n                depth = 0;\n            }\n      \
    \      _ => {}\n        }\n    }\n    max_depths.push(max_depth);\n    max_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_level = 0;\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_levels = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                if current_nesting_level\
    \ > 0 {\n                    current_nesting_level -= 1;\n                }\n\
    \            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         paren_stack.push(c);\n            current_depth += 1;\n            if\
    \ current_depth > max_depth {\n                max_depth = current_depth;\n  \
    \          }\n        } else if c == ')' {\n            if paren_stack.pop() !=\
    \ Some('(') {\n                panic!(\"Invalid parentheses string\");\n     \
    \       }\n            current_depth -= 1;\n        } else if c == ' ' {\n   \
    \         result.push(max_depth);\n            max_depth = 0;\n            current_depth\
    \ = 0;\n        } else {\n            panic!(\"Invalid parentheses string\");\n\
    \        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut current_depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            paren_vec.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    paren_vec.push(max_depth);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                max_nesting_vec.push(max_nesting);\n        \
    \        max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_level = 0;\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_levels = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                current_nesting_level -=\
    \ 1;\n            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting_level += 1;\n        \
    \    if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if c == ')' {\n    \
    \        current_nesting_level -= 1;\n        } else if c == ' ' {\n         \
    \   max_nesting_levels.push(max_nesting_level);\n            max_nesting_level\
    \ = 0;\n            current_nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths: Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                depth += 1;\n      \
    \          if depth > max_depth {\n                    max_depth = depth;\n  \
    \              }\n            }\n            ')' => {\n                depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                result.push(max_nesting);\n                max_nesting\
    \ = 0;\n                current_nesting = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut results = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                nesting += 1;\n          \
    \      if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                results.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    results.push(max_nesting);\n    results\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_stack =\
    \ Vec::new();\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_stack.push(c);\n            max_depth\
    \ += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n      \
    \      if paren_stack.is_empty() {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpy9ulb9jq.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depths: Vec<isize> = Vec::new();\n    let\
    \ mut current_depth: isize = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            paren_stack.push(c);\n            current_depth +=\
    \ 1;\n            if current_depth > max_depth {\n                max_depth =\
    \ current_depth;\n            }\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            current_depth -= 1;\n        } else if c == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                if stack.pop().is_none() {\n                   \
    \ panic!(\"Unbalanced parentheses\");\n                }\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                if stack.is_empty()\
    \ {\n                    result.push(max_depth);\n                    max_depth\
    \ = 0;\n                    depth = 0;\n                }\n            }\n   \
    \         _ => panic!(\"Invalid character\"),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp71i8dyvj.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpqukgrxif.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = std::cmp::max(max_depth,\
    \ depth);\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(max_depth);\n            max_depth =\
    \ 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpdeti6xnp.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpn6ketb_h.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_level = 0;\n\
    \    let mut current_level = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_level += 1;\n     \
    \           if current_level > max_level {\n                    max_level = current_level;\n\
    \                }\n            }\n            ')' => {\n                current_level\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_level);\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {\n   \
    \             panic!(\"Invalid character in input string\");\n            }\n\
    \        }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp9b5ubcro.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                if stack.pop().is_none() {\n                   \
    \ panic!(\"Unmatched parentheses!\");\n                }\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                if stack.is_empty()\
    \ {\n                    result.push(max_depth);\n                    max_depth\
    \ = 0;\n                    depth = 0;\n                }\n            }\n   \
    \         _ => panic!(\"Invalid character!\"),\n        }\n    }\n    if !stack.is_empty()\
    \ {\n        panic!(\"Unmatched parentheses!\");\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut paren_count: isize = 0;\n\
    \    let mut max_paren_count: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_count += 1;\n            paren_stack.push(paren_count);\n\
    \        } else if c == ')' {\n            paren_stack.pop();\n            if\
    \ paren_stack.is_empty() {\n                paren_vec.push(paren_count);\n   \
    \             paren_count = 0;\n            }\n        }\n    }\n    paren_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpddkysbqk.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpr7r0nf7i.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp4oxi5o6e.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_depth: isize = 0;\n    let mut max_depth_list: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(max_depth);\n\
    \            max_depth += 1;\n        } else if c == ')' {\n            max_depth_list.push(max_depth);\n\
    \            max_depth = paren_stack.pop().unwrap();\n        }\n    }\n    max_depth_list\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp67oznpkj.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting += 1;\n    \
    \            if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_vec.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_level:\
    \ isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = std::cmp::max(max_depth,\
    \ depth);\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(max_depth);\n            max_depth =\
    \ 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n \
    \   let mut depth: isize = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \               paren_stack.push(depth);\n            }\n            ')' => {\n\
    \                depth -= 1;\n                paren_stack.pop();\n           \
    \ }\n            ' ' => {\n                if paren_stack.len() == 0 {\n     \
    \               paren_vec.push(max_depth);\n                    max_depth = 0;\n\
    \                    depth = 0;\n                }\n            }\n          \
    \  _ => {}\n        }\n    }\n    paren_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprh53ypyq.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                curr_nesting += 1;\n    \
    \            if curr_nesting > max_nesting {\n                    max_nesting\
    \ = curr_nesting;\n                }\n            }\n            ')' => {\n  \
    \              curr_nesting -= 1;\n            }\n            ' ' => {\n     \
    \           result.push(max_nesting);\n                max_nesting = 0;\n    \
    \            curr_nesting = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp7fzy5sbo.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_level:\
    \ isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut max_count = 0;\n\
    \    let mut max_counts = Vec::new();\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            paren_count += 1;\n            if paren_count\
    \ > max_count {\n                max_count = paren_count;\n            }\n   \
    \     } else if c == ')' {\n            paren_count -= 1;\n        } else if c\
    \ == ' ' {\n            max_counts.push(max_count);\n            max_count = 0;\n\
    \            paren_count = 0;\n        }\n    }\n    max_counts.push(max_count);\n\
    \    max_counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n \
    \   let mut curr_depth: isize = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            curr_depth += 1;\n            paren_stack.push(curr_depth);\n\
    \            if curr_depth > max_depth {\n                max_depth = curr_depth;\n\
    \            }\n        } else if c == ')' {\n            let top_depth = paren_stack.pop().unwrap();\n\
    \            if top_depth == curr_depth {\n                paren_vec.push(max_depth);\n\
    \                max_depth = 0;\n                curr_depth = 0;\n           \
    \ } else {\n                curr_depth = top_depth;\n            }\n        }\n\
    \    }\n    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 4, 3, 3, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmptit5x5h7.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                curr_nesting += 1;\n    \
    \            if curr_nesting > max_nesting {\n                    max_nesting\
    \ = curr_nesting;\n                }\n            }\n            ')' => {\n  \
    \              curr_nesting -= 1;\n            }\n            ' ' => {\n     \
    \           result.push(max_nesting);\n                max_nesting = 0;\n    \
    \            curr_nesting = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = std::cmp::max(max_depth,\
    \ depth);\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(max_depth);\n            max_depth =\
    \ 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut max_depth_list: Vec<isize> = Vec::new();\n\
    \    let mut current_depth: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_stack.push(c);\n            current_depth\
    \ += 1;\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth;\n            }\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            current_depth -= 1;\n        } else if c == ' ' {\n            max_depth_list.push(max_depth);\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    max_depth_list.push(max_depth);\n    max_depth_list\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depths: Vec<isize> = Vec::new();\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_depth += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_depth -= 1;\n        } else if c == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpha9_kl0r.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut curr_depth = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            curr_depth += 1;\n            if curr_depth > max_depth\
    \ {\n                max_depth = curr_depth;\n            }\n        } else if\
    \ c == ')' {\n            curr_depth -= 1;\n        } else if c == ' ' {\n   \
    \         result.push(max_depth);\n            max_depth = 0;\n            curr_depth\
    \ = 0;\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                if current_nesting > 0 {\n                  \
    \  current_nesting -= 1;\n                }\n            }\n            ' ' =>\
    \ {\n                max_nesting_vec.push(max_nesting);\n                max_nesting\
    \ = 0;\n                current_nesting = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n    max_nesting_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = Vec::new();\n    let mut current_nesting\
    \ = 0;\n    let mut max_current_nesting = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting += 1;\n            if\
    \ current_nesting > max_current_nesting {\n                max_current_nesting\
    \ = current_nesting;\n            }\n        } else if c == ')' {\n          \
    \  current_nesting -= 1;\n        } else if c == ' ' {\n            max_nesting.push(max_current_nesting);\n\
    \            max_current_nesting = 0;\n            current_nesting = 0;\n    \
    \    }\n    }\n    max_nesting.push(max_current_nesting);\n    max_nesting\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => panic!(\"Unexpected character in input string\"),\n        }\n    }\n\
    \    result.push(max_depth);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmph_rwzroj.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         stack.push(c);\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            if stack.len() > 0 {\n             \
    \   stack.pop();\n                current_depth -= 1;\n            } else {\n\
    \                result.push(0);\n                current_depth = 0;\n       \
    \         max_depth = 0;\n            }\n        } else if c == ' ' {\n      \
    \      result.push(max_depth);\n            current_depth = 0;\n            max_depth\
    \ = 0;\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut max_nesting:\
    \ isize = 0;\n    let mut current_nesting: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                result.push(max_nesting);\n                max_nesting\
    \ = 0;\n                current_nesting = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_level: isize = 0;\n \
    \   let mut curr_level: isize = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            paren_stack.push(1);\n            curr_level +=\
    \ 1;\n            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            curr_level -= 1;\n        } else if c == ' ' {\n            paren_vec.push(max_level);\n\
    \            max_level = 0;\n            curr_level = 0;\n        }\n    }\n \
    \   paren_vec.push(max_level);\n    paren_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut max_depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                max_depths.push(max_depth);\n     \
    \           max_depth = 0;\n                depth = 0;\n            }\n      \
    \      _ => {}\n        }\n    }\n    max_depths.push(max_depth);\n    max_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                max_nesting_vec.push(max_nesting);\n        \
    \        max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting += 1;\n    \
    \            if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_vec.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                max_nesting_vec.push(max_nesting);\n        \
    \        max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut max_nesting_vec = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting += 1;\n    \
    \            if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_vec.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: Vec<isize> = Vec::new();\n    let mut depth: isize = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            depth += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            depth -= 1;\n        } else if c == ' ' {\n            max_depth.push(depth);\n\
    \            depth = 0;\n        }\n    }\n    max_depth\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp6k8ek8no.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_level = 0;\n\
    \    let mut curr_level = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            curr_level += 1;\n            if curr_level > max_level\
    \ {\n                max_level = curr_level;\n            }\n        } else if\
    \ c == ')' {\n            curr_level -= 1;\n        } else if c == ' ' {\n   \
    \         result.push(max_level);\n            max_level = 0;\n            curr_level\
    \ = 0;\n        }\n    }\n    result.push(max_level);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_nesting: isize = 0;\n    let mut max_nesting_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_nesting += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_nesting -= 1;\n        } else if c == ' ' {\n            max_nesting_vec.push(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmppgb69wmi.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<char> = Vec::new();\n    let mut max_level: isize = 0;\n  \
    \  let mut curr_level: isize = 0;\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                paren_stack.push(c);\n  \
    \              curr_level += 1;\n                if curr_level > max_level {\n\
    \                    max_level = curr_level;\n                }\n            }\n\
    \            ')' => {\n                paren_stack.pop();\n                curr_level\
    \ -= 1;\n            }\n            ' ' => {\n                paren_vec.push(max_level);\n\
    \                max_level = 0;\n                curr_level = 0;\n           \
    \ }\n            _ => {\n                panic!(\"Invalid character in input string\"\
    );\n            }\n        }\n    }\n    paren_vec.push(max_level);\n    paren_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_depth += 1;\n     \
    \           if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                curr_nesting += 1;\n    \
    \            if curr_nesting > max_nesting {\n                    max_nesting\
    \ = curr_nesting;\n                }\n            }\n            ')' => {\n  \
    \              curr_nesting -= 1;\n            }\n            ' ' => {\n     \
    \           result.push(max_nesting);\n                max_nesting = 0;\n    \
    \            curr_nesting = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ max_level: isize = 0;\n    let mut curr_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    } else if c == ')' {\n            curr_level -= 1;\n        } else if c ==\
    \ ' ' {\n            paren_vec.push(max_level);\n            max_level = 0;\n\
    \            curr_level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depths: Vec<isize> = Vec::new();\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_depth += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_depth -= 1;\n        } else if c == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvkfridex.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut paren_counts = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                paren_counts.push(max_nesting);\n           \
    \     max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    paren_counts.push(max_nesting);\n\
    \    paren_counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut max_nesting_list = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                nesting += 1;\n    \
    \            if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_list.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_list.push(max_nesting);\n\
    \    max_nesting_list\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n \
    \   let mut curr_depth: isize = 0;\n    for c in paren_string.chars() {\n    \
    \    match c {\n            '(' => {\n                curr_depth += 1;\n     \
    \           paren_stack.push(curr_depth);\n                if curr_depth > max_depth\
    \ {\n                    max_depth = curr_depth;\n                }\n        \
    \    }\n            ')' => {\n                if paren_stack.len() > 0 {\n   \
    \                 paren_stack.pop();\n                    if paren_stack.len()\
    \ > 0 {\n                        curr_depth = *paren_stack.last().unwrap();\n\
    \                    } else {\n                        curr_depth = 0;\n     \
    \               }\n                }\n            }\n            ' ' => {\n  \
    \              paren_vec.push(max_depth);\n                max_depth = 0;\n  \
    \              curr_depth = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    paren_vec.push(max_depth);\n    paren_vec\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => (),\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut current_depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                stack.pop();\n              \
    \  current_depth -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => (),\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut result = Vec::new();\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                nesting += 1;\n           \
    \     if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                stack.pop();\n                depth -= 1;\n    \
    \        }\n            ' ' => {\n                result.push(max_depth);\n  \
    \              max_depth = 0;\n                depth = 0;\n            }\n   \
    \         _ => panic!(\"Invalid input\"),\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpkazrf035.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_nesting: isize\
    \ = 0;\n    let mut nesting_vec: Vec<isize> = Vec::new();\n\n    for paren in\
    \ paren_vec {\n        if paren == '(' {\n            paren_stack.push(paren);\n\
    \            if paren_stack.len() as isize > max_nesting {\n                max_nesting\
    \ = paren_stack.len() as isize;\n            }\n        } else if paren == ')'\
    \ {\n            paren_stack.pop();\n        } else if paren == ' ' {\n      \
    \      nesting_vec.push(max_nesting);\n            max_nesting = 0;\n        }\n\
    \    }\n    nesting_vec.push(max_nesting);\n    nesting_vec\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels = Vec::new();\n    let mut paren_stack\
    \ = Vec::new();\n    let mut current_level = 0;\n    let mut max_level = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_level += 1;\n                max_level = std::cmp::max(max_level,\
    \ current_level);\n                paren_stack.push(c);\n            }\n     \
    \       ')' => {\n                current_level -= 1;\n                paren_stack.pop();\n\
    \            }\n            ' ' => {\n                max_levels.push(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n            _ => panic!(\"Unexpected character in input string\"),\n \
    \       }\n    }\n    max_levels.push(max_level);\n    max_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        } else if c == ')' {\n            depth -= 1;\n        } else if c ==\
    \ ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppsh91r05.rs:13:25\n\
    \   |\n13 |             max_depth = max(max_depth, depth);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_level: isize = 0;\n    let mut max_level_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \            max_level += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_level -= 1;\n        } else if c == ' ' {\n            max_level_vec.push(max_level);\n\
    \            max_level = 0;\n        }\n    }\n    max_level_vec.push(max_level);\n\
    \    max_level_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmplebypdq_.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' => {\n                depth += 1;\n                if\
    \ depth > max_depth {\n                    max_depth = depth;\n              \
    \  }\n            }\n            ')' => {\n                depth -= 1;\n     \
    \       }\n            ' ' => {\n                depths.push(max_depth);\n   \
    \             max_depth = 0;\n                depth = 0;\n            }\n    \
    \        _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_stack: Vec<char> = Vec::new();\n    let mut max_nesting: isize = 0;\n\
    \    let mut curr_nesting: isize = 0;\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            paren_stack.push(c);\n            curr_nesting\
    \ += 1;\n            if curr_nesting > max_nesting {\n                max_nesting\
    \ = curr_nesting;\n            }\n        } else if c == ')' {\n            if\
    \ paren_stack.len() > 0 {\n                paren_stack.pop();\n              \
    \  curr_nesting -= 1;\n            } else {\n                paren_vec.push(-1);\n\
    \                curr_nesting = 0;\n                max_nesting = 0;\n       \
    \     }\n        } else if c == ' ' {\n            if paren_stack.len() == 0 {\n\
    \                paren_vec.push(max_nesting);\n                curr_nesting =\
    \ 0;\n                max_nesting = 0;\n            }\n        }\n    }\n    if\
    \ paren_stack.len() == 0 {\n        paren_vec.push(max_nesting);\n    } else {\n\
    \        paren_vec.push(-1);\n    }\n    paren_vec\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
