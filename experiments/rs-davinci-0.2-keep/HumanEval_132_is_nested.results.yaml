name: HumanEval_132_is_nested
language: rust
results:
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2mgbe789.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp02wplfv_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8u_90lzq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7rfkkeoa.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkvkdzv0p.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2e72mqn7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_0iu_bd0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvjs2blt2.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6q22j4ir.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if !stack.is_empty() {\n            stack.pop();\n        }\n \
    \   }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoa8dsohv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpidszqhbn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg8t2vzmf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm4glz64v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpydhpvtd1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxg1utdhl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt35m532l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvm52zrlf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp25_o2bxt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    stack.len() > 1\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw_bkw26z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl5ge4r_g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuhmowxpk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvvpqfx5g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps78gd134.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_3ak_szw.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzddmkh9i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1wfmw1ag.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpznlmgv77.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk7a1ydu4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp30o13u3w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_gzdvzgq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyd177iyl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6hnq74h7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz_gp4bo2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcd2_sqk8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmhmca919.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1a77vjx8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgayfsslr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi5ms3zzb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4dtmfgev.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2t8ceh__.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    return !stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcn8tcssa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv0v05_f_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptxjseihl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Unexpected character\"),\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt9_eoili.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fdcr2kf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqiojxd10.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplqqcptku.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqam8gmo1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp39jnqktp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8t92edc3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd6b5tixo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdra1z9ub.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2id78qkz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpawafa2iy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj1wpqz6d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdhxm4ifl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplp93kxj8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7gjccvve.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Unexpected character\"),\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxfzcdclp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcdx_ezfp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7f80rp5q.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwpr8kb77.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7lg2enk7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(x) = stack.pop() {\n      \
    \              if x != '[' {\n                        return false;\n        \
    \            }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxj3qb9be.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkrjixzqy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptp7ksm0a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk22yf8vk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpewlbt723.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpor8smvwx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5t7n1v_l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvd94a_qu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n \
    \   stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2cj62iq0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => unreachable!(),\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpouqtbe9d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpclwa9uhv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkdf6yv2p.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps2oh_8ci.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpju_ux4i1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => continue,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2ubf5bg8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqzzgmc_w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6uj_usfw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptdxnhgca.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for ch\
    \ in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n \
    \       } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjynois00.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2fb6kxys.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr91mranj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5yrk8byh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprnf54esy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph1mm5kp2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphj07n_y9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqse1lfiz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuf3crx5w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1raxy323.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.len() > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9p2i8nhh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n \
    \   stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbzqute7o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj5ysmd0l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n \
    \   !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37l95hdj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv4kp7u_n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxtcgla4g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl1t53ssn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf21h66zc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphmxsfzse.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr329lr1u.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvuqsslym.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    return !stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx04pz0zs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphyi9y4r6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_4rl0a2s.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkg0lt7gl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqx7l6gue.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7881s9op.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu6iqr_pn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8p_t0a0k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2fp_u0bk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfo2oq36u.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpco7453x8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                if stack.pop().unwrap()\
    \ != '[' {\n                    return false;\n                }\n           \
    \ }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptuc0zq3e.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsp46cls9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbyq24kx2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr_q6fdio.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz4_s_1ow.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if let Some(x) = stack.pop() {\n   \
    \             if x != '[' {\n                    return false;\n             \
    \   }\n            } else {\n                return false;\n            }\n  \
    \      }\n    }\n    if stack.len() > 0 {\n        return false;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq6s4qr2a.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfcvxf9tr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbfatunux.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaydss7da.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdl7q2vgn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqtmqm4xj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnbynrv50.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsfuw2nl0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprvrlpphv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0gfcscnu.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoeggwhxn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq4wvckh2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaum1zro8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnpv0nmls.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoh76at7k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1topson3.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2uwuti6y.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp49wluars.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvpykt9oo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgcg6g50s.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7q05_8qm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n \
    \       } else if c == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiruqhjry.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6z6hfzw2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjd3n8cxj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp32k82u0t.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => continue,\n        }\n    }\n    stack.len() > 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl8pigto4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo3dp0mxa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3oxt6lxa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvntxfenj.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_rweakxb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6hy18bvi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpphmazlox.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8bx7s4ex.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character in string\"),\n        }\n\
    \    }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6cn_df5i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptml769nx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeebgd_tk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => continue,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpegnlm01y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiejawpbj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdrq2fuxs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1yrkvwfo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpet3u_p0s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmpc02hoj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmwyawugb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg_b0173a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzes4p4by.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_zipz9h0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj4uypxxs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxhsi_vg1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjgyi147l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character in input string\"),\n   \
    \     }\n    }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfmzb5_i2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplxdxg94a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2rcyo5d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmvbjnl4x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmfql5kew.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfb_f22c4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwwn2f6_j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj__jf7ax.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbzgpi1gt.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsmmmmzcy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    stack.len() > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphi6y44r6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppgetctk0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg275p4y9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwms6y1st.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbkvxk27x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg25_92fz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0b8mrtiw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpojbjy4ch.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfa02as5g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n \
    \   !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq2m6t2ke.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe9ftdn9s.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmzaqkzkc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplfeym43g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpekcfu02s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5vy22llr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbmafcqgg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph0y66gvf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg0wqvpwn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsp169zro.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() > 0 {\n                \
    \    stack.pop();\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprkmcd172.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkrigu90w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6itskb_i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd6012zem.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
