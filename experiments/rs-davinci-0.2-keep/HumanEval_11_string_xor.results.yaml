name: HumanEval_11_string_xor
language: rust
results:
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        match (a_chars.next(), b_chars.next()) {\n\
    \            (Some(a_char), Some(b_char)) => {\n                result.push(if\
    \ a_char == b_char { '0' } else { '1' });\n            }\n            _ => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                if a_char == b_char\
    \ {\n                    result.push('0');\n                } else {\n       \
    \             result.push('1');\n                }\n            }\n          \
    \  _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        if x == y {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap();\n        let y = j.to_digit(10).unwrap();\n\
    \        result.push_str(&format!(\"{}\", x ^ y));\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap();\n        let y = j.to_digit(10).unwrap();\n\
    \        result.push_str(&format!(\"{}\", x ^ y));\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        let x = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n        result.push_str(&x.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result\
    \ = String::new();\n    for i in 0..a_bytes.len() {\n        let a_bit = a_bytes[i]\
    \ - b'0';\n        let b_bit = b_bytes[i] - b'0';\n        let result_bit = a_bit\
    \ ^ b_bit;\n        result.push(result_bit as char);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp6b5tvm91.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut result = String::new();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(x), Some(y))\
    \ => {\n                if x == y {\n                    result.push('0');\n \
    \               } else {\n                    result.push('1');\n            \
    \    }\n            }\n            _ => break,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap();\n        let y = j.to_digit(10).unwrap();\n\
    \        result.push_str(&(x ^ y).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                result.push(if\
    \ a_char == b_char { '0' } else { '1' });\n            }\n            _ => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        let x = x.to_digit(10).unwrap();\n        let y = y.to_digit(10).unwrap();\n\
    \        result.push_str(&(x ^ y).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                result.push_str(&(a_int\
    \ ^ b_int).to_string());\n            }\n            (None, None) => break,\n\
    \            _ => panic!(\"Inputs must be of equal length\"),\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let a_chars = a.chars();\n    let b_chars =\
    \ b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars) {\n        let\
    \ a_int = a_char.to_digit(10).unwrap();\n        let b_int = b_char.to_digit(10).unwrap();\n\
    \        let xor_int = a_int ^ b_int;\n        result.push_str(&xor_int.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        let a_char = a_chars.next();\n        let\
    \ b_char = b_chars.next();\n        if a_char.is_none() || b_char.is_none() {\n\
    \            break;\n        }\n        let a_char = a_char.unwrap();\n      \
    \  let b_char = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    for i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n\
    \        let b_byte = b_bytes[i];\n        let a_bit = a_byte - 48;\n        let\
    \ b_bit = b_byte - 48;\n        let xor_bit = a_bit ^ b_bit;\n        result.push(xor_bit\
    \ as u8 + 48);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6v98ad2.rs:15:21\n   |\n\
    15 |         result.push(xor_bit as u8 + 48);\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `u8`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => ' ',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        let x = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n        result.push_str(&x.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        match (a_char, b_char) {\n            (Some(a), Some(b))\
    \ => {\n                if a == b {\n                    result.push('0');\n \
    \               } else {\n                    result.push('1');\n            \
    \    }\n            }\n            (Some(_), None) => {\n                result.push('0');\n\
    \            }\n            (None, Some(_)) => {\n                result.push('0');\n\
    \            }\n            (None, None) => {\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let a_char =\
    \ a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let xor_char = if a_char == b_char {\n            '0'\n        } else\
    \ {\n            '1'\n        };\n        result.push(xor_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap();\n        let y = j.to_digit(10).unwrap();\n\
    \        result.push_str(&(x ^ y).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    for i in 0..a_bytes.len() {\n        result.push(match\
    \ (a_bytes[i], b_bytes[i]) {\n            (b'0', b'0') => '0',\n            (b'0',\
    \ b'1') => '1',\n            (b'1', b'0') => '1',\n            (b'1', b'1') =>\
    \ '0',\n            _ => unreachable!(),\n        });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                if a_char == b_char\
    \ {\n                    result.push('0');\n                } else {\n       \
    \             result.push('1');\n                }\n            }\n          \
    \  _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                let\
    \ result_int = a_int ^ b_int;\n                result.push_str(&result_int.to_string());\n\
    \            }\n            (None, None) => break,\n            _ => panic!(\"\
    Inputs must be of equal length\"),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        match (a_chars.next(), b_chars.next()) {\n\
    \            (Some(a_char), Some(b_char)) => {\n                result.push(if\
    \ a_char == b_char { '0' } else { '1' });\n            }\n            _ => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                if a_char == b_char\
    \ {\n                    result.push('0');\n                } else {\n       \
    \             result.push('1');\n                }\n            }\n          \
    \  _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        let a_char = a_chars.next();\n        let\
    \ b_char = b_chars.next();\n        if a_char.is_none() || b_char.is_none() {\n\
    \            break;\n        }\n        let a_char = a_char.unwrap();\n      \
    \  let b_char = b_char.unwrap();\n        let a_digit = a_char.to_digit(10).unwrap();\n\
    \        let b_digit = b_char.to_digit(10).unwrap();\n        let result_digit\
    \ = a_digit ^ b_digit;\n        result.push_str(&result_digit.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        match (a_char, b_char) {\n            (Some(a), Some(b))\
    \ => {\n                let a_num = a.to_digit(10).unwrap();\n               \
    \ let b_num = b.to_digit(10).unwrap();\n                let result_num = a_num\
    \ ^ b_num;\n                result.push_str(&result_num.to_string());\n      \
    \      }\n            (Some(_), None) => {\n                result.push_str(&a_char.unwrap().to_string());\n\
    \            }\n            (None, Some(_)) => {\n                result.push_str(&b_char.unwrap().to_string());\n\
    \            }\n            (None, None) => {\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let a_char =\
    \ a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let xor_char = if a_char == b_char {\n            '0'\n        } else\
    \ {\n            '1'\n        };\n        result.push(xor_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                let\
    \ result_int = a_int ^ b_int;\n                result.push_str(&result_int.to_string());\n\
    \            }\n            (None, None) => break,\n            _ => panic!(\"\
    Inputs must be of equal length\"),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                let\
    \ xor_int = a_int ^ b_int;\n                result.push_str(&xor_int.to_string());\n\
    \            }\n            (None, None) => break,\n            _ => panic!(\"\
    Strings are not of equal length\"),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input.\"),\n        });\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let a_char =\
    \ a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let a_int = a_char.to_digit(10).unwrap();\n        let b_int = b_char.to_digit(10).unwrap();\n\
    \        let xor_int = a_int ^ b_int;\n        let xor_char = xor_int.to_string();\n\
    \        result.push_str(&xor_char);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => ' ',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result\
    \ = String::new();\n    for i in 0..a_bytes.len() {\n        let a_bit = a_bytes[i]\
    \ - 48;\n        let b_bit = b_bytes[i] - 48;\n        let xor_bit = a_bit ^ b_bit;\n\
    \        result.push(xor_bit as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpsusgem6w.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        match (a_chars.next(), b_chars.next()) {\n\
    \            (Some(a_char), Some(b_char)) => {\n                if a_char == b_char\
    \ {\n                    result.push('0');\n                } else {\n       \
    \             result.push('1');\n                }\n            }\n          \
    \  _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n   \
    \     if i == j {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        let a_char = a_chars.next();\n        let\
    \ b_char = b_chars.next();\n        if a_char.is_none() || b_char.is_none() {\n\
    \            break;\n        }\n        let a_char = a_char.unwrap();\n      \
    \  let b_char = b_char.unwrap();\n        let xor_result = match (a_char, b_char)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"\
    Invalid input\"),\n        };\n        result.push(xor_result);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_char = a_iter.next();\n        let b_char\
    \ = b_iter.next();\n        if a_char.is_none() || b_char.is_none() {\n      \
    \      break;\n        }\n        let a_char = a_char.unwrap();\n        let b_char\
    \ = b_char.unwrap();\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap() ^ j.to_digit(10).unwrap();\n        result.push_str(&x.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (c1, c2) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Unexpected input\"),\n        });\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => unreachable!(),\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        let x = i.to_digit(10).unwrap();\n        let y = j.to_digit(10).unwrap();\n\
    \        result.push_str(&(x ^ y).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next()) {\n \
    \           (Some(a_char), Some(b_char)) => {\n                result.push(if\
    \ a_char == b_char { '0' } else { '1' });\n            }\n            _ => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(if i == j { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
