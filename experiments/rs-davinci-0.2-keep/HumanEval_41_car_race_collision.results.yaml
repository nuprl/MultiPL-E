name: HumanEval_41_car_race_collision
language: rust
results:
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvzx3ygxy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l == r {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp1g9xt1tp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuru8fqof.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = vec![0; n as usize];\n \
    \   let mut cars_right_to_left = vec![0; n as usize];\n    for i in 0..n {\n \
    \       cars_left_to_right[i as usize] = i;\n        cars_right_to_left[i as usize]\
    \ = n - i - 1;\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n    \
    \    for j in 0..n {\n            if cars_left_to_right[i as usize] == cars_right_to_left[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4jtg8q7z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp38tny5yc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right_cars\
    \ = vec![];\n    let mut right_to_left_cars = vec![];\n    for i in 0..n {\n \
    \       left_to_right_cars.push(i);\n        right_to_left_cars.push(n - i - 1);\n\
    \    }\n    while !left_to_right_cars.is_empty() && !right_to_left_cars.is_empty()\
    \ {\n        let left_car = left_to_right_cars.pop().unwrap();\n        let right_car\
    \ = right_to_left_cars.pop().unwrap();\n        if left_car > right_car {\n  \
    \          collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmphksv5fxs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            count += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvy61_6h5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpyr7nkabm.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6am3am2_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuqqq1mno.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpa4qfisqc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * i;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpi4qx6jv8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo1vfj582.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo1vfj582.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * j;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjii2z676.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjii2z676.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpv6s1vypn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp038sc0cl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut count = 0;\n    for i in 0..n {\n        for j\
    \ in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n         \
    \       count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4levuqu6.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4levuqu6.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpl0ge0r1g.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut left_to_right_index\
    \ = 0;\n    let mut right_to_left_index = 0;\n    while left_to_right_index <\
    \ n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else if left_to_right[left_to_right_index] > right_to_left[right_to_left_index]\
    \ {\n            right_to_left_index += 1;\n        } else {\n            collisions\
    \ += 1;\n            left_to_right_index += 1;\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn42yeioj.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn42yeioj.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn42yeioj.rs:22:19\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn42yeioj.rs:22:56\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpq8y8324_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collision_count = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collision_count += 1;\n        }\n    }\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpl4vfpvy7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpck4w_vg_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car <\
    \ right_car {\n            right_to_left.push(right_car);\n        } else {\n\
    \            left_to_right.push(left_car);\n            collisions += 1;\n   \
    \     }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp77ddj06t.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = Vec::new();\n    let mut\
    \ cars_right_to_left = Vec::new();\n    for i in 0..n {\n        cars_left_to_right.push(i);\n\
    \        cars_right_to_left.push(n - i - 1);\n    }\n    let mut collisions =\
    \ 0;\n    while !cars_left_to_right.is_empty() && !cars_right_to_left.is_empty()\
    \ {\n        let left_to_right_car = cars_left_to_right.pop().unwrap();\n    \
    \    let right_to_left_car = cars_right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ == right_to_left_car {\n            collisions += 1;\n        } else if left_to_right_car\
    \ > right_to_left_car {\n            cars_left_to_right.push(left_to_right_car);\n\
    \        } else {\n            cars_right_to_left.push(right_to_left_car);\n \
    \       }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpigc5k8vx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    let mut left_to_right_index\
    \ = 0;\n    let mut right_to_left_index = 0;\n    while left_to_right_index <\
    \ n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else if left_to_right[left_to_right_index] > right_to_left[right_to_left_index]\
    \ {\n            right_to_left_index += 1;\n        } else {\n            collisions\
    \ += 1;\n            left_to_right_index += 1;\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmfo3zegm.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpmfo3zegm.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpmfo3zegm.rs:22:19\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpmfo3zegm.rs:22:56\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i > j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpr7wklig1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpugwg3jda.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ count = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            count += j;\n            i += 1;\n        } else {\n        \
    \    j += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpz0o52gv9.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpz0o52gv9.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpy7d1j7y_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy_lt8352.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car ==\
    \ right_car {\n            collisions += 1;\n        } else if left_car > right_car\
    \ {\n            left_to_right.push(left_car);\n        } else {\n           \
    \ right_to_left.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp97h76yi_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    left_to_right.sort();\n    right_to_left.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if\
    \ left_to_right[i as usize] == right_to_left[j as usize] {\n            collisions\
    \ += 1;\n            i += 1;\n            j += 1;\n        } else if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpd5146idc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i] < right_to_left[j] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8ord1q6r.rs:19:12\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8ord1q6r.rs:19:31\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left > right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmnb23div.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car ==\
    \ right_car {\n            collisions += 1;\n        } else if left_car > right_car\
    \ {\n            left_to_right.push(left_car);\n        } else {\n           \
    \ right_to_left.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpgl2lq5t7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while left_to_right.len() > 0 && right_to_left.len()\
    \ > 0 {\n        let left_to_right_car = left_to_right.pop().unwrap();\n     \
    \   let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpsgi1id43.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut left_to_right = vec![];\n    let mut right_to_left = vec![];\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < n &&\
    \ j < n {\n        if left_to_right[i] < right_to_left[j] {\n            count\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp65mdwkxv.rs:23:12\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp65mdwkxv.rs:23:31\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpder5odd5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgiz0s9ho.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgiz0s9ho.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpof46_d6x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..n {\n      \
    \  collisions += i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpl84m0thl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.remove(0);\n        let right_car =\
    \ right_to_left.remove(0);\n        if left_car == right_car {\n            collisions\
    \ += 1;\n        } else if left_car > right_car {\n            left_to_right.push(left_car);\n\
    \        } else {\n            right_to_left.push(right_car);\n        }\n   \
    \ }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpgklwwlv1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpiumyc_u5.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmphxv3jcez.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<isize> = (0..n).collect();\n    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n\
    \    let mut count = 0;\n    while left_to_right.len() > 0 && right_to_left.len()\
    \ > 0 {\n        if left_to_right[0] == right_to_left[0] {\n            count\
    \ += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \        } else {\n            right_to_left.remove(0);\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9e828hpt.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut count = 0;\n    while i < n {\n        j = 0;\n\
    \        while j < n {\n            if i == j {\n                j += 1;\n   \
    \             continue;\n            }\n            if i < j {\n             \
    \   count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz0rjn7vh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = Vec::new();\n    let mut\
    \ cars_right_to_left = Vec::new();\n    for i in 0..n {\n        cars_left_to_right.push(i);\n\
    \        cars_right_to_left.push(i);\n    }\n    let mut collisions = 0;\n   \
    \ while !cars_left_to_right.is_empty() && !cars_right_to_left.is_empty() {\n \
    \       let car_left_to_right = cars_left_to_right.pop().unwrap();\n        let\
    \ car_right_to_left = cars_right_to_left.pop().unwrap();\n        if car_left_to_right\
    \ == car_right_to_left {\n            collisions += 1;\n        } else {\n   \
    \         cars_left_to_right.push(car_left_to_right);\n            cars_right_to_left.push(car_right_to_left);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnazpnx35.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        if left_to_right[i as usize] == right_to_left[i\
    \ as usize] {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp9ijace8n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpc8_sanj3.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpc8_sanj3.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ collisions = 0;\n    let mut left_to_right = vec![0; n as usize];\n    let mut\
    \ right_to_left = vec![0; n as usize];\n\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n\n  \
    \  let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if\
    \ left_to_right[i as usize] < right_to_left[j as usize] {\n            collisions\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n\n    collisions += (n - i) * (j as isize);\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprnio5_tk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::with_capacity(n as usize);\n\
    \    let mut right_to_left = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n\
    \    }\n    let mut count = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \            count += 1;\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpyp8bo2lt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfgg_fpzs.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfgg_fpzs.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i > j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9gtqlznr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpd0361_kz.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = Vec::new();\n    let mut\
    \ cars_right_to_left = Vec::new();\n    for i in 0..n {\n        cars_left_to_right.push(i);\n\
    \        cars_right_to_left.push(n - i - 1);\n    }\n    let mut collisions =\
    \ 0;\n    while !cars_left_to_right.is_empty() && !cars_right_to_left.is_empty()\
    \ {\n        let car_left_to_right = cars_left_to_right.pop().unwrap();\n    \
    \    let car_right_to_left = cars_right_to_left.pop().unwrap();\n        if car_left_to_right\
    \ > car_right_to_left {\n            collisions += 1;\n        } else {\n    \
    \        cars_left_to_right.push(car_left_to_right);\n            cars_right_to_left.push(car_right_to_left);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left = left_to_right[0];\n        let right = right_to_left[0];\n\
    \        if left < right {\n            left_to_right.remove(0);\n        } else\
    \ if right < left {\n            right_to_left.remove(0);\n        } else {\n\
    \            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpc_1dqwg4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpew9ng34j.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut count = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i as\
    \ usize] < right_to_left[j as usize] {\n            count += j;\n            i\
    \ += 1;\n        } else {\n            j += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpzfrvwsc3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * i;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz3pf2zs9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp84j4hctp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp1ky9_5wm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collision = 0;\n    for i in 0..n {\n        for j in 0..n {\n         \
    \   if left_to_right[i as usize] == right_to_left[j as usize] {\n            \
    \    collision += 1;\n            }\n        }\n    }\n    collision\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo_m2_u1n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function.\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp5ku6vhak.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i] < right_to_left[j] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpilgn91t6.rs:19:12\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpilgn91t6.rs:19:31\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    let mut collisions = 0;\n    for i in\
    \ 0..n {\n        cars_left[i as usize] = i;\n        cars_right[i as usize] =\
    \ n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n          \
    \  if cars_left[i as usize] == cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuh9sl71a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpn6oyl95d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprq4u_vdt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.remove(0);\n        let right_to_left_car\
    \ = right_to_left.remove(0);\n        if left_to_right_car == right_to_left_car\
    \ {\n            collisions += 1;\n        } else {\n            left_to_right.push(left_to_right_car);\n\
    \            right_to_left.push(right_to_left_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpi16_0mbx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    cars.sort();\n\
    \    for i in 0..n {\n        if cars[i as usize] != i {\n            collisions\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqlxqzpoe.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collision_count = 0;\n    let mut i = 0;\n   \
    \ let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collision_count += j;\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    collision_count += j * (n - i);\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpuzs5p819.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpuzs5p819.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left < right {\n\
    \            left_to_right.push(left);\n            right_to_left.push(right);\n\
    \        } else {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while left_to_right.len()\
    \ > 0 {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp519737ol.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    let mut collisions = 0;\n    for i in\
    \ 0..n {\n        cars_left[i as usize] = i;\n        cars_right[i as usize] =\
    \ n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n          \
    \  if cars_left[i as usize] == cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfo796tl8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpt1tkniat.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8zj870fd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if left_to_right[i as usize] == right_to_left[j as usize] {\n      \
    \          collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsji32vr8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = n - 1;\n    while i < n && j >= 0 {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j + 1;\n            i += 1;\n\
    \        } else {\n            j -= 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9yxg581x.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9yxg581x.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..n {\n      \
    \  collisions += i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmphzktc41e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = n - 1;\n    while i < n && j >= 0 {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j + 1;\n            i += 1;\n\
    \        } else {\n            j -= 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmlommxf2.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmlommxf2.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l == r {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt8foq19b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = 0;\n    let mut right_to_left\
    \ = 0;\n    let mut collisions = 0;\n    for i in 0..n {\n        left_to_right\
    \ += i;\n        right_to_left += n - i - 1;\n        collisions += left_to_right\
    \ * right_to_left;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpl1xo2q1e.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgaafiiyn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut count = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1_9g07_8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collision_count = 0;\n  \
    \  let mut left_index = 0;\n    let mut right_index = 0;\n    while left_index\
    \ < n && right_index < n {\n        if left_to_right[left_index] < right_to_left[right_index]\
    \ {\n            collision_count += right_index;\n            left_index += 1;\n\
    \        } else {\n            right_index += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpsjyzemgz.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_index] < right_to_left[right_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsjyzemgz.rs:20:40\n   |\n20 |         if left_to_right[left_index]\
    \ < right_to_left[right_index] {\n   |                                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car == right_car {\n           \
    \ collisions += 1;\n        } else {\n            cars_left.push(left_car);\n\
    \            cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmafrj6kn.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collision_count = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car > right_car {\n       \
    \     collision_count += 1;\n        }\n    }\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp1u2hah15.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !cars_left.is_empty()\
    \ && !cars_right.is_empty() {\n        if cars_left[0] < cars_right[0] {\n   \
    \         cars_left.remove(0);\n            collisions += 1;\n        } else {\n\
    \            cars_right.remove(0);\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprzgkpxm8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<_> = (0..n).collect();\n \
    \   let mut right_to_left: Vec<_> = (0..n).rev().collect();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i] < right_to_left[j] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6btru_r4.rs:16:12\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6btru_r4.rs:16:31\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left =\
    \ left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        } else if left\
    \ > right {\n            left_to_right.push(left);\n        } else {\n       \
    \     right_to_left.push(right);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpy3kl53c1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppjy9ror7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if cars_left[i as usize] > cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpl7t8m84_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpujg385_k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if cars_left[i as usize] == cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjtrezzm8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions += (n -\
    \ i) * (n - j);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp470d8e2z.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp470d8e2z.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right[0];\n        let right_car = right_to_left[0];\n\
    \        if left_car < right_car {\n            left_to_right.remove(0);\n   \
    \     } else if left_car > right_car {\n            right_to_left.remove(0);\n\
    \        } else {\n            collisions += 1;\n            left_to_right.remove(0);\n\
    \            right_to_left.remove(0);\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpc6tro340.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = vec![];\n    let mut cars_right_to_left\
    \ = vec![];\n    for i in 0..n {\n        cars_left_to_right.push(i);\n      \
    \  cars_right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n \
    \   while !cars_left_to_right.is_empty() && !cars_right_to_left.is_empty() {\n\
    \        let car_left_to_right = cars_left_to_right.pop().unwrap();\n        let\
    \ car_right_to_left = cars_right_to_left.pop().unwrap();\n        if car_left_to_right\
    \ == car_right_to_left {\n            collisions += 1;\n        } else if car_left_to_right\
    \ > car_right_to_left {\n            cars_left_to_right.push(car_left_to_right);\n\
    \            cars_right_to_left.push(car_right_to_left);\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut left_to_right = vec![0;\
    \ n as usize];\n    let mut right_to_left = vec![0; n as usize];\n    for i in\
    \ 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i as usize]\
    \ = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpk33rw00z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    let mut left_to_right_index\
    \ = 0;\n    let mut right_to_left_index = 0;\n    while left_to_right_index <\
    \ n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            collisions += 1;\n     \
    \       left_to_right_index += 1;\n        } else {\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv6rbrk_a.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpv6rbrk_a.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_car\
    \ = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            collisions += 1;\n        } else\
    \ if left_car > right_car {\n            left_to_right.push(left_car);\n     \
    \   } else {\n            right_to_left.push(right_car);\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8dujn7g3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = Vec::new();\n    let mut\
    \ cars_right_to_left = Vec::new();\n    for i in 0..n {\n        cars_left_to_right.push(i);\n\
    \        cars_right_to_left.push(i);\n    }\n    cars_left_to_right.sort();\n\
    \    cars_right_to_left.sort();\n    let mut collisions = 0;\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if cars_left_to_right[i\
    \ as usize] < cars_right_to_left[j as usize] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp_y5i1f_7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpfeucg50w.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpk1tqz9mh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = 0;\n    let mut right_to_left\
    \ = 0;\n    let mut collisions = 0;\n    let mut i = 0;\n    while i < n {\n \
    \       left_to_right += 1;\n        right_to_left += 1;\n        if left_to_right\
    \ == right_to_left {\n            collisions += 1;\n        }\n        i += 1;\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplvh9bybg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmapvjbmu.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmapvjbmu.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car ==\
    \ right_car {\n            collisions += 1;\n        } else if left_car > right_car\
    \ {\n            left_to_right.push(left_car);\n        } else {\n           \
    \ right_to_left.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8qhs6jnv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuq5upyn8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![];\n    for i in 0..n {\n       \
    \ cars.push(Car::new(i, true));\n        cars.push(Car::new(i, false));\n    }\n\
    \    let mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n \
    \           if cars[i].collides(&cars[j]) {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp763k45l0.rs:12:19\n\
    \   |\n12 |         cars.push(Car::new(i, true));\n   |                   ^^^\
    \ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Car`\n  --> /tmp/tmp763k45l0.rs:13:19\n   |\n13 |         cars.push(Car::new(i,\
    \ false));\n   |                   ^^^ use of undeclared type `Car`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp763k45l0.rs:18:16\n\
    \   |\n18 |             if cars[i].collides(&cars[j]) {\n   |                ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp763k45l0.rs:18:34\n\
    \   |\n18 |             if cars[i].collides(&cars[j]) {\n   |                \
    \                  ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.pop().unwrap();\n        let\
    \ right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ == right_to_left_car {\n            collisions += 1;\n        } else {\n   \
    \         left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb4ccx135.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j as\
    \ usize] {\n                collisions += 1;\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpiio4ouoe.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] <\
    \ right_to_left[j] {\n            collisions += j;\n            i += 1;\n    \
    \    } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpm8zd3qsp.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpm8zd3qsp.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut left_to_right_index = 0;\n    let mut right_to_left_index\
    \ = 0;\n    let mut collision_count = 0;\n    while left_to_right_index < n &&\
    \ right_to_left_index < n {\n        if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n            left_to_right_index += 1;\n        } else if left_to_right[left_to_right_index]\
    \ > right_to_left[right_to_left_index] {\n            right_to_left_index += 1;\n\
    \        } else {\n            collision_count += 1;\n            left_to_right_index\
    \ += 1;\n            right_to_left_index += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdbs561jk.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpdbs561jk.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpdbs561jk.rs:22:19\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpdbs561jk.rs:22:56\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    let mut\
    \ collisions = 0;\n    while left_to_right.len() > 0 && right_to_left.len() >\
    \ 0 {\n        let left_to_right_car = left_to_right.pop().unwrap();\n       \
    \ let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ == right_to_left_car {\n            collisions += 1;\n        } else {\n   \
    \         left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptloqnjw5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if cars_left[i as usize] < cars_right[j as usize] {\n  \
    \          collisions += j;\n            i += 1;\n        } else {\n         \
    \   j += 1;\n        }\n    }\n    collisions + (n - i) * i\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpo7t_gyg7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvt4tv8fo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2fd13364.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![];\n    let mut cars_right =\
    \ vec![];\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let car_left = cars_left.pop().unwrap();\n        let car_right =\
    \ cars_right.pop().unwrap();\n        if car_left == car_right {\n           \
    \ collisions += 1;\n        } else {\n            cars_left.push(car_left);\n\
    \            cars_right.push(car_right);\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsxszspkj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    let mut collisions = 0;\n    for\
    \ i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy6fpsl1o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The idea is to use a binary search to find the first\
    \ car that collides with\n    // a car that's moving right to left.  The first\
    \ car that collides with a car\n    // that's moving right to left is the car\
    \ that's moving left to right that's\n    // closest to the origin.\n    //\n\
    \    // The binary search is done by using a helper function that returns the\n\
    \    // number of cars that collide with a car that's moving right to left,\n\
    \    // given the position of the car that's moving right to left.\n    //\n \
    \   // The helper function is implemented by using a binary search to find the\n\
    \    // first car that collides with the car that's moving right to left.\n  \
    \  //\n    // The binary search is done by using a helper function that returns\
    \ the\n    // number of cars that collide with a car that's moving right to left,\n\
    \    // given the position of the car that's moving right to left.\n    //\n \
    \   // The helper function is implemented by using a binary search to find the\n\
    \    // first car that collides with the car that's moving right to left.\n  \
    \  //\n    // The binary search is done by using a helper function that returns\
    \ the\n    // number of cars that collide with a car that's moving right to left,\n\
    \    // given the position of the car that's moving right to left.\n    //\n \
    \   // The helper function is implemented by using a binary search to find the\n\
    \    // first car that collides with the car that's moving right to left.\n  \
    \  //\n    // The binary search is done by using a helper function that returns\
    \ the\n    // number of cars that collide with a car that's moving right to left,\n\
    \    // given the position of the car that's moving right to left.\n    //\n \
    \   // The helper function is implemented by using a binary search to find the\n\
    \    // first car that collides with the car that's moving right to left.\n  \
    \  //\n    // The binary search is done by using a helper function that returns\
    \ the\n    // number of cars that collide with a car that's moving right to left,\n\
    \    // given the position of the car that's moving right to left.\n    //\n \
    \   // The helper function is implemented by using a binary search to find the\n\
    \    // first car that collides with the\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkhx1n8a_.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0;\n    let mut left_to_right = 0;\n    let mut right_to_left = n - 1;\n \
    \   while left_to_right < right_to_left {\n        if left_to_right == right_to_left\
    \ {\n            collisions += 1;\n        } else {\n            collisions +=\
    \ 2;\n        }\n        left_to_right += 1;\n        right_to_left -= 1;\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp40kjgmt9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n   \
    \ let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i\
    \ < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n         \
    \   collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk4z7y5ga.rs:23:12\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk4z7y5ga.rs:23:31\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpx8dmx6qs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp_fnf5jcq.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = 0;\n    let mut right_to_left\
    \ = 0;\n    for i in 0..n {\n        left_to_right += i;\n        right_to_left\
    \ += n - i - 1;\n    }\n    left_to_right + right_to_left\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3kwphwfg.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = n - 1;\n    while i < n && j >= 0 {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j + 1;\n            i += 1;\n\
    \        } else {\n            j -= 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmb7ld31t.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmb7ld31t.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions += j *\
    \ (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7udy4n_h.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7udy4n_h.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] <\
    \ right_to_left[j] {\n            collisions += j;\n            i += 1;\n    \
    \    } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfawmz7ev.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfawmz7ev.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq53yt7yd.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq53yt7yd.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4asyzxkt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    left_to_right.sort();\n    right_to_left.sort();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i as usize] < right_to_left[j as usize] {\n         \
    \   collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppo771mr9.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpke1azjp8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while left_to_right.len() > 0 && right_to_left.len()\
    \ > 0 {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpd55lp098.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::with_capacity(n as usize);\n\
    \    let mut cars_right = Vec::with_capacity(n as usize);\n    for i in 0..n {\n\
    \        cars_left.push(i);\n        cars_right.push(n - i - 1);\n    }\n    let\
    \ mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car > right_car {\n            collisions\
    \ += 1;\n        } else {\n            cars_left.push(left_car);\n           \
    \ cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = Vec::new();\n    let mut right_to_left = Vec::new();\n    for i in 0..n {\n\
    \        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() {\n        let\
    \ l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l == r {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp3khhmxzl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpumuy5a68.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpryvkat70.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_car\
    \ = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            collisions += 1;\n        } else\
    \ if left_car > right_car {\n            left_to_right.push(left_car);\n     \
    \   } else {\n            right_to_left.push(right_car);\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpli9yanc1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut cars_rev\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        cars[i as usize] = i;\n\
    \        cars_rev[i as usize] = n - i - 1;\n    }\n    let mut collisions = 0;\n\
    \    for i in 0..n {\n        for j in 0..n {\n            if cars[i as usize]\
    \ > cars_rev[j as usize] {\n                collisions += 1;\n            }\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpu6jn3vku.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::with_capacity(n as usize);\n\
    \    let mut right_to_left = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n\
    \    }\n    let mut collisions = 0;\n    let mut left_to_right_index = 0;\n  \
    \  let mut right_to_left_index = 0;\n    while left_to_right_index < n && right_to_left_index\
    \ < n {\n        if left_to_right[left_to_right_index as usize] < right_to_left[right_to_left_index\
    \ as usize] {\n            left_to_right_index += 1;\n        } else if left_to_right[left_to_right_index\
    \ as usize] > right_to_left[right_to_left_index as usize] {\n            right_to_left_index\
    \ += 1;\n        } else {\n            collisions += 1;\n            left_to_right_index\
    \ += 1;\n            right_to_left_index += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpjmkp_pg1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if cars_left[i as usize] < cars_right[j as usize] {\n  \
    \          collisions += j;\n            i += 1;\n        } else {\n         \
    \   j += 1;\n        }\n    }\n    collisions += (n - i) * (n - i - 1) / 2;\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmploihg3_7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_car\
    \ = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            collisions += 1;\n        } else\
    \ if left_car > right_car {\n            left_to_right.push(left_car);\n     \
    \   } else {\n            right_to_left.push(right_car);\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvy0j3z6l.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if cars_left[i as usize] < cars_right[j as usize] {\n  \
    \          collisions += j;\n            i += 1;\n        } else {\n         \
    \   j += 1;\n        }\n    }\n    collisions += (n - i) * (j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpckls13lh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car == right_car {\n           \
    \ collisions += 1;\n        } else {\n            cars_left.push(left_car);\n\
    \            cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0prnzsjn.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    let mut collisions = 0;\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    left_to_right.sort();\n    right_to_left.sort();\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            collisions += j;\n    \
    \        i += 1;\n        } else {\n            j += 1;\n        }\n    }\n  \
    \  collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpbtg13133.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvr9n11va.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::with_capacity(n as usize);\n\
    \    let mut cars_right = Vec::with_capacity(n as usize);\n    for i in 0..n {\n\
    \        cars_left.push(i);\n        cars_right.push(n - i - 1);\n    }\n    let\
    \ mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car > right_car {\n            collisions\
    \ += 1;\n        } else {\n            cars_left.push(left_car);\n           \
    \ cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    let mut collisions = 0;\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    left_to_right.sort();\n    right_to_left.sort();\n   \
    \ let mut left_to_right_index = 0;\n    let mut right_to_left_index = 0;\n   \
    \ while left_to_right_index < n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else if left_to_right[left_to_right_index] > right_to_left[right_to_left_index]\
    \ {\n            right_to_left_index += 1;\n        } else {\n            collisions\
    \ += 1;\n            left_to_right_index += 1;\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiyzh6l64.rs:22:12\n\
    \   |\n22 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiyzh6l64.rs:22:49\n   |\n22 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiyzh6l64.rs:24:19\n   |\n24 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiyzh6l64.rs:24:56\n   |\n24 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpp_bmuzxc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut left_to_right_index\
    \ = 0;\n    let mut right_to_left_index = 0;\n    while left_to_right_index <\
    \ n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else if left_to_right[left_to_right_index] > right_to_left[right_to_left_index]\
    \ {\n            right_to_left_index += 1;\n        } else {\n            collisions\
    \ += 1;\n            left_to_right_index += 1;\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjoluae55.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjoluae55.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjoluae55.rs:22:19\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjoluae55.rs:22:56\n   |\n22 |         } else\
    \ if left_to_right[left_to_right_index] > right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<isize> = Vec::new();\n    let mut right_to_left: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collision_count = 0;\n    let mut left_index =\
    \ 0;\n    let mut right_index = 0;\n    while left_index < n && right_index <\
    \ n {\n        if left_to_right[left_index] < right_to_left[right_index] {\n \
    \           collision_count += right_index;\n            left_index += 1;\n  \
    \      } else {\n            right_index += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxo1yuxb1.rs:23:12\n\
    \   |\n23 |         if left_to_right[left_index] < right_to_left[right_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxo1yuxb1.rs:23:40\n   |\n23 |         if left_to_right[left_index]\
    \ < right_to_left[right_index] {\n   |                                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while left_to_right.len()\
    \ > 0 {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe4s2u7hy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl5_f9288.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_to_right_car\
    \ = left_to_right.pop().unwrap();\n        let right_to_left_car = right_to_left.pop().unwrap();\n\
    \        if left_to_right_car > right_to_left_car {\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvw903ul9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ left_to_right.len() > 0 && right_to_left.len() > 0 {\n        let left_car =\
    \ left_to_right[0];\n        let right_car = right_to_left[0];\n        if left_car\
    \ < right_car {\n            left_to_right.remove(0);\n        } else if left_car\
    \ > right_car {\n            right_to_left.remove(0);\n        } else {\n    \
    \        collisions += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpwxo93_og.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n {\n        left_to_right\
    \ += 1;\n        if right_to_left > 0 {\n            right_to_left -= 1;\n   \
    \         collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpspod3m72.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            count += 1;\n        }\
    \ else {\n            right_to_left.remove(0);\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuufcj8h_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    left_to_right.sort();\n    right_to_left.sort();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i as usize] < right_to_left[j as usize] {\n         \
    \   collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += j * (n - i);\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpj_c6si8u.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6z0n7yqx.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6z0n7yqx.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpkht703se.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \            collisions += 1;\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmqh2zpiz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            count += 1;\n        }\
    \ else {\n            right_to_left.remove(0);\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpne8upwod.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        if left_to_right[0]\
    \ == right_to_left[0] {\n            collisions += 1;\n            left_to_right.remove(0);\n\
    \            right_to_left.remove(0);\n        } else if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxmfzor06.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut collisions = 0;\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            collisions += j;\n    \
    \        i += 1;\n        } else {\n            j += 1;\n        }\n    }\n  \
    \  collisions += (n - i) * j;\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4mgcgmt2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        if left_to_right[0]\
    \ < right_to_left[0] {\n            left_to_right.remove(0);\n            collisions\
    \ += 1;\n        } else {\n            right_to_left.remove(0);\n        }\n \
    \   }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp5ib5dpxf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n   \
    \ let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.pop().unwrap();\n        let\
    \ right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * i;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2oh_ubqu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Write your code here\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnkzk1rid.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while left_to_right.len() > 0 && right_to_left.len() >\
    \ 0 {\n        let left_car = left_to_right[0];\n        let right_car = right_to_left[0];\n\
    \        if left_car == right_car {\n            collisions += 1;\n          \
    \  left_to_right.remove(0);\n            right_to_left.remove(0);\n        } else\
    \ if left_car < right_car {\n            left_to_right.remove(0);\n        } else\
    \ {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmplbplwa05.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut count = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] == right_to_left[0] {\n            count += 1;\n\
    \            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \        } else {\n            right_to_left.remove(0);\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpapocmtoy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![];\n    let mut cars_right =\
    \ vec![];\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        if cars_left[0] == cars_right[0] {\n            collisions += 1;\n\
    \            cars_left.remove(0);\n            cars_right.remove(0);\n       \
    \ } else if cars_left[0] < cars_right[0] {\n            cars_left.remove(0);\n\
    \        } else {\n            cars_right.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgyxu54zr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7s2qd5az.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while left_to_right.len()\
    \ > 0 {\n        let mut i = 0;\n        while i < left_to_right.len() {\n   \
    \         if left_to_right[i] == right_to_left[i] {\n                collisions\
    \ += 1;\n                left_to_right.remove(i);\n                right_to_left.remove(i);\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     for i in 0..left_to_right.len() {\n            left_to_right[i] += 1;\n\
    \            right_to_left[i] -= 1;\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut left_to_right = vec![0; n as usize];\n    let mut right_to_left\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i as usize]\
    \ = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            count += j;\n         \
    \   i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpgtf9lvq8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left > right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmptt043sjb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i] < right_to_left[j] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpivmtvz38.rs:19:12\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpivmtvz38.rs:19:31\n\
    \   |\n19 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwnc38sqi.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp91conr1i.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp91conr1i.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpv8zqolmj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = -i;\n    }\n    let mut\
    \ collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ left_to_right[i as usize] == right_to_left[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprk56bbeo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![];\n    let mut cars_right =\
    \ vec![];\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !cars_left.is_empty()\
    \ && !cars_right.is_empty() {\n        if cars_left[0] < cars_right[0] {\n   \
    \         collisions += 1;\n            cars_left.remove(0);\n            cars_right.remove(0);\n\
    \        } else {\n            cars_left.remove(0);\n            cars_right.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4g4tx5is.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqcob7gxu.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqcob7gxu.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpdwcjrwln.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpinal0rj8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = Vec::new();\n    let mut right_to_left = Vec::new();\n    for i in 0..n {\n\
    \        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n\
    \    let mut collision_count = 0;\n    while !left_to_right.is_empty() {\n   \
    \     let left_car = left_to_right.remove(0);\n        let right_car = right_to_left.remove(0);\n\
    \        if left_car == right_car {\n            collision_count += 1;\n     \
    \   }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp36_u0py3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl89f4nio.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl89f4nio.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp62hbc8ay.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcdn31tl8.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcdn31tl8.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpx2cplngz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if left_to_right[i as usize] == right_to_left[j as usize] {\n      \
    \          collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpobwbwkus.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut count = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            count += j;\n            i += 1;\n        } else {\n        \
    \    j += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3ohlid0h.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3ohlid0h.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpgzdzpl7e.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut cars_left\
    \ = vec![0; n as usize];\n    let mut cars_right = vec![0; n as usize];\n    for\
    \ i in 0..n {\n        cars_left[i as usize] = i;\n        cars_right[i as usize]\
    \ = n - i - 1;\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < n && j < n {\n        if cars_left[i as usize] < cars_right[j\
    \ as usize] {\n            collisions += j;\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    collisions += (n - i) * (j as\
    \ isize);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn81m2v_9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpbrpknvg_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] <\
    \ right_to_left[j] {\n            collisions += j;\n            i += 1;\n    \
    \    } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphvczjebr.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphvczjebr.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt97l53jm.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt97l53jm.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp2tdd7o51.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] <\
    \ right_to_left[j] {\n            collisions += j;\n            i += 1;\n    \
    \    } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq3_4i3qx.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq3_4i3qx.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpp2bcq7q2.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpykwfanni.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
