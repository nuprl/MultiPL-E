name: HumanEval_37_sort_even
language: rust
results:
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = Vec::new();\n    let mut even_list = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            new_list.push(*x);\n        } else {\n\
    \            even_list.push(*x);\n        }\n    }\n    even_list.sort();\n  \
    \  for (i, x) in even_list.iter().enumerate() {\n        new_list.insert(i * 2\
    \ + 1, *x);\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5oskns59.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    let mut even_list = Vec::new();\n    let mut odd_list = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_list.push(*x);\n        } else {\n            odd_list.push(*x);\n  \
    \      }\n    }\n    even_list.sort();\n    for (i, x) in even_list.iter().enumerate()\
    \ {\n        new_list[i * 2] = *x;\n    }\n    new_list\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for i in 0..even_indicies.len() {\n        l[i *\
    \ 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len() {\n      \
    \  l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i;\n            while j < l.len() {\n                if j %\
    \ 2 == 0 {\n                    if l[j] < l[i] {\n                        let\
    \ temp = l[i];\n                        l[i] = l[j];\n                       \
    \ l[j] = temp;\n                    }\n                }\n                j +=\
    \ 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    let mut odd_indicies:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indicies.push(l[i]);\n        } else {\n            odd_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..even_indicies.len()\
    \ {\n        l[i * 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len()\
    \ {\n        l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let\
    \ mut even_values = Vec::new();\n    for i in even_indicies {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for i in 0..even_values.len() {\n       \
    \ l[even_indicies[i]] = even_values[i];\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpx_8yz4bl.rs:22:11\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indicies[i]] = even_values[i];\n    |           ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i - 1];\n        }\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpf_g1deci.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for (i,\
    \ v) in even_values.iter().enumerate() {\n        l[even_indicies[i]] = *v;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpwn5l45fx.rs:22:11\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indicies[i]] = *v;\n    |           ^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1pa4nz_g.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j < l.len() {\n                if l[j] < l[i] {\n                   \
    \ let temp = l[i];\n                    l[i] = l[j];\n                    l[j]\
    \ = temp;\n                }\n                j += 1;\n            }\n       \
    \ }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, 3, -5, 2, -3, 9, 0, 123, 1, 3]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_j07cq1m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     while j < l.len() {\n            if l[i] > l[j] {\n                let temp\
    \ = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n      \
    \      }\n            j += 1;\n        }\n        i += 2;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7m1kqv2w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpea3tqf0r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     while j < l.len() {\n            if l[i] > l[j] {\n                let temp\
    \ = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n      \
    \      }\n            j += 1;\n        }\n        i += 2;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp47qbpt6f.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = sort_even_helper(l[i]);\n\
    \        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmpsmnmwl5m.rs:15:20\n   |\n15 |             l[i] = sort_even_helper(l[i]);\n\
    \   |                    ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    let mut odd_indices:\
    \ Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n       \
    \ if i % 2 == 0 {\n            even_indices.push(*x);\n        } else {\n    \
    \        odd_indices.push(*x);\n        }\n    }\n    even_indices.sort();\n \
    \   for (i, x) in even_indices.iter().enumerate() {\n        l[i * 2] = *x;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 1;\n    while i < l.len() {\n        let mut j = i;\n       \
    \ while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1, j);\n          \
    \  j -= 1;\n        }\n        i += 2;\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvk63d02s.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indices.push(i);\n        }\n    }\n    for i\
    \ in 0..even_indices.len() {\n        let mut min_index = i;\n        for j in\
    \ i..even_indices.len() {\n            if l[even_indices[j]] < l[even_indices[min_index]]\
    \ {\n                min_index = j;\n            }\n        }\n        l.swap(even_indices[i],\
    \ even_indices[min_index]);\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        let mut even_values = Vec::new();\n\
    \        for j in even_indicies {\n            even_values.push(l[j]);\n     \
    \   }\n        even_values.sort();\n        l_prime[i] = even_values[0];\n   \
    \     even_values.remove(0);\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `even_indicies`\n   --> /tmp/tmps9x9wzx4.rs:18:18\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    17  |         let mut even_values = Vec::new();\n18  |         for j in even_indicies\
    \ {\n    |                  ^^^^^^^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = vec![];\n    for i in 0..l.len() {\n        if i\
    \ % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for i\
    \ in 0..even_indicies.len() {\n        for j in i..even_indicies.len() {\n   \
    \         if l[even_indicies[i]] > l[even_indicies[j]] {\n                let\
    \ temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for (index, value) in l.iter().enumerate() {\n        if\
    \ index % 2 == 0 {\n            even_indicies.push(*value);\n        } else {\n\
    \            odd_indicies.push(*value);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (index, value) in even_indicies.iter().enumerate() {\n        l_prime[index\
    \ * 2] = *value;\n    }\n    for (index, value) in odd_indicies.iter().enumerate()\
    \ {\n        l_prime[index * 2 + 1] = *value;\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    let mut odd_indicies:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indicies.push(l[i]);\n        } else {\n            odd_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..even_indicies.len()\
    \ {\n        l[2 * i] = even_indicies[i];\n    }\n    l\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i];\n            let\
    \ mut j = i;\n            while j > 0 && l[j - 1] > l[j] {\n                let\
    \ temp = l[j];\n                l[j] = l[j - 1];\n                l[j - 1] = temp;\n\
    \                j -= 1;\n            }\n        }\n        i += 1;\n    }\n \
    \   l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7ydqj7d2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_vals: Vec<isize> = Vec::new();\n    for i in even_indicies\
    \ {\n        even_vals.push(l[i]);\n    }\n    even_vals.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l[even_indicies[i]] = even_vals[i];\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp76qjxkbv.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let tmp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = tmp;\n                }\n              \
    \  j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpjm694qv4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpm193pphu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i - 1];\n        }\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpys5u481l.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in 0..even_indicies.len() {\n        let mut min_index = i;\n        for j\
    \ in i+1..even_indicies.len() {\n            if l[even_indicies[j]] < l[even_indicies[min_index]]\
    \ {\n                min_index = j;\n            }\n        }\n        l.swap(even_indicies[i],\
    \ even_indicies[min_index]);\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp00ys8aw5.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1egbmm32.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = vec![];\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n\
    \    for i in even_indicies {\n        let mut temp = l[i];\n        for j in\
    \ i..l.len() {\n            if l[j] < temp {\n                temp = l[j];\n \
    \               l_prime[j] = l[i];\n                l_prime[i] = temp;\n     \
    \       }\n        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -10, 2, -10, 3, -10, 9, -10, 123, 123]`,\n right: `[-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123]`', /tmp/tmp0sy1d264.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpsp3trkth.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i] + 1;\n        }\n        i = i + 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 4]`,\n right: `[1, 2, 3]`', /tmp/tmpqsqyqx_h.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpwho53drk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    even_indicies.sort_by(|a,\
    \ b| l[*a].cmp(&l[*b]));\n    for i in 0..even_indicies.len() {\n        l.swap(i\
    \ * 2, even_indicies[i]);\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 3, -5, 2, -3, 3, 123, 0, 5, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmphmxgpb2i.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even = Vec::new();\n\
    \    let mut odd = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n   \
    \     if i % 2 == 0 {\n            odd.push(*x);\n        } else {\n         \
    \   even.push(*x);\n        }\n    }\n    even.sort();\n    let mut res = Vec::new();\n\
    \    for (i, x) in odd.iter().enumerate() {\n        res.push(*x);\n        if\
    \ i < even.len() {\n            res.push(even[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmps80nt0ej.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i] + 1;\n        }\n        i = i + 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 4]`,\n right: `[1, 2, 3]`', /tmp/tmpsrx4krj2.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpangjw51w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3c2oa4eu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpqen1ns3q.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, v) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*v);\n        } else {\n\
    \            l_odd.push(*v);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for (i, v) in l_even.iter().enumerate() {\n       \
    \ l_new.push(*v);\n        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpfevx1rw9.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<usize> = Vec::new();\n    let mut odd_indicies:\
    \ Vec<usize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indicies.push(i);\n        } else {\n            odd_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    return l;\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp5nngf8nr.rs:24:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n24  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n20  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        l[i] = sort_even_helper(l[i]);\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmpf0i7ynag.rs:17:16\n   |\n17 |         l[i] = sort_even_helper(l[i]);\n\
    \   |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        l[i] = sort_even_helper(l[i]);\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmpsaxcli4z.rs:17:16\n   |\n17 |         l[i] = sort_even_helper(l[i]);\n\
    \   |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[i * 2 + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcos6519h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n       \
    \ l_new.push(*x);\n        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmppij83edp.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp6028dmh3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = vec![];\n    for i in 0..l.len() {\n        if i\
    \ % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let mut\
    \ even_values = vec![];\n    for i in even_indicies {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for i in 0..even_indicies.len() {\n     \
    \   l[even_indicies[i]] = even_values[i];\n    }\n    l\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpmjifsqxp.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = vec![];\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let\
    \ mut even_indicies_values = Vec::new();\n    for i in even_indicies {\n     \
    \   even_indicies_values.push(l[i]);\n    }\n    even_indicies_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_indicies_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp0rc6_xv2.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    let mut odd_indices:\
    \ Vec<isize> = Vec::new();\n    for (i, v) in l.iter().enumerate() {\n       \
    \ if i % 2 == 0 {\n            even_indices.push(*v);\n        } else {\n    \
    \        odd_indices.push(*v);\n        }\n    }\n    even_indices.sort();\n \
    \   for (i, v) in even_indices.iter().enumerate() {\n        l[i * 2] = *v;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     while j < l.len() {\n            if l[i] > l[j] {\n                let temp\
    \ = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n      \
    \      }\n            j += 1;\n        }\n        i += 2;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcbay48zy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp4sz52et7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        let mut even_values = Vec::new();\n\
    \        for j in even_indicies {\n            even_values.push(l[j]);\n     \
    \   }\n        even_values.sort();\n        for (j, k) in even_indicies.iter().enumerate()\
    \ {\n            l_prime[*k] = even_values[j];\n        }\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpdhuaqo8v.rs:16:9\n   |\n16\
    \ |     for i in even_indicies {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `even_indicies`\n   --> /tmp/tmpdhuaqo8v.rs:18:18\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    17  |         let mut even_values = Vec::new();\n18  |         for j in even_indicies\
    \ {\n    |                  ^^^^^^^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror[E0382]: borrow of moved value: `even_indicies`\n  --> /tmp/tmpdhuaqo8v.rs:22:23\n\
    \   |\n10 |     let mut even_indicies = Vec::new();\n   |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n18 |         for j in even_indicies {\n   |         \
    \         ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         for (j, k) in even_indicies.iter().enumerate() {\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   |\n\
    \   = note: borrow occurs due to deref coercion to `[usize]`\nhelp: consider iterating\
    \ over a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \   |\n18 |         for j in &even_indicies {\n   |                  +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmptmfco99_.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7wqc_6a7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n       \
    \ l_new.push(*x);\n        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp1jxhns_k.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, v) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*v);\n        } else {\n\
    \            l_odd.push(*v);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_ret = Vec::new();\n    for (i, v) in l_even.iter().enumerate() {\n       \
    \ l_ret.push(*v);\n        l_ret.push(l_odd[i]);\n    }\n    l_ret\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpnpdo2b54.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut i = 0;\n    while i < v.len() {\n        if i % 2 == 0 {\n      \
    \      i += 1;\n            continue;\n        }\n        let mut j = i;\n   \
    \     while j > 0 && v[j - 1] > v[j] {\n            v.swap(j - 1, j);\n      \
    \      j -= 1;\n        }\n        i += 1;\n    }\n    v\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9bjj2ssy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i] + 1;\n        }\n        i = i + 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 4]`,\n right: `[1, 2, 3]`', /tmp/tmp_jyye2k0.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        let mut sublist = Vec::new();\n        for j in\
    \ i..l.len() {\n            if j % 2 == 0 {\n                sublist.push(l[j]);\n\
    \            }\n        }\n        sublist.sort();\n        for j in i..l.len()\
    \ {\n            if j % 2 == 0 {\n                l[j] = sublist[j - i];\n   \
    \         }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 2 but the index\
    \ is 2', /tmp/tmpkeuukgdz.rs:26:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    let mut even_indicies = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            result.push(*x);\n        } else {\n\
    \            even_indicies.push(*x);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (i, x) in even_indicies.iter().enumerate() {\n        result.insert(i\
    \ * 2 + 1, *x);\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_c6hkqvu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l.sort();\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpyrkk9uj4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for i in 0..even_indicies.len() {\n        l[i *\
    \ 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len() {\n      \
    \  l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     while j < l.len() {\n            if l[i] > l[j] {\n                let temp\
    \ = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n      \
    \      }\n            j += 1;\n        }\n        i += 2;\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp2893gqkp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcxqv6_59.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    for i in even_indicies {\n        let mut even_values:\
    \ Vec<isize> = Vec::new();\n        for j in even_indicies {\n            even_values.push(l[j]);\n\
    \        }\n        even_values.sort();\n        for j in even_indicies {\n  \
    \          l_prime[j] = even_values[j];\n        }\n    }\n    l_prime\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmp27vuy6jq.rs:16:9\n   |\n16\
    \ |     for i in even_indicies {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `even_indicies`\n   --> /tmp/tmp27vuy6jq.rs:18:18\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n16  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n17  |         let mut even_values: Vec<isize> = Vec::new();\n\
    18  |         for j in even_indicies {\n    |                  ^^^^^^^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `even_indicies`\nhelp: consider iterating over a slice of\
    \ the `Vec<usize>`'s content to avoid moving into the `for` loop\n    |\n16  |\
    \     for i in &even_indicies {\n    |              +\n\nerror[E0382]: use of\
    \ moved value: `even_indicies`\n  --> /tmp/tmp27vuy6jq.rs:22:18\n   |\n10 |  \
    \   let mut even_indicies: Vec<usize> = Vec::new();\n   |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n18 |         for j in even_indicies {\n   |         \
    \         ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         for j in even_indicies {\n   |                  ^^^^^^^^^^^^^\
    \ value used here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<usize>`'s content to avoid moving into the `for` loop\n   |\n18 |     \
    \    for j in &even_indicies {\n   |                  +\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(i as isize);\n   \
    \     }\n    }\n    let mut even_indices_sorted = even_indices.clone();\n    even_indices_sorted.sort();\n\
    \    for (i, index) in even_indices.iter().enumerate() {\n        l[*index as\
    \ usize] = l[even_indices_sorted[i] as usize];\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpq2ul9eso.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i + 1];\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpl5mui368.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i as isize);\n  \
    \      }\n    }\n    for i in even_indicies {\n        let mut even_slice = l.split_off(i\
    \ as usize);\n        even_slice.sort();\n        l.append(&mut even_slice);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp0772kcrh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpg8gteve4.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut evens = Vec::new();\n    for (i, e) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            evens.push(*e);\n        }\n    }\n\
    \    evens.sort();\n    for (i, e) in evens.iter().enumerate() {\n        l_prime[i\
    \ * 2] = *e;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[2 * i + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp38ysgi4v.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut odds: Vec<isize> = Vec::new();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n       \
    \ if i % 2 == 0 {\n            odds.push(*x);\n        } else {\n            evens.push(*x);\n\
    \        }\n    }\n    evens.sort();\n    for (i, x) in l.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            result.push(*x);\n        } else {\n   \
    \         result.push(evens.pop().unwrap());\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 3, -3, 2, 9, 1, 123, 0, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpb072cn2f.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i - 1];\n        }\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpdhgc47f0.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let\
    \ mut even_values = Vec::new();\n    for i in even_indicies {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for i in 0..even_values.len() {\n       \
    \ l[even_indicies[i]] = even_values[i];\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmppccig79q.rs:22:11\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indicies[i]] = even_values[i];\n    |           ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut i = 0;\n    while i < v.len() {\n        if i % 2 == 0 {\n      \
    \      v[i] = v[i + 1];\n        }\n        i += 1;\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmp18j22qsa.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[i * 2 + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpal95nodz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpb_69e62w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ num) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*num);\n\
    \        } else {\n            evens.push(*num);\n        }\n    }\n    evens.sort();\n\
    \    for (i, num) in evens.iter().enumerate() {\n        l[i * 2 + 1] = *num;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp2s_6c6k1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        l[i] = sort_even_helper(l[i]);\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmpl39cmd4x.rs:17:16\n   |\n17 |         l[i] = sort_even_helper(l[i]);\n\
    \   |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpync6dzzb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = evens[i\
    \ / 2];\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp5erk63g2.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_even_odd = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n  \
    \      l_even_odd.push(*x);\n        l_even_odd.push(l_odd[i]);\n    }\n    l_even_odd\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpe29b529v.rs:22:25\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut i = 0;\n    while i < v.len() {\n        if i % 2 == 0 {\n      \
    \      v[i] = l[i];\n        } else {\n            let mut temp = l[i];\n    \
    \        let mut j = i;\n            while j > 0 && temp < v[j - 1] {\n      \
    \          v[j] = v[j - 1];\n                j -= 1;\n            }\n        \
    \    v[j] = temp;\n        }\n        i += 1;\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1h0lc2p3.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_nums: Vec<isize> = Vec::new();\n    let mut odd_nums: Vec<isize>\
    \ = Vec::new();\n    for (i, num) in l.iter().enumerate() {\n        if i % 2\
    \ == 0 {\n            odd_nums.push(*num);\n        } else {\n            even_nums.push(*num);\n\
    \        }\n    }\n    even_nums.sort();\n    for (i, num) in even_nums.iter().enumerate()\
    \ {\n        l[i * 2 + 1] = *num;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpoc62f5a1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_x9z03so.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        let mut temp = l[i];\n        let mut j = i;\n\
    \        while j > 0 && l[j - 1] > temp {\n            l[j] = l[j - 1];\n    \
    \        j -= 1;\n        }\n        l[j] = temp;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 5, 3, 2, 3, 9, 0, 123, 1]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp72jappeg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = evens[i\
    \ / 2];\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        let mut even_sublist = Vec::new();\n        for\
    \ j in i..l.len() {\n            if j % 2 == 0 {\n                even_sublist.push(l[j]);\n\
    \            }\n        }\n        even_sublist.sort();\n        for j in i..l.len()\
    \ {\n            if j % 2 == 0 {\n                l[j] = even_sublist.remove(0);\n\
    \            }\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        let mut temp = l[i];\n        for j in i..l.len()\
    \ {\n            if l[j] < temp {\n                l[i] = l[j];\n            \
    \    l[j] = temp;\n                temp = l[i];\n            }\n        }\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp4qtowaw_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpmixydp2z.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_indicies\
    \ = Vec::new();\n    let mut odd_indicies = Vec::new();\n    let mut result =\
    \ Vec::new();\n    for (index, item) in l.iter().enumerate() {\n        if index\
    \ % 2 == 0 {\n            even_indicies.push(*item);\n        } else {\n     \
    \       odd_indicies.push(*item);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (index, item) in l.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            result.push(even_indicies.remove(0));\n        } else {\n       \
    \     result.push(*item);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    let mut odd_indicies:\
    \ Vec<isize> = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n       \
    \ if i % 2 == 0 {\n            even_indicies.push(*x);\n        } else {\n   \
    \         odd_indicies.push(*x);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (i, x) in even_indicies.iter().enumerate() {\n        l[i * 2] = *x;\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[2 * i + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7sy698hk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even: Vec<isize>\
    \ = Vec::new();\n    let mut l_odd: Vec<isize> = Vec::new();\n    let mut l_even_sorted:\
    \ Vec<isize> = Vec::new();\n    let mut l_sorted: Vec<isize> = Vec::new();\n \
    \   let mut i: usize = 0;\n    for x in l {\n        if i % 2 == 0 {\n       \
    \     l_even.push(x);\n        } else {\n            l_odd.push(x);\n        }\n\
    \        i += 1;\n    }\n    l_even_sorted = l_even.clone();\n    l_even_sorted.sort();\n\
    \    i = 0;\n    for x in l_even_sorted {\n        l_sorted.push(x);\n       \
    \ l_sorted.push(l_odd[i]);\n        i += 1;\n    }\n    l_sorted\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpkrfmtzxn.rs:27:23\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   odds.push(*x);\n        } else {\n            evens.push(*x);\n        }\n\
    \    }\n    evens.sort();\n    for (i, x) in evens.iter().enumerate() {\n    \
    \    l_prime[2 * i + 1] = *x;\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpe188z1i2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l_prime[i] = even_indicies[i / 2];\n       \
    \ }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp31cphqmt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = evens[i/2];\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len() - 1 {\n\
    \            if l[even_indicies[j]] > l[even_indicies[j + 1]] {\n            \
    \    l.swap(even_indicies[j], even_indicies[j + 1]);\n            }\n        }\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for i in 0..l.len() {\n  \
    \      if i % 2 == 0 {\n            l_even.push(l[i]);\n        } else {\n   \
    \         l_odd.push(l[i]);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for i in 0..l_even.len() {\n        l_new.push(l_even[i]);\n\
    \        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpzty7lz6b.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = Vec::new();\n\
    \    let mut odds = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            odds.push(*x);\n        } else {\n       \
    \     evens.push(*x);\n        }\n    }\n    evens.sort();\n    let mut result\
    \ = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n        if i % 2 ==\
    \ 0 {\n            result.push(*x);\n        } else {\n            result.push(evens.pop().unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 3, -3, 2, 9, 1, 123, 0, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpzgrf53j1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut l_even = Vec::new();\n    let mut l_odd = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            l_even.push(*x);\n\
    \        } else {\n            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n\
    \    for (i, x) in l_even.iter().enumerate() {\n        l[i * 2] = *x;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    let mut odd_indices:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indices.push(l[i]);\n        } else {\n            odd_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..even_indices.len()\
    \ {\n        l[2 * i] = even_indices[i];\n    }\n    l\n}\n\nfn main() {\n   \
    \ let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        let mut j = i + 1;\n        while j < l.len()\
    \ {\n            if l[j] < l[i] {\n                let temp = l[i];\n        \
    \        l[i] = l[j];\n                l[j] = temp;\n            }\n         \
    \   j += 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbilre4rw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for i in 0..even_indicies.len() {\n        l[i *\
    \ 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len() {\n      \
    \  l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    let mut\
    \ i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n            odds.push(l[i]);\n\
    \        } else {\n            evens.push(l[i]);\n        }\n        i += 1;\n\
    \    }\n    evens.sort();\n    i = 0;\n    while i < l.len() {\n        if i %\
    \ 2 == 0 {\n            l[i] = odds[i / 2];\n        } else {\n            l[i]\
    \ = evens[i / 2];\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1j6hg3ou.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpin93atsj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmprspqiq_5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_sorted = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n    \
    \    l_sorted.push(*x);\n        l_sorted.push(l_odd[i]);\n    }\n    l_sorted\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpa1c0y45k.rs:22:23\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l.insert(i, l.remove(i + 1));\n            i += 2;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0499]: cannot borrow `l` as mutable more than once at a time\n \
    \ --> /tmp/tmphmq4gcu5.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |             ------------^^^^^^^^^^^^^^^-\n   |             | |\
    \         |\n   |             | |         second mutable borrow occurs here\n\
    \   |             | first borrow later used by call\n   |             first mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmphmq4gcu5.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |                         ^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmphmq4gcu5.rs:13:13\n \
    \  |\n13 |             l.insert(i, l.remove(i + 1));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7h_c57kd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 1;\n    while i < l.len() {\n        let mut j = i;\n       \
    \ while j > 0 && l[j - 1] > l[j] {\n            l.swap(j - 1, j);\n          \
    \  j -= 1;\n        }\n        i += 2;\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvw066woq.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_copy =\
    \ l.clone();\n    let mut even_indicies: Vec<isize> = Vec::new();\n    let mut\
    \ odd_indicies: Vec<isize> = Vec::new();\n    for (index, value) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            even_indicies.push(*value);\n  \
    \      } else {\n            odd_indicies.push(*value);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for (index, value) in even_indicies.iter().enumerate()\
    \ {\n        l_copy[index * 2] = *value;\n    }\n    l_copy\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i - 1];\n        }\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp_1kcol_v.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5qn8nnlu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            let mut j = i;\n          \
    \  while j > 0 {\n                if l[j] < l[j - 1] {\n                    let\
    \ temp = l[j];\n                    l[j] = l[j - 1];\n                    l[j\
    \ - 1] = temp;\n                }\n                j -= 1;\n            }\n  \
    \      }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 3, 5, 2, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpx8878gag.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    let mut odd_indices:\
    \ Vec<isize> = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n    \
    \    if i % 2 == 0 {\n            even_indices.push(l[i]);\n        } else {\n\
    \            odd_indices.push(l[i]);\n        }\n        i += 1;\n    }\n    even_indices.sort();\n\
    \    let mut i = 0;\n    while i < even_indices.len() {\n        l[i * 2] = even_indices[i];\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    let mut even_indicies = Vec::new();\n    for (i, v) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            result.push(*v);\n        } else {\n\
    \            even_indicies.push(*v);\n        }\n    }\n    even_indicies.sort();\n\
    \    for (i, v) in even_indicies.iter().enumerate() {\n        result.insert(i\
    \ * 2 + 1, *v);\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1axvlb58.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp7941i8fo.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    let mut even_list = Vec::new();\n    let mut odd_list = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_list.push(*x);\n        } else {\n            odd_list.push(*x);\n  \
    \      }\n    }\n    even_list.sort();\n    for (i, x) in even_list.iter().enumerate()\
    \ {\n        new_list[i * 2] = *x;\n    }\n    new_list\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len() - 1 {\n\
    \            if l[even_indicies[j]] > l[even_indicies[j + 1]] {\n            \
    \    let temp = l[even_indicies[j]];\n                l[even_indicies[j]] = l[even_indicies[j\
    \ + 1]];\n                l[even_indicies[j + 1]] = temp;\n            }\n   \
    \     }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in 0..even_indicies.len() {\n        for j in 0..even_indicies.len()\
    \ {\n            if l[even_indicies[i]] < l[even_indicies[j]] {\n            \
    \    let temp = l[even_indicies[i]];\n                l[even_indicies[i]] = l[even_indicies[j]];\n\
    \                l[even_indicies[j]] = temp;\n            }\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpjs_6ps3_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9cb9kzn_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        let mut even_values = Vec::new();\n\
    \        for j in even_indicies {\n            even_values.push(l[j]);\n     \
    \   }\n        even_values.sort();\n        for j in even_indicies {\n       \
    \     l_prime[j] = even_values[j];\n        }\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpaa0kt2s7.rs:16:9\n   |\n16\
    \ |     for i in even_indicies {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `even_indicies`\n   --> /tmp/tmpaa0kt2s7.rs:18:18\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    17  |         let mut even_values = Vec::new();\n18  |         for j in even_indicies\
    \ {\n    |                  ^^^^^^^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror[E0382]: use of moved value: `even_indicies`\n  --> /tmp/tmpaa0kt2s7.rs:22:18\n\
    \   |\n10 |     let mut even_indicies = Vec::new();\n   |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n18 |         for j in even_indicies {\n   |         \
    \         ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         for j in even_indicies {\n   |                  ^^^^^^^^^^^^^\
    \ value used here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<usize>`'s content to avoid moving into the `for` loop\n   |\n18 |     \
    \    for j in &even_indicies {\n   |                  +\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpfsr6h75n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplrr7ecc8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    let mut\
    \ result = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n \
    \           odds.push(l[i]);\n        } else {\n            evens.push(l[i]);\n\
    \        }\n    }\n    evens.sort();\n    for i in 0..l.len() {\n        if i\
    \ % 2 == 0 {\n            result.push(odds[i / 2]);\n        } else {\n      \
    \      result.push(evens[i / 2]);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp0l4q1uge.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = l[i - 1];\n        }\n\
    \        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp3xqc5r_5.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_indicies:\
    \ Vec<isize> = Vec::new();\n    let mut odd_indicies: Vec<isize> = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indicies.push(*x);\n        } else {\n            odd_indicies.push(*x);\n\
    \        }\n    }\n    even_indicies.sort();\n    let mut result: Vec<isize> =\
    \ Vec::new();\n    for (i, x) in even_indicies.iter().enumerate() {\n        result.push(*x);\n\
    \        result.push(odd_indicies[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp1ptb_ss3.rs:22:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[i * 2 + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcwia3hed.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp356gmyel.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = l.clone();\n\
    \    let mut even_l = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            even_l.push(l[i]);\n        }\n    }\n    even_l.sort();\n\
    \    for i in 0..even_l.len() {\n        new_l[i * 2] = even_l[i];\n    }\n  \
    \  new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp9gv1i81b.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for i in 0..l.len() {\n  \
    \      if i % 2 == 0 {\n            l_even.push(l[i]);\n        } else {\n   \
    \         l_odd.push(l[i]);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for i in 0..l_even.len() {\n        l_new.push(l_even[i]);\n\
    \        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpr44p6yi3.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    let mut sorted_even_indicies = Vec::new();\n    let mut sorted_l = Vec::new();\n\
    \n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n\n\
    \    sorted_even_indicies = even_indicies.clone();\n    sorted_even_indicies.sort();\n\
    \n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            sorted_l.push(sorted_even_indicies[i\
    \ / 2]);\n        } else {\n            sorted_l.push(odd_indicies[i / 2]);\n\
    \        }\n    }\n\n    sorted_l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmps03m2mjv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpgdc99bcu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices = Vec::new();\n    let mut odd_indices = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indices.push(x);\n        } else {\n            odd_indices.push(x);\n\
    \        }\n    }\n    even_indices.sort();\n    for (i, x) in even_indices.iter().enumerate()\
    \ {\n        l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpll64dlfk.rs:21:20\n   |\n\
    21 |         l[i * 2] = *x;\n   |         --------   ^^ expected `isize`, found\
    \ `&isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         l[i * 2] =\
    \ **x;\n   |                    +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for (i, _) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    for i in even_indicies {\n        l_prime[i] = l[i];\n    }\n    l_prime\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpxqcgjtb2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let\
    \ mut even_vals = Vec::new();\n    for i in even_indicies {\n        even_vals.push(l[i]);\n\
    \    }\n    even_vals.sort();\n    for i in 0..even_vals.len() {\n        l[even_indicies[i]]\
    \ = even_vals[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpy6j7altt.rs:22:11\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indicies[i]] = even_vals[i];\n    |           ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp7t82lqy_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_sorted\
    \ = l.clone();\n    l_sorted.sort();\n    let mut l_sorted_even = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l_sorted_even.push(l[i]);\n\
    \        } else {\n            l_sorted_even.push(l_sorted[i]);\n        }\n \
    \   }\n    l_sorted_even\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8mxbursb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    let mut odd_indices:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indices.push(l[i]);\n        } else {\n            odd_indices.push(l[i]);\n\
    \        }\n    }\n    even_indices.sort();\n    for i in 0..even_indices.len()\
    \ {\n        l[2 * i] = even_indices[i];\n    }\n    l\n}\n\nfn main() {\n   \
    \ let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i];\n        } else {\n            l[i] = sort_even_helper(l[i]);\n\
    \        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmpuxdrcemm.rs:15:20\n   |\n15 |             l[i] = sort_even_helper(l[i]);\n\
    \   |                    ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpdmmp7_0x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     while j < l.len() {\n            if l[i] > l[j] {\n                l.swap(i,\
    \ j);\n            }\n            j += 1;\n        }\n        i += 2;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8zbj06hc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpws5crhii.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for i in 0..even_indicies.len() {\n        l[i *\
    \ 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len() {\n      \
    \  l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5trygxtf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpsfivilx_.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = vec![];\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values: Vec<isize> = vec![];\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmp61sowxg1.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = vec![];\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        l[i] = sort_even_helper(l[i]);\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_helper` in this scope\n \
    \ --> /tmp/tmp33nrj51v.rs:17:16\n   |\n17 |         l[i] = sort_even_helper(l[i]);\n\
    \   |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l.insert(i, l.remove(i + 1));\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0499]: cannot borrow `l` as mutable more than once at a time\n \
    \ --> /tmp/tmpig90mdiu.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |             ------------^^^^^^^^^^^^^^^-\n   |             | |\
    \         |\n   |             | |         second mutable borrow occurs here\n\
    \   |             | first borrow later used by call\n   |             first mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmpig90mdiu.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |                         ^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpig90mdiu.rs:13:13\n \
    \  |\n13 |             l.insert(i, l.remove(i + 1));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5ihxdm4c.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpcbqnvt4h.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values = Vec::new();\n    for i in even_indicies {\n\
    \        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for i in\
    \ 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpp5fo_v58.rs:21:17\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for i in 0..even_indicies.len() {\n    |                 ^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i + 1];\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpgqvxw0x5.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    for i in 0..even_indicies.len() {\n        l[i *\
    \ 2] = even_indicies[i];\n    }\n    for i in 0..odd_indicies.len() {\n      \
    \  l[i * 2 + 1] = odd_indicies[i];\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpgg911pk0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n        }\n\
    \    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            l[i] = even_indicies[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n       \
    \ l_new.push(*x);\n        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpd2_620o5.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n        }\n\
    \    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for i in even_indicies\
    \ {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n    for\
    \ i in 0..even_indicies.len() {\n        l[even_indicies[i]] = even_values[i];\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpe9mdkin1.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies: Vec<isize> = Vec::new();\n    let mut odd_indicies:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even_indicies.push(l[i]);\n        } else {\n            odd_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..even_indicies.len()\
    \ {\n        l[i * 2] = even_indicies[i];\n    }\n    l\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = evens[i/2];\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ Vec::new();\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for (i, item) in l.iter().enumerate() {\n        if i % 2\
    \ == 0 {\n            even_indicies.push(*item);\n        } else {\n         \
    \   odd_indicies.push(*item);\n        }\n    }\n    even_indicies.sort();\n \
    \   for (i, item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n       \
    \     l_prime.push(even_indicies.remove(0));\n        } else {\n            l_prime.push(*item);\n\
    \        }\n    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    for\
    \ i in even_indicies {\n        l[i] = l[i] + 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 4]`,\n right: `[1, 2, 3]`', /tmp/tmpsmfewi03.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    let mut even_indicies: Vec<usize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(i);\n\
    \        }\n    }\n    let mut even_values: Vec<isize> = Vec::new();\n    for\
    \ i in even_indicies {\n        even_values.push(l[i]);\n    }\n    even_values.sort();\n\
    \    for i in 0..even_indicies.len() {\n        l_prime[even_indicies[i]] = even_values[i];\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpk3ktfgsi.rs:21:17\n\
    \    |\n10  |     let mut even_indicies: Vec<usize> = Vec::new();\n    |     \
    \    ----------------- move occurs because `even_indicies` has type `Vec<usize>`,\
    \ which does not implement the `Copy` trait\n...\n17  |     for i in even_indicies\
    \ {\n    |              ------------- `even_indicies` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     for i in 0..even_indicies.len() {\n \
    \   |                 ^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `even_indicies`\n\
    help: consider iterating over a slice of the `Vec<usize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |     for i in &even_indicies {\n    |     \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    l.swap(i, j);\n                }\n      \
    \          j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpltyl7r9k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l[i] = l[i + 1];\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpdq__fao0.rs:13:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even_indicies.push(*x);\n        } else {\n            odd_indicies.push(*x);\n\
    \        }\n    }\n    even_indicies.sort();\n    for (i, x) in even_indicies.iter().enumerate()\
    \ {\n        l[i * 2] = *x;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut evens = Vec::new();\n    let mut odds = Vec::new();\n    for (i,\
    \ x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            odds.push(*x);\n\
    \        } else {\n            evens.push(*x);\n        }\n    }\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        l[i * 2 + 1] = *x;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpr7vl4r0h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            even_indicies.push(i);\n        }\n    }\n    let\
    \ mut even_values = Vec::new();\n    for i in even_indicies {\n        even_values.push(l[i]);\n\
    \    }\n    even_values.sort();\n    for i in 0..even_values.len() {\n       \
    \ l[even_indicies[i]] = even_values[i];\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `even_indicies`\n   --> /tmp/tmpofa7xc30.rs:22:11\n\
    \    |\n10  |     let mut even_indicies = Vec::new();\n    |         -----------------\
    \ move occurs because `even_indicies` has type `Vec<usize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in even_indicies {\n    |           \
    \   ------------- `even_indicies` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |         l[even_indicies[i]] = even_values[i];\n    |           ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `even_indicies`\nhelp: consider iterating over\
    \ a slice of the `Vec<usize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &even_indicies {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i + 1;\n            while j < l.len() {\n                if\
    \ l[j] < l[i] {\n                    let temp = l[i];\n                    l[i]\
    \ = l[j];\n                    l[j] = temp;\n                }\n             \
    \   j += 1;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 5, -5, 3, -3, 3, 0, 9, 1, 123, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpg3ox3o9h.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even =\
    \ Vec::new();\n    let mut l_odd = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even.push(*x);\n        } else {\n\
    \            l_odd.push(*x);\n        }\n    }\n    l_even.sort();\n    let mut\
    \ l_new = Vec::new();\n    for (i, x) in l_even.iter().enumerate() {\n       \
    \ l_new.push(*x);\n        l_new.push(l_odd[i]);\n    }\n    l_new\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpxfeepv4l.rs:22:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indices: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\n  \
    \  }\n    even_indices.sort();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            l[i] = even_indices[i / 2];\n        }\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      l.insert(i, l.remove(i + 1));\n            i += 2;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0499]: cannot borrow `l` as mutable more than once at a time\n \
    \ --> /tmp/tmp1wua9ovp.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |             ------------^^^^^^^^^^^^^^^-\n   |             | |\
    \         |\n   |             | |         second mutable borrow occurs here\n\
    \   |             | first borrow later used by call\n   |             first mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmp1wua9ovp.rs:13:25\n   |\n13 |             l.insert(i, l.remove(i\
    \ + 1));\n   |                         ^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmp1wua9ovp.rs:13:13\n \
    \  |\n13 |             l.insert(i, l.remove(i + 1));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  exit_code: 1
  status: SyntaxError
