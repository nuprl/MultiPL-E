name: HumanEval_72_will_it_fly
language: rust
results:
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpiy25zp64.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6eqc26tz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q1 = q.clone();\n        q1.reverse();\n        if q1 == q {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpg10mlxbe.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpkw8mpyde.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && sum <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        if q.len()\
    \ % 2 == 0 {\n            return false;\n        }\n        let mut left = 0;\n\
    \        let mut right = q.len() - 1;\n        while left < right {\n        \
    \    if q[left] != q[right] {\n                return false;\n            }\n\
    \            left += 1;\n            right -= 1;\n        }\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let len = q.len();\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    sum <= w && q == q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n   \
    \     sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_m9679wh.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpvv3ujanv.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let rev: Vec<isize> = q.iter().rev().cloned().collect();\n    sum <= w &&\
    \ q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc3akkj73.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpim3xcmeq.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpwk941hin.rs:19:20\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n19  |     if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n    |                    ^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpehdexj88.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev_q = q.clone();\n        rev_q.reverse();\n        if q == rev_q {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        if q.len()\
    \ % 2 == 0 {\n            return false;\n        }\n        let mut i = 0;\n \
    \       let mut j = q.len() - 1;\n        while i < j {\n            if q[i] !=\
    \ q[j] {\n                return false;\n            }\n            i += 1;\n\
    \            j -= 1;\n        }\n        return true;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphy6vo7_z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut reversed = q.clone();\n    reversed.reverse();\n    sum <= w && q\
    \ == reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxhya_l6l.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmps6wge8ar.rs:16:19\n\
    \   |\n16 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut rev = q.clone();\n    rev.reverse();\n    if q ==\
    \ rev {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let rev: Vec<isize> = q.iter().rev().cloned().collect();\n    sum <= w &&\
    \ q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr0wb6jdp.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ i = 0;\n        let mut j = q.len() - 1;\n        while i < j {\n          \
    \  if q[i] != q[j] {\n                return false;\n            }\n         \
    \   i += 1;\n            j -= 1;\n        }\n        return true;\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum = q.iter().sum::<isize>();\n    let len = q.len();\n    let mut i\
    \ = 0;\n    let mut j = len - 1;\n    while i < j {\n        if q[i] != q[j] {\n\
    \            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj0v3n7by.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum = q.iter().sum::<isize>();\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    q == q_rev && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9m16po1q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfbn3uter.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut left = 0;\n    let mut right = q.len() - 1;\n    while left < right {\n\
    \        sum += q[left] + q[right];\n        left += 1;\n        right -= 1;\n\
    \    }\n    if left == right {\n        sum += q[left];\n    }\n    sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppsjsv8o0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpjbqoff3q.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr2hwm4j5.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut q_rev\
    \ = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphvtf0ts6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5r2ueqp_.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut reversed = q.clone();\n    reversed.reverse();\n    sum <= w && q\
    \ == reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpdsn1uq_z.rs:19:22\n\
    \   |\n19 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmvsekiya.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpftgnrs3e.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxpcltxnc.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpd1jyo9_u.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpbs36vhs1.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp6h07jtdj.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n\
    \    q == q.iter().rev().cloned().collect::<Vec<isize>>() && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmg8ylo6x.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpc4ff_028.rs:19:22\n\
    \   |\n19 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpm3k3wlj7.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpwm3vuo28.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp06hbeui1.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    let len = q.len();\n    if sum <= w\
    \ && q[0] == q[len - 1] {\n        true\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd5vwu98j.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut q_iter = q.iter();\n    let mut q_iter_rev = q.iter().rev();\n    while\
    \ let Some(x) = q_iter.next() {\n        if let Some(y) = q_iter_rev.next() {\n\
    \            if x != y {\n                return false;\n            }\n     \
    \   }\n        sum += x;\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpn6b78xm4.rs:19:20\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n19  |     if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n    |                    ^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpih4a45tv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ i = 0;\n        let mut j = q.len() - 1;\n        while i < j {\n          \
    \  if q[i] != q[j] {\n                return false;\n            }\n         \
    \   i += 1;\n            j -= 1;\n        }\n        return true;\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    sum <= w && q == q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7n8c4j0i.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ reversed = q.clone();\n        reversed.reverse();\n        if q == reversed\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp9o14t520.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut rev_q = q.clone();\n    rev_q.reverse();\n    sum <= w && q == rev_q\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp3g1hr6rd.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    for i in 0..q.len() {\n  \
    \      if q[i] != q_rev[i] {\n            return false;\n        }\n        sum\
    \ += q[i];\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n\
    \    q == q.iter().rev().collect::<Vec<_>>() && q.iter().sum::<isize>() <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp0vew1it8.rs:15:7\n\
    \   |\n15 |     q == q.iter().rev().collect::<Vec<_>>() && q.iter().sum::<isize>()\
    \ <= w\n   |       ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.reverse();\n    let mut sum = 0;\n    for i in q {\n        sum += i;\n\
    \        if sum > w {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps8jl1aue.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n\
    \    q == q.iter().rev().cloned().collect::<Vec<isize>>() && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut rev_q = q.clone();\n    rev_q.reverse();\n    sum <= w && q == rev_q\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmphzmsgb_j.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let len = q.len();\n    let mut i = 0;\n    let mut j = len - 1;\n    while\
    \ i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n \
    \       i += 1;\n        j -= 1;\n    }\n    sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let is_palindrome = q.iter().eq(q.iter().rev());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr7i9unxp.rs:19:22\n\
    \   |\n19 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmphbprnm46.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && sum <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let is_palindrome = q.iter().eq(q.iter().rev());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    let mut palindrome = true;\n    for\
    \ i in 0..q.len() / 2 {\n        if q[i] != q[q.len() - i - 1] {\n           \
    \ palindrome = false;\n            break;\n        }\n    }\n    palindrome &&\
    \ sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0navi177.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpaf_9gju5.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp2knzl29i.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    while i\
    \ < j {\n        if q[i] != q[j] {\n            return false;\n        }\n   \
    \     i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let is_palindrome: bool = q.iter().eq(q.iter().rev());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let is_palindrome = q.iter().eq(q.iter().rev());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q_rev == q {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut sum = 0;\n    while !q.is_empty() {\n        sum += q.pop().unwrap();\n\
    \        if !q.is_empty() {\n            sum += q.remove(0);\n        }\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg88k3y0b.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpzd6_nlx1.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp2rikcimf.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_iter = q.iter();\n\
    \    let mut q_iter_rev = q.iter().rev();\n    let mut sum = 0;\n    loop {\n\
    \        match (q_iter.next(), q_iter_rev.next()) {\n            (Some(x), Some(y))\
    \ => {\n                if x != y {\n                    return false;\n     \
    \           }\n                sum += x + y;\n            }\n            (Some(x),\
    \ None) => {\n                sum += x;\n            }\n            (None, Some(y))\
    \ => {\n                sum += y;\n            }\n            (None, None) =>\
    \ {\n                break;\n            }\n        }\n    }\n    sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwippblcu.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpdmkk5xt2.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    q == q_rev && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4gev2jws.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpb89e09xq.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let is_palindrome: bool = q.iter().rev().eq(q.iter());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb7nwswzh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpab_on5lj.rs:16:22\n\
    \   |\n16 |     if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n\
    \   |                      ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp9lyc7xi6.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmppyflq8oh.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    if\
    \ q_rev == q {\n        return true;\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpoeb0p86x.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut sum = 0;\n    while !q.is_empty() {\n        sum += q.pop().unwrap();\n\
    \        if !q.is_empty() {\n            sum += q.remove(0);\n        }\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgpgnsu89.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp_0nj4cp1.rs:19:20\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n19  |     if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n    |                    ^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut sum = 0;\n    while !q.is_empty() {\n        sum += q.pop().unwrap();\n\
    \        if !q.is_empty() {\n            sum += q.remove(0);\n        }\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0iqvrjla.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpln95rxfl.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut sum = 0;\n    while !q.is_empty() {\n        sum += q.pop().unwrap();\n\
    \        if !q.is_empty() {\n            sum += q.remove(0);\n        }\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptdfrwfxu.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5ktjjqf6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmppxkppbnc.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    if sum <= w {\n        let mut q_rev\
    \ = q.clone();\n        q_rev.reverse();\n        q == q_rev\n    } else {\n \
    \       false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum = q.iter().sum::<isize>();\n    if sum > w {\n        return false;\n\
    \    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmf60fu5n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        if q.len()\
    \ % 2 == 0 {\n            return false;\n        }\n        let mut i = 0;\n \
    \       let mut j = q.len() - 1;\n        while i < j {\n            if q[i] !=\
    \ q[j] {\n                return false;\n            }\n            i += 1;\n\
    \            j -= 1;\n        }\n        return true;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp944su_a9.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    for i in 0..q.len() {\n  \
    \      if q[i] != q_rev[i] {\n            return false;\n        }\n        sum\
    \ += q[i];\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpw_1tc9fo.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut q_rev = q.clone();\n    q_rev.reverse();\n    q == q_rev && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let len = q.len();\n    let mut i = 0;\n    let mut j = len - 1;\n    while\
    \ i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n \
    \       i += 1;\n        j -= 1;\n    }\n    sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmphewhbnts.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmpyplq71.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let rev: Vec<isize> = q.iter().rev().cloned().collect();\n    sum <= w &&\
    \ q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q_rev == q {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr9gm9d4w.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmphzkqx47x.rs:19:20\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n19  |     if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n    |                    ^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ rev = q.clone();\n        rev.reverse();\n        if rev == q {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfye35zxa.rs:19:22\n\
    \   |\n19 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ > w {\n        return false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    q == q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp_l1zprph.rs:22:21\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n22  |     let mut q_rev = q.clone();\n    |           \
    \          ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let rev: Vec<isize> = q.iter().rev().cloned().collect();\n    sum <= w &&\
    \ q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    let mut q_rev = q.clone();\n\
    \    q_rev.reverse();\n    sum <= w && q == q_rev\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ > w {\n        return false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    q == q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpb8pnpvqv.rs:22:21\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n...\n22  |     let mut q_rev = q.clone();\n    |           \
    \          ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum\
    \ <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdatyyn84.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmihm0_u_.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let rev = q.iter().rev().collect::<Vec<_>>();\n    sum <= w && q == rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpl3xw6jsi.rs:15:19\n\
    \   |\n15 |     sum <= w && q == rev\n   |                   ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ q_rev = q.clone();\n        q_rev.reverse();\n        if q == q_rev {\n    \
    \        return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    sum <= w && q == q_rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpp3sjb3kp.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let sum = q.iter().sum::<isize>();\n    let mut i = 0;\n    let mut j = q.len()\
    \ - 1;\n    while i < j {\n        if q[i] != q[j] {\n            return false;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5virr657.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpnwppsjvn.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7p2txbtj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmprhpiceh9.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
