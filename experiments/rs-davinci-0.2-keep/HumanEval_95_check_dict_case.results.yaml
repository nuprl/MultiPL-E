name: HumanEval_95_check_dict_case
language: rust
results:
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_uppercase() {\n            lower_case =\
    \ false;\n        } else {\n            upper_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuwcjfhm8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpvzfispdw.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpvzfispdw.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpgfe4tfs6.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpgfe4tfs6.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpucb8l8vu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp2ei9mpdj.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp2ei9mpdj.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case_keys\
    \ = true;\n    let mut upper_case_keys = true;\n    for key in dict.keys() {\n\
    \        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case_keys\
    \ = false;\n        }\n        if key.chars().any(|c| c.is_lowercase()) {\n  \
    \          upper_case_keys = false;\n        }\n    }\n    lower_case_keys ||\
    \ upper_case_keys\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgwhyopp6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for (key, _) in dict {\n      \
    \  if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpch2xnl_b.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5phn17a3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpi06m4bru.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpi06m4bru.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.chars().all(|c| c.is_lowercase()) {\n            lower = false;\n     \
    \   }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper\
    \ = false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt9cv8agw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph6qar1fo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpaf2y93xo.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpaf2y93xo.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp63ulag25.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcpy6al39.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.to_uppercase() != key {\n            upper_case = false;\n       \
    \ }\n        if key.to_lowercase() != key {\n            lower_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpo2sjxo9j.rs:16:31\n\
    \   |\n16 |         if key.to_uppercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpo2sjxo9j.rs:19:31\n   |\n19 |         if key.to_lowercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            is_lower = is_lower && key.chars().all(|c|\
    \ c.is_lowercase());\n            is_upper = is_upper && key.chars().all(|c| c.is_uppercase());\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvt4euhqf.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_all_lower\
    \ = true;\n    let mut is_all_upper = true;\n    for key in dict.keys() {\n  \
    \      if key.chars().all(|c| c.is_lowercase()) {\n            is_all_upper =\
    \ false;\n        } else if key.chars().all(|c| c.is_uppercase()) {\n        \
    \    is_all_lower = false;\n        } else {\n            return false;\n    \
    \    }\n    }\n    is_all_lower || is_all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2yi00m_3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzuxujhz4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        }\n    }\n    lower\
    \ || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_rz8th4t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpba_mfa9s.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpethibj11.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps68n1if5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxw7wivw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz3wkcjpj.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmphb84g50_.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmphb84g50_.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprpupr4zz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.chars().any(|c| c.is_uppercase()) {\n            all_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            all_upper\
    \ = false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8kl108y9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpuexqtfro.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpuexqtfro.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpfcbidagq.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpfcbidagq.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp17keeboo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().next().unwrap().is_lowercase() {\n            upper = false;\n \
    \       } else {\n            lower = false;\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdzmhmjy8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb137kib2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk4q27pqw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for (key, _) in dict {\n      \
    \  if key.chars().all(|c| c.is_lowercase()) {\n            is_lower = true;\n\
    \        } else if key.chars().all(|c| c.is_uppercase()) {\n            is_upper\
    \ = true;\n        } else {\n            return false;\n        }\n    }\n   \
    \ is_lower || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7rr_ha9t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpd8hlw4vh.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpd8hlw4vh.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpckiq7sfr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsrd96hzw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_all_lower\
    \ = true;\n    let mut is_all_upper = true;\n    for (key, _) in dict {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            is_all_upper = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            is_all_lower\
    \ = false;\n        }\n    }\n    is_all_lower || is_all_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9ssgu6sx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        } else {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpue6i1pbn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm5j29njc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_smga8ww.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa812lj6t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgq4x9o5i.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                upper_case = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   return false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpah1ypdc7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqvgf6rn0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxrcnacjy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_empty() {\n            return false;\n        }\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = true;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = true;\n        } else {\n      \
    \      return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6c2781fx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpadb2v5z5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpowux3t25.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpuzbx4r_2.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpuzbx4r_2.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        } else if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7bheteah.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpukc7klu6.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpukc7klu6.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9o80fvua.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsi92agd1.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmphu9emi4h.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmphu9emi4h.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_empty() {\n            if !key.chars().all(|c| c.is_lowercase())\
    \ {\n                lower_case = false;\n            }\n            if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n                upper_case = false;\n            }\n  \
    \      }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppdloq39d.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkh2j6a1v.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4qf4s8u4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6k1wvp57.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for (key, _) in dict {\n      \
    \  if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvd4ovo5o.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4g29v_jq.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_upper\
    \ = true;\n    let mut is_lower = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().all(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        } else if key.chars().all(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  !is_upper && !is_lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2p3pblip.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz88ac39e.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwdl_8ckv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().next().unwrap().is_lowercase() {\n            upper = false;\n \
    \       } else {\n            lower = false;\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp587f4zpt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_lowercase() {\n            is_lower = true;\n        } else if\
    \ key.is_uppercase() {\n            is_upper = true;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower != is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpfz9hcy6e.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpfz9hcy6e.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmqt4y68s.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpht3gnhuw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp_sj7fb3_.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp_sj7fb3_.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp880t1sji.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp880t1sji.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().all(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        } else if key.chars().all(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_upper\
    \ = false;\n    let mut is_lower = false;\n    for key in dict.keys() {\n    \
    \    if key.is_uppercase() {\n            is_upper = true;\n        } else if\
    \ key.is_lowercase() {\n            is_lower = true;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if is_upper && is_lower {\n     \
    \   return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpbzb37eo2.rs:16:16\n   |\n16 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmpbzb37eo2.rs:18:23\n\
    \   |\n18 |         } else if key.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplejjm5gm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps5il4x0m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_empty() {\n            if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   upper_case = false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1k0izr_j.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8ppel3cz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmn_6jy0_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvrj6qja9.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk97p3bm0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexn3pfcx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // TODO: Implement\
    \ this function\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw1aojdq7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpchnlnk6h.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().all(|c| c.is_lowercase()) {\n            upper = false;\n      \
    \  } else if key.chars().all(|c| c.is_uppercase()) {\n            lower = false;\n\
    \        } else {\n            return false;\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5undn58a.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for (key, _) in dict {\n      \
    \  if !key.is_ascii_lowercase() {\n            lower_case = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            upper_case = false;\n   \
    \     }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpnwkfgdq9.rs:16:17\n   |\n16 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpnwkfgdq9.rs:19:17\n   |\n19 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg19lo30f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjgz5s2v5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpyiotoyxs.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpyiotoyxs.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpuggixh_m.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpuggixh_m.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        }\n    }\n    lower\
    \ || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp22139ud4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case_keys\
    \ = true;\n    let mut upper_case_keys = true;\n    for key in dict.keys() {\n\
    \        if !key.is_ascii_lowercase() {\n            lower_case_keys = false;\n\
    \        }\n        if !key.is_ascii_uppercase() {\n            upper_case_keys\
    \ = false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpy6xalrjx.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpy6xalrjx.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for (key, _) in dict {\n      \
    \  if key.chars().next().unwrap().is_lowercase() {\n            upper_case = false;\n\
    \        } else if key.chars().next().unwrap().is_uppercase() {\n            lower_case\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp41he8vtt.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaqyjlujw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        }\n    }\n    lower\
    \ || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf794jvnc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkwqduam_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7kmxjwc3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpppzayv00.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpppzayv00.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeugvmo6t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp024zkrri.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        } else if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        } else {\n        \
    \    return false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3nurd490.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ != is_lower {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_5sua2dk.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfnwal3wr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjmk8lvv6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpfyek3kyl.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpfyek3kyl.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyujqdxs7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for key in dict.keys() {\n        if\
    \ key.is_lowercase() {\n            lower_count += 1;\n        } else if key.is_uppercase()\
    \ {\n            upper_count += 1;\n        }\n    }\n    if lower_count == dict.len()\
    \ || upper_count == dict.len() {\n        return true;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpcf385fqt.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpcf385fqt.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp433585y7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw3f89d4y.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpmtc55wvp.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmtc55wvp.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.to_lowercase() != key {\n            lower_case = false;\n       \
    \ }\n        if key.to_uppercase() != key {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpt8i66sto.rs:16:31\n\
    \   |\n16 |         if key.to_lowercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpt8i66sto.rs:19:31\n   |\n19 |         if key.to_uppercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // TODO: Implement\
    \ check_dict_case\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase()) {\n   \
    \         lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf0dz_axi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8oyr3hyr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp27kbe6ik.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpv6dne1bv.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpv6dne1bv.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ is_upper = false;\n            }\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzcjoq9h7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        }\n    }\n    lower\
    \ || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpilu3wvbl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzqfrhmql.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3kp8p0oc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp99jv897j.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp99jv897j.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvxw08wle.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmplzpgsgcf.rs:16:17\n   |\n16 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplzpgsgcf.rs:19:17\n   |\n19 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpewiz6y9g.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpewiz6y9g.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                upper_case = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   return false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnt1w6cxd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.chars().any(|c| c.is_uppercase()) {\n            all_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            all_upper\
    \ = false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn5eqs7vo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for (key, _) in dict {\n       \
    \ if key.chars().any(|c| c.is_uppercase()) {\n            all_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            all_upper\
    \ = false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp11yp7se3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf9ie9rgr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_uppercase() {\n            lower_case =\
    \ false;\n        } else {\n            upper_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph941qkcn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwkoy_mfi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpefxomtqk.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjwaz5xk6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpudhvaxv9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                is_upper = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ return false;\n            }\n        }\n    }\n    is_lower || is_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcupof38l.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpobf8oz2f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wfb26im.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqrnuqk2p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase() {\n\
    \            lower = false;\n        }\n        if !key.is_ascii_uppercase() {\n\
    \            upper = false;\n        }\n    }\n    return lower || upper;\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpj1lbms8p.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpj1lbms8p.rs:22:17\n   |\n22 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8wf2xcl2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmptf45m3ig.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmptf45m3ig.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().next().unwrap().is_uppercase() {\n            lower = false;\n \
    \       } else {\n            upper = false;\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9tkqidvv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for (key, _) in dict {\n       \
    \ if key.chars().any(|c| c.is_uppercase()) {\n            all_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            all_upper\
    \ = false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz3xc_yz2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0_ynrodf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp28qwgcun.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp28qwgcun.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpduegzaca.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpduegzaca.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut case_type\
    \ = None;\n    for key in dict.keys() {\n        let key_case = key.chars().next().unwrap().is_uppercase();\n\
    \        if case_type == None {\n            case_type = Some(key_case);\n   \
    \     } else if case_type != Some(key_case) {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpicah4oq5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_ascii_lowercase() {\n            is_lower = true;\n        } else\
    \ if key.is_ascii_uppercase() {\n            is_upper = true;\n        } else\
    \ {\n            return false;\n        }\n    }\n    is_lower ^ is_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmprw8o4slv.rs:16:16\n   |\n16 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmprw8o4slv.rs:18:23\n   |\n18 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp9ihvhr47.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp9ihvhr47.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnvb7zvf5.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_ascii_lowercase()) {\n            lower_case\
    \ = false;\n        }\n        if !key.chars().all(|c| c.is_ascii_uppercase())\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr1ogleik.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu7l0t7it.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_uppercase() {\n            lower_case =\
    \ false;\n        } else {\n            upper_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpya43107o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                upper_case = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   return false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5kr7ty4p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = true;\n    let mut is_upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else {\n            is_lower = false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp06uwhjd8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.chars().all(|c| c.is_lowercase()) {\n            is_lower = true;\n\
    \        } else if key.chars().all(|c| c.is_uppercase()) {\n            is_upper\
    \ = true;\n        } else {\n            return false;\n        }\n    }\n   \
    \ is_lower || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprghiox06.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // TODO: Implement\
    \ this function\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ key in dict.keys() {\n        if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                upper = false;\n            } else {\n                lower\
    \ = false;\n            }\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfxi8h1n7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcgbx18sn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_lowercase() {\n            is_lower = true;\n        } else if\
    \ key.is_uppercase() {\n            is_upper = true;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpw_4y_jwk.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpw_4y_jwk.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpifwptslw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3gd2ctoi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsfrtvx5s.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptfx0xyxv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6pnba3e4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_ascii_lowercase() {\n            is_lower = false;\n        }\n\
    \        if !key.is_ascii_uppercase() {\n            is_upper = false;\n     \
    \   }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpg2pyfpcv.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpg2pyfpcv.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpclqqej45.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxvimr5mj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp10yfi93b.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpneu6tizx.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            if key.chars().next().unwrap().is_lowercase()\
    \ {\n                is_upper = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ return false;\n            }\n        }\n    }\n    is_lower || is_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0j3i4cfl.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_ascii_lowercase() {\n            is_lower = true;\n        } else\
    \ if key.is_ascii_uppercase() {\n            is_upper = true;\n        } else\
    \ {\n            return false;\n        }\n    }\n    if is_lower && is_upper\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpko7xgz6e.rs:16:16\n   |\n16 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpko7xgz6e.rs:18:23\n   |\n18 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.to_lowercase() != key {\n            lower_case = false;\n       \
    \ }\n        if key.to_uppercase() != key {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpu9m07gia.rs:16:31\n\
    \   |\n16 |         if key.to_lowercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpu9m07gia.rs:19:31\n   |\n19 |         if key.to_uppercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj1ipv_n.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_uppercase() {\n            lower_case =\
    \ false;\n        } else {\n            upper_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7kzm3fa5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph_0rzqk2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp2sddfpf0.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp2sddfpf0.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphzoeo_a_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0k5r680p.rs:16:17\n   |\n16 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0k5r680p.rs:19:17\n   |\n19 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.to_lowercase() != key {\n            lower_case = false;\n       \
    \ }\n        if key.to_uppercase() != key {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp40ibcqht.rs:16:31\n\
    \   |\n16 |         if key.to_lowercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp40ibcqht.rs:19:31\n   |\n19 |         if key.to_uppercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvs2vvlwu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_lowercase() {\n            lower_case = false;\n       \
    \ }\n        if !key.is_ascii_uppercase() {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpt63dtox4.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpt63dtox4.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpja67ygfw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp41fd8d_r.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_case\
    \ = true;\n    let mut lower_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().all(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        } else if key.chars().all(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  upper_case || lower_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpunrr_q4l.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdxbgvu1g.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps8h5y449.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfo23spf4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.chars().all(|c| c.is_lowercase()) {\n            all_upper = false;\n\
    \        } else if key.chars().all(|c| c.is_uppercase()) {\n            all_lower\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  all_lower || all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpet_vj1t2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lowercase\
    \ = true;\n    let mut uppercase = true;\n    for key in dict.keys() {\n     \
    \   if key.chars().next().unwrap().is_uppercase() {\n            lowercase = false;\n\
    \        } else {\n            uppercase = false;\n        }\n    }\n    lowercase\
    \ || uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo09h2uqh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8gwawedr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper = false;\n        } else {\n        \
    \    return false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjywv9i3n.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.is_ascii_lowercase() {\n\
    \            upper = false;\n        } else if key.is_ascii_uppercase() {\n  \
    \          lower = false;\n        } else {\n            return false;\n     \
    \   }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu05uwz7z.rs:19:16\n   |\n19 |         if\
    \ key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpu05uwz7z.rs:21:23\n   |\n21 |         } else if key.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.to_uppercase() != *key {\n            all_upper = false;\n        }\n\
    \        if key.to_lowercase() != *key {\n            all_lower = false;\n   \
    \     }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp91fiiurl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph5g8ufcv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_lowercase() {\n            lower = false;\n        }\n       \
    \ if !key.is_ascii_uppercase() {\n            upper = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpz5e7fzyx.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpz5e7fzyx.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5esjj3np.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    for key in dict.keys() {\n    \
    \    if key.is_lowercase() {\n            is_lower = true;\n        } else if\
    \ key.is_uppercase() {\n            is_upper = true;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if is_lower && is_upper {\n     \
    \   return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpgbtvrs_t.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpgbtvrs_t.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().any(|c| c.is_uppercase()) {\n            is_lower = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            is_upper\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzin6tnkl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n      \
    \  }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper =\
    \ false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_hmootnw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqislq7sy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            if !key.chars().next().unwrap().is_ascii_lowercase()\
    \ {\n                is_lower = false;\n            }\n            if !key.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n                is_upper = false;\n            }\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxan59dwc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().any(|c| c.is_uppercase()) {\n            lower_case = false;\n\
    \        } else {\n            upper_case = false;\n        }\n    }\n    lower_case\
    \ || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp987quofr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.chars().next().unwrap().is_lowercase() {\n            upper_case =\
    \ false;\n        } else {\n            lower_case = false;\n        }\n    }\n\
    \    lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfbs3r33b.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.is_empty() {\n            if !key.chars().all(|c| c.is_lowercase())\
    \ {\n                is_lower = false;\n            }\n            if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n                is_upper = false;\n            }\n    \
    \    }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp239zp96p.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
