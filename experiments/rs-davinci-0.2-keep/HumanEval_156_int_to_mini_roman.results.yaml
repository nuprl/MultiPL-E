name: HumanEval_156_int_to_mini_roman
language: rust
results:
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpnsc2hjxg.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (numeral, value) in roman_numerals {\n     \
    \   while number >= *value {\n            result.push_str(numeral);\n        \
    \    number -= value;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpxpb8oewa.rs:27:25\n\
    \   |\n27 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpnrqig2ed.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        let roman_digit = match digit {\n    \
    \        0 => \"\",\n            1 => \"i\",\n            2 => \"ii\",\n     \
    \       3 => \"iii\",\n            4 => \"iv\",\n            5 => \"v\",\n   \
    \         6 => \"vi\",\n            7 => \"vii\",\n            8 => \"viii\",\n\
    \            9 => \"ix\",\n            _ => panic!(\"Invalid digit: {}\", digit),\n\
    \        };\n        result = format!(\"{}{}\", roman_digit, result);\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpichgo9sc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    while number > 0 {\n        if number >= 1000 {\n            result.push('m');\n\
    \            number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = match digit {\n            1 => format!(\"{}{}\"\
    , ROMAN_DIGITS[i][0], result),\n            2 => format!(\"{}{}\", ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n            3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n            4 => format!(\"{}{}\"\
    , ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][1]),\n            5 => format!(\"{}\", ROMAN_DIGITS[i][1]),\n\
    \            6 => format!(\"{}{}\", ROMAN_DIGITS[i][1], ROMAN_DIGITS[i][0]),\n\
    \            7 => format!(\"{}{}{}\", ROMAN_DIGITS[i][1], ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n            8 => format!(\"{}{}{}{}\", ROMAN_DIGITS[i][1],\
    \ ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n            9\
    \ => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][2]),\n            _\
    \ => String::new(),\n        };\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:16:34\n\
    \   |\n16 |             1 => format!(\"{}{}\", ROMAN_DIGITS[i][0], result),\n\
    \   |                                  ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:17:34\n\
    \   |\n17 |             2 => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                  ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:17:54\n\
    \   |\n17 |             2 => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                                      ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n\
    \  --> /tmp/tmp9_jmyh_0.rs:18:36\n   |\n18 |             3 => format!(\"{}{}{}\"\
    , ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n   |         \
    \                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:18:56\n\
    \   |\n18 |             3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n   |                                                 \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:18:76\n   |\n18 |  \
    \           3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                                                        \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS`\
    \ in this scope\n  --> /tmp/tmp9_jmyh_0.rs:19:34\n   |\n19 |             4 =>\
    \ format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][1]),\n   |           \
    \                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmp9_jmyh_0.rs:19:54\n\
    \   |\n19 |             4 => format!(\"{}{}\", R"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpij8a9_e1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number >= 1000 {\n        result.push('m');\n        number\
    \ -= 1000;\n    }\n    if number >= 900 {\n        result.push_str(\"cm\");\n\
    \        number -= 900;\n    }\n    if number >= 500 {\n        result.push('d');\n\
    \        number -= 500;\n    }\n    if number >= 400 {\n        result.push_str(\"\
    cd\");\n        number -= 400;\n    }\n    while number >= 100 {\n        result.push('c');\n\
    \        number -= 100;\n    }\n    if number >= 90 {\n        result.push_str(\"\
    xc\");\n        number -= 90;\n    }\n    if number >= 50 {\n        result.push('l');\n\
    \        number -= 50;\n    }\n    if number >= 40 {\n        result.push_str(\"\
    xl\");\n        number -= 40;\n    }\n    while number >= 10 {\n        result.push('x');\n\
    \        number -= 10;\n    }\n    if number >= 9 {\n        result.push_str(\"\
    ix\");\n        number -= 9;\n    }\n    if number >= 5 {\n        result.push('v');\n\
    \        number -= 5;\n    }\n    if number >= 4 {\n        result.push_str(\"\
    iv\");\n        number -= 4;\n    }\n    while number >= 1 {\n        result.push('i');\n\
    \        number -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    let roman_digit = match digit {\n            1 => \"i\",\n            2 =>\
    \ \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n            5\
    \ => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n           \
    \ 8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n        };\n\
    \        result = format!(\"{}{}\", roman_digit, result);\n        num /= 10;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmphgkdpdjf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut digit = 0;\n    while number > 0 {\n        let ones\
    \ = number % 10;\n        number /= 10;\n        let tens = number % 10;\n   \
    \     number /= 10;\n        let hundreds = number % 10;\n        number /= 10;\n\
    \        let thousands = number % 10;\n        number /= 10;\n        if digit\
    \ == 0 {\n            result = format!(\"{}{}\", result, ones_to_mini_roman(ones));\n\
    \        } else if digit == 1 {\n            result = format!(\"{}{}\", result,\
    \ tens_to_mini_roman(tens));\n        } else if digit == 2 {\n            result\
    \ = format!(\"{}{}\", result, hundreds_to_mini_roman(hundreds));\n        } else\
    \ if digit == 3 {\n            result = format!(\"{}{}\", result, thousands_to_mini_roman(thousands));\n\
    \        }\n        digit += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ones_to_mini_roman` in this scope\n\
    \  --> /tmp/tmplyexc2mt.rs:22:46\n   |\n22 |             result = format!(\"{}{}\"\
    , result, ones_to_mini_roman(ones));\n   |                                   \
    \           ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `tens_to_mini_roman` in this scope\n  --> /tmp/tmplyexc2mt.rs:24:46\n\
    \   |\n24 |             result = format!(\"{}{}\", result, tens_to_mini_roman(tens));\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `hundreds_to_mini_roman`\
    \ in this scope\n  --> /tmp/tmplyexc2mt.rs:26:46\n   |\n26 |             result\
    \ = format!(\"{}{}\", result, hundreds_to_mini_roman(hundreds));\n   |       \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `thousands_to_mini_roman` in this\
    \ scope\n  --> /tmp/tmplyexc2mt.rs:28:46\n   |\n28 |             result = format!(\"\
    {}{}\", result, thousands_to_mini_roman(thousands));\n   |                   \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut digit = 0;\n    let mut digit_value = 1;\n    while number\
    \ > 0 {\n        digit = number % 10;\n        number /= 10;\n        if digit\
    \ == 4 {\n            result.insert(0, 'i');\n            result.insert(0, 'v');\n\
    \        } else if digit == 9 {\n            result.insert(0, 'i');\n        \
    \    result.insert(0, 'x');\n        } else {\n            if digit >= 5 {\n \
    \               result.insert(0, 'v');\n                digit -= 5;\n        \
    \    }\n            for _ in 0..digit {\n                result.insert(0, 'i');\n\
    \            }\n        }\n        if digit_value == 10 {\n            result\
    \ = result.replace(\"iiiii\", \"v\");\n            result = result.replace(\"\
    vv\", \"x\");\n            result = result.replace(\"iiii\", \"iv\");\n      \
    \      result = result.replace(\"viv\", \"ix\");\n        } else if digit_value\
    \ == 100 {\n            result = result.replace(\"iiiiiiiii\", \"ix\");\n    \
    \        result = result.replace(\"xxxxxxxxx\", \"c\");\n            result =\
    \ result.replace(\"iiiiiiii\", \"viii\");\n            result = result.replace(\"\
    xxxxxxxx\", \"lxxx\");\n            result = result.replace(\"iiiiiii\", \"vii\"\
    );\n            result = result.replace(\"xxxxxxx\", \"lxx\");\n            result\
    \ = result.replace(\"iiiiii\", \"vi\");\n            result = result.replace(\"\
    xxxxxx\", \"lx\");\n            result = result.replace(\"iiiii\", \"v\");\n \
    \           result = result.replace(\"xxxxx\", \"l\");\n            result = result.replace(\"\
    iiii\", \"iv\");\n            result = result.replace(\"xxxx\", \"xl\");\n   \
    \         result = result.replace(\"iii\", \"iii\");\n            result = result.replace(\"\
    xxx\", \"xxx\");\n            result = result.replace(\"ii\", \"ii\");\n     \
    \       result = result.replace(\"xx\", \"xx\");\n            result = result.replace(\"\
    i\", \"i\");\n            result = result.replace(\"x\", \"x\");\n        }\n\
    \       \n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprmy9mmkw.rs:75:3\n\
    \   |\n8  | fn int_to_mini_roman(number: isize) -> String {\n   |            \
    \                                   - unclosed delimiter\n...\n13 |     while\
    \ number > 0 {\n   |                      - this delimiter might not be properly\
    \ closed...\n...\n57 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmprmy9mmkw.rs:8:40\n\
    \  |\n8 | fn int_to_mini_roman(number: isize) -> String {\n  |    -----------------\
    \                   ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    if digit == 9 {\n            result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n\
    \            result.push_str(&MINI_ROMAN_DIGITS[i]);\n        } else if digit\
    \ == 4 {\n            result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n          \
    \  result.push_str(&MINI_ROMAN_DIGITS[i]);\n        } else if digit >= 5 {\n \
    \           result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n            for _ in\
    \ 0..digit - 5 {\n                result.push_str(&MINI_ROMAN_DIGITS[i]);\n  \
    \          }\n        } else {\n            for _ in 0..digit {\n            \
    \    result.push_str(&MINI_ROMAN_DIGITS[i]);\n            }\n        }\n     \
    \   num /= 10;\n        i += 2;\n    }\n    result.chars().rev().collect()\n}\n\
    \nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n  -->\
    \ /tmp/tmpjptqq2tu.rs:15:30\n   |\n15 |             result.push_str(&MINI_ROMAN_DIGITS[i\
    \ + 1]);\n   |                              ^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n\
    \  --> /tmp/tmpjptqq2tu.rs:16:30\n   |\n16 |             result.push_str(&MINI_ROMAN_DIGITS[i]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpjptqq2tu.rs:18:30\n\
    \   |\n18 |             result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n   |    \
    \                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpjptqq2tu.rs:19:30\n\
    \   |\n19 |             result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |        \
    \                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpjptqq2tu.rs:21:30\n\
    \   |\n21 |             result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n   |    \
    \                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpjptqq2tu.rs:23:34\n\
    \   |\n23 |                 result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpjptqq2tu.rs:27:34\n\
    \   |\n27 |                 result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\",\
    \ 900),\n        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n\
    \        (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"\
    x\", 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n \
    \       (\"i\", 1),\n    ];\n    while number > 0 {\n        let (numeral, value)\
    \ = roman_numerals.pop().unwrap();\n        while number >= value {\n        \
    \    result.push_str(numeral);\n            number -= value;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmpdaz1qefd.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        if digit == 4 {\n            result.insert(0, ROMAN_DIGITS[i + 1]);\n\
    \            result.insert(0, ROMAN_DIGITS[i]);\n        } else if digit == 9\
    \ {\n            result.insert(0, ROMAN_DIGITS[i + 2]);\n            result.insert(0,\
    \ ROMAN_DIGITS[i]);\n        } else if digit >= 5 {\n            result.insert(0,\
    \ ROMAN_DIGITS[i + 1]);\n            for _ in 0..digit - 5 {\n               \
    \ result.insert(0, ROMAN_DIGITS[i]);\n            }\n        } else {\n      \
    \      for _ in 0..digit {\n                result.insert(0, ROMAN_DIGITS[i]);\n\
    \            }\n        }\n        number /= 10;\n        i += 2;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:15:30\n\
    \   |\n15 |             result.insert(0, ROMAN_DIGITS[i + 1]);\n   |         \
    \                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:16:30\n \
    \  |\n16 |             result.insert(0, ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:18:30\n \
    \  |\n18 |             result.insert(0, ROMAN_DIGITS[i + 2]);\n   |          \
    \                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:19:30\n \
    \  |\n19 |             result.insert(0, ROMAN_DIGITS[i]);\n   |              \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:21:30\n \
    \  |\n21 |             result.insert(0, ROMAN_DIGITS[i + 1]);\n   |          \
    \                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:23:34\n \
    \  |\n23 |                 result.insert(0, ROMAN_DIGITS[i]);\n   |          \
    \                        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpx2v3_bpx.rs:27:34\n\
    \   |\n27 |                 result.insert(0, ROMAN_DIGITS[i]);\n   |         \
    \                         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        if digit == 0 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut roman = String::new();\n        match i {\n      \
    \      0 => {\n                if digit <= 3 {\n                    roman.push_str(&\"\
    i\".repeat(digit as usize));\n                } else if digit == 4 {\n       \
    \             roman.push_str(\"iv\");\n                } else if digit == 5 {\n\
    \                    roman.push_str(\"v\");\n                } else if digit <=\
    \ 8 {\n                    roman.push_str(\"v\");\n                    roman.push_str(&\"\
    i\".repeat((digit - 5) as usize));\n                } else {\n               \
    \     roman.push_str(\"ix\");\n                }\n            }\n            1\
    \ => {\n                if digit <= 3 {\n                    roman.push_str(&\"\
    x\".repeat(digit as usize));\n                } else if digit == 4 {\n       \
    \             roman.push_str(\"xl\");\n                } else if digit == 5 {\n\
    \                    roman.push_str(\"l\");\n                } else if digit <=\
    \ 8 {\n                    roman.push_str(\"l\");\n                    roman.push_str(&\"\
    x\".repeat((digit - 5) as usize));\n                } else {\n               \
    \     roman.push_str(\"xc\");\n                }\n            }\n            2\
    \ => {\n                if digit <= 3 {\n                    roman.push_str(&\"\
    c\".repeat(digit as usize));\n                } else if digit == 4 {\n       \
    \             roman.push_str(\"cd\");\n                } else if digit == 5 {\n\
    \                    roman.push_str(\"d\");\n                } else if digit <=\
    \ 8 {\n                    roman.push_str(\"d\");\n                    roman.push_str(&\"\
    c\".repeat((digit - 5) as usize));\n                } else {\n               \
    \     roman.push_str(\"cm\");\n                }\n            }\n            3\
    \ => {\n                roman.push_str(&\"m\".repeat(digit as\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf2m6sywo.rs:83:3\n\
    \   |\n8  | fn int_to_mini_roman(number: isize) -> String {\n   |            \
    \                                   - unclosed delimiter\n...\n12 |     while\
    \ num > 0 {\n   |                   - unclosed delimiter\n...\n20 |         match\
    \ i {\n   |                 - unclosed delimiter\n...\n63 |             3 => {\n\
    \   |                  - this delimiter might not be properly closed...\n64 |\
    \                 roman.push_str(&\"m\".repeat(digit as\n65 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n83 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpf2m6sywo.rs:64:43\n  \
    \ |\n8  | fn int_to_mini_roman(number: isize) -> String {\n   |              \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n64 |                 roman.push_str(&\"m\".repeat(digit as\n   |        \
    \                                   ^ unclosed delimiter\n65 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected type, found `)`\n  --> /tmp/tmpf2m6sywo.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected type\n\nerror: expected identifier, found keyword\
    \ `fn`\n  --> /tmp/tmpf2m6sywo.rs:67:1\n   |\n67 | fn main() {\n   | ^^ expected\
    \ identifier, found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`,\
    \ found `main`\n  --> /tmp/tmpf2m6sywo.rs:67:4\n   |\n67 | fn main() {\n   | \
    \   ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf2m6sywo.rs:12:5\n   |\n8  |   fn int_to_mini_roman(number: isize)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n...\n12 | /     while num > 0 {\n13 | |         let\
    \ digit = num % 10;\n14 | |         num /= 10;\n15 | |         if digit == 0 {\n\
    ...  |\n82 | |     assert_eq!(candidate(1000), String::from(\"m\"));\n83 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        if digit > 0 {\n            result = mini_roman_digit(digit,\
    \ i) + &result;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp7irrylh8.rs:16:22\n   |\n16 |             result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                      ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = format!(\"{}{}\", mini_roman_digit(digit,\
    \ i), result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp06680p41.rs:15:34\n   |\n15 |         result = format!(\"{}{}\"\
    , mini_roman_digit(digit, i), result);\n   |                                 \
    \ ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut numeral_pairs = vec![\n        (1000, 'm'),\n       \
    \ (900, 'c'),\n        (500, 'd'),\n        (400, 'c'),\n        (100, 'c'),\n\
    \        (90, 'x'),\n        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n\
    \        (9, 'i'),\n        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n\
    \    ];\n    while number > 0 {\n        for (value, numeral) in numeral_pairs.iter_mut()\
    \ {\n            if number >= *value {\n                result.push(*numeral);\n\
    \                number -= *value;\n                break;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xi\"`,\n right: `\"xix\"`', /tmp/tmpozw0ymzw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        let roman_digit = match digit {\n            1 => \"i\",\n          \
    \  2 => \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n       \
    \     5 => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n     \
    \       8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n   \
    \     };\n        result = format!(\"{}{}\", roman_digit, result);\n        number\
    \ /= 10;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp4xoosrbs.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut symbols = vec![\n        (1000, 'm'),\n        (900, 'c'),\n    \
    \    (500, 'd'),\n        (400, 'c'),\n        (100, 'c'),\n        (90, 'x'),\n\
    \        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n        (9, 'i'),\n\
    \        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n    ];\n    while number\
    \ > 0 {\n        for (value, symbol) in symbols.iter() {\n            if number\
    \ >= *value {\n                number -= *value;\n                result.push(*symbol);\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xi\"`,\n right: `\"xix\"`', /tmp/tmpdqb9_deq.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp4wg868p6.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut numeral = 0;\n    let mut numeral_value = 0;\n    while\
    \ number > 0 {\n        numeral = number % 10;\n        numeral_value = numeral\
    \ * 10_isize.pow(result.len() as u32);\n        result = format!(\"{}{}\", mini_roman_numeral(numeral_value),\
    \ result);\n        number /= 10;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_numeral` in this scope\n\
    \  --> /tmp/tmp3x22s6y5.rs:16:34\n   |\n16 |         result = format!(\"{}{}\"\
    , mini_roman_numeral(numeral_value), result);\n   |                          \
    \        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut num_digits = 0;\n    while number > 0 {\n        let\
    \ digit = number % 10;\n        number /= 10;\n        num_digits += 1;\n    \
    \    result = match digit {\n            1 => format!(\"i{}\", result),\n    \
    \        2 => format!(\"ii{}\", result),\n            3 => format!(\"iii{}\",\
    \ result),\n            4 => format!(\"iv{}\", result),\n            5 => format!(\"\
    v{}\", result),\n            6 => format!(\"vi{}\", result),\n            7 =>\
    \ format!(\"vii{}\", result),\n            8 => format!(\"viii{}\", result),\n\
    \            9 => format!(\"ix{}\", result),\n            _ => result,\n     \
    \   };\n    }\n    match num_digits {\n        2 => result = format!(\"x{}\",\
    \ result),\n        3 => result = format!(\"c{}\", result),\n        4 => result\
    \ = format!(\"m{}\", result),\n        _ => (),\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xiix\"`,\n right: `\"xix\"`', /tmp/tmpyx8_zq4u.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    while number > 0 {\n        if number >= 1000 {\n            result.push('m');\n\
    \            number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmponninqon.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n\n    while number > 0 {\n        let mut\
    \ current_numeral = roman_numerals.pop().unwrap();\n        let (numeral, value)\
    \ = (current_numeral.0, current_numeral.1);\n\n        while number >= value {\n\
    \            result.push_str(numeral);\n            number -= value;\n       \
    \ }\n\n        if number >= value - roman_numerals.last().unwrap().1 {\n     \
    \       result.push_str(roman_numerals.last().unwrap().0);\n            result.push_str(numeral);\n\
    \            number -= value - roman_numerals.last().unwrap().1;\n        }\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp5smgoeq4.rs:30:52\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpsf635v61.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut remaining\
    \ = number;\n    let mut current_digit = 0;\n    let mut current_value = 1000;\n\
    \    while remaining > 0 {\n        let digit = remaining / current_value;\n \
    \       remaining = remaining % current_value;\n        current_digit += 1;\n\
    \        if digit > 0 {\n            result.push_str(&mini_roman_digit(digit,\
    \ current_digit));\n        }\n        current_value /= 10;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpiq2tcc3b.rs:18:30\n   |\n18 |             result.push_str(&mini_roman_digit(digit,\
    \ current_digit));\n   |                              ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    if digit == 4 {\n            result.insert(0, ROMAN_NUMERALS[i + 1]);\n \
    \           result.insert(0, ROMAN_NUMERALS[i]);\n        } else if digit == 9\
    \ {\n            result.insert(0, ROMAN_NUMERALS[i + 2]);\n            result.insert(0,\
    \ ROMAN_NUMERALS[i]);\n        } else if digit >= 5 {\n            result.insert(0,\
    \ ROMAN_NUMERALS[i + 1]);\n            for _ in 0..digit - 5 {\n             \
    \   result.insert(0, ROMAN_NUMERALS[i]);\n            }\n        } else {\n  \
    \          for _ in 0..digit {\n                result.insert(0, ROMAN_NUMERALS[i]);\n\
    \            }\n        }\n        num /= 10;\n        i += 2;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:15:30\n\
    \   |\n15 |             result.insert(0, ROMAN_NUMERALS[i + 1]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:16:30\n\
    \   |\n16 |             result.insert(0, ROMAN_NUMERALS[i]);\n   |           \
    \                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:18:30\n\
    \   |\n18 |             result.insert(0, ROMAN_NUMERALS[i + 2]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:19:30\n\
    \   |\n19 |             result.insert(0, ROMAN_NUMERALS[i]);\n   |           \
    \                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:21:30\n\
    \   |\n21 |             result.insert(0, ROMAN_NUMERALS[i + 1]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:23:34\n\
    \   |\n23 |                 result.insert(0, ROMAN_NUMERALS[i]);\n   |       \
    \                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpx9zi1ask.rs:27:34\n\
    \   |\n27 |                 result.insert(0, ROMAN_NUMERALS[i]);\n   |       \
    \                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            0 => \"\"\
    ,\n            1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\"\
    ,\n            4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\"\
    ,\n            7 => \"vii\",\n            8 => \"viii\",\n            9 => \"\
    ix\",\n            _ => panic!(\"Invalid digit: {}\", digit),\n        };\n  \
    \      result = format!(\"{}{}\", roman_digit, result);\n        i += 1;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpwk48hhp2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        let roman_digit = match digit {\n    \
    \        1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n  \
    \          4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n \
    \           7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\"\
    ,\n            _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpxt55q18i.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        if digit == 0 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut digit_str = String::new();\n        if digit <= 3\
    \ {\n            digit_str.push_str(&\"i\".repeat(digit as usize));\n        }\
    \ else if digit == 4 {\n            digit_str.push_str(\"iv\");\n        } else\
    \ if digit <= 8 {\n            digit_str.push_str(\"v\");\n            digit_str.push_str(&\"\
    i\".repeat((digit - 5) as usize));\n        } else {\n            digit_str.push_str(\"\
    ix\");\n        }\n        result.insert_str(0, &digit_str);\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmphxd00d98.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp9r1ljtwi.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut symbols = vec![\n        ('m', 1000),\n        ('d', 500),\n    \
    \    ('c', 100),\n        ('l', 50),\n        ('x', 10),\n        ('v', 5),\n\
    \        ('i', 1),\n    ];\n    while number > 0 {\n        let (symbol, value)\
    \ = symbols.pop().unwrap();\n        let count = number / value;\n        number\
    \ = number % value;\n        result.push_str(&symbol.to_string().repeat(count\
    \ as usize));\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmp1f0_rh3r.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let symbols = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n   \
    \     (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n        (\"\
    xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n\
    \        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"\
    i\", 1),\n    ];\n    for (symbol, value) in symbols {\n        while number >=\
    \ value {\n            result.push_str(symbol);\n            number -= value;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut roman = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        roman.push('m');\n        num -= 1000;\n   \
    \ }\n    if num >= 900 {\n        roman.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        roman.push('d');\n        num -= 500;\n \
    \   }\n    if num >= 400 {\n        roman.push_str(\"cd\");\n        num -= 400;\n\
    \    }\n    while num >= 100 {\n        roman.push('c');\n        num -= 100;\n\
    \    }\n    if num >= 90 {\n        roman.push_str(\"xc\");\n        num -= 90;\n\
    \    }\n    if num >= 50 {\n        roman.push('l');\n        num -= 50;\n   \
    \ }\n    if num >= 40 {\n        roman.push_str(\"xl\");\n        num -= 40;\n\
    \    }\n    while num >= 10 {\n        roman.push('x');\n        num -= 10;\n\
    \    }\n    if num >= 9 {\n        roman.push_str(\"ix\");\n        num -= 9;\n\
    \    }\n    if num >= 5 {\n        roman.push('v');\n        num -= 5;\n    }\n\
    \    if num >= 4 {\n        roman.push_str(\"iv\");\n        num -= 4;\n    }\n\
    \    while num >= 1 {\n        roman.push('i');\n        num -= 1;\n    }\n  \
    \  roman\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut roman = String::new();\n\
    \    let mut numeral_values = vec![\n        (1000, \"m\"),\n        (900, \"\
    cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n\
    \        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10,\
    \ \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n \
    \       (1, \"i\"),\n    ];\n    while number > 0 {\n        for (value, numeral)\
    \ in numeral_values.iter() {\n            if number >= *value {\n            \
    \    roman.push_str(numeral);\n                number -= *value;\n           \
    \     break;\n            }\n        }\n    }\n    roman\n}\n\nfn main() {\n \
    \   let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    while number > 0 {\n        if number >= 1000 {\n            result.push('m');\n\
    \            number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_map = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n    while number > 0 {\n        let (numeral,\
    \ value) = numeral_map.pop().unwrap();\n        let mut count = number / value;\n\
    \        number = number % value;\n        if count == 4 {\n            result.push_str(numeral);\n\
    \            result.push_str(&numeral_map.last().unwrap().0);\n        } else\
    \ {\n            for _ in 0..count {\n                result.push_str(numeral);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmpw5570a07.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp8zs9pysv.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpr9auddex.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut num_to_roman = |num, roman| {\n        while number >= num {\n  \
    \          result.push_str(roman);\n            number -= num;\n        }\n  \
    \  };\n    num_to_roman(1000, \"m\");\n    num_to_roman(900, \"cm\");\n    num_to_roman(500,\
    \ \"d\");\n    num_to_roman(400, \"cd\");\n    num_to_roman(100, \"c\");\n   \
    \ num_to_roman(90, \"xc\");\n    num_to_roman(50, \"l\");\n    num_to_roman(40,\
    \ \"xl\");\n    num_to_roman(10, \"x\");\n    num_to_roman(9, \"ix\");\n    num_to_roman(5,\
    \ \"v\");\n    num_to_roman(4, \"iv\");\n    num_to_roman(1, \"i\");\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n\n    while number > 0 {\n        let (numeral,\
    \ value) = roman_numerals.pop().unwrap();\n        let mut count = number / value;\n\
    \        number %= value;\n\n        if count == 4 && !result.is_empty() {\n \
    \           let last_char = result.pop().unwrap();\n            result.push_str(numeral);\n\
    \            result.push(match last_char {\n                'i' => 'v',\n    \
    \            'x' => 'l',\n                'c' => 'd',\n                _ => last_char,\n\
    \            });\n        } else {\n            while count > 0 {\n          \
    \      result.push_str(numeral);\n                count -= 1;\n            }\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmp_83zl_ly.rs:48:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut num_to_roman = |num, roman| {\n        while number >= num {\n  \
    \          result.push_str(roman);\n            number -= num;\n        }\n  \
    \  };\n    num_to_roman(1000, \"m\");\n    num_to_roman(900, \"cm\");\n    num_to_roman(500,\
    \ \"d\");\n    num_to_roman(400, \"cd\");\n    num_to_roman(100, \"c\");\n   \
    \ num_to_roman(90, \"xc\");\n    num_to_roman(50, \"l\");\n    num_to_roman(40,\
    \ \"xl\");\n    num_to_roman(10, \"x\");\n    num_to_roman(9, \"ix\");\n    num_to_roman(5,\
    \ \"v\");\n    num_to_roman(4, \"iv\");\n    num_to_roman(1, \"i\");\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            1 => \"\
    i\",\n            2 => \"ii\",\n            3 => \"iii\",\n            4 => \"\
    iv\",\n            5 => \"v\",\n            6 => \"vi\",\n            7 => \"\
    vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n            _ =>\
    \ \"\"\n        };\n        result = format!(\"{}{}\", roman_digit, result);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp65__a7p4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number >= 1000 {\n        result.push('m');\n        number\
    \ -= 1000;\n    }\n    if number >= 900 {\n        result.push_str(\"cm\");\n\
    \        number -= 900;\n    }\n    if number >= 500 {\n        result.push('d');\n\
    \        number -= 500;\n    }\n    if number >= 400 {\n        result.push_str(\"\
    cd\");\n        number -= 400;\n    }\n    while number >= 100 {\n        result.push('c');\n\
    \        number -= 100;\n    }\n    if number >= 90 {\n        result.push_str(\"\
    xc\");\n        number -= 90;\n    }\n    if number >= 50 {\n        result.push('l');\n\
    \        number -= 50;\n    }\n    if number >= 40 {\n        result.push_str(\"\
    xl\");\n        number -= 40;\n    }\n    while number >= 10 {\n        result.push('x');\n\
    \        number -= 10;\n    }\n    if number >= 9 {\n        result.push_str(\"\
    ix\");\n        number -= 9;\n    }\n    if number >= 5 {\n        result.push('v');\n\
    \        number -= 5;\n    }\n    if number >= 4 {\n        result.push_str(\"\
    iv\");\n        number -= 4;\n    }\n    while number >= 1 {\n        result.push('i');\n\
    \        number -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp0prhfvu7.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        match digit {\n            1 => result.push_str(ROMAN_DIGITS[i][0]),\n\
    \            2 => result.push_str(ROMAN_DIGITS[i][0]),\n            3 => result.push_str(ROMAN_DIGITS[i][0]),\n\
    \            4 => result.push_str(ROMAN_DIGITS[i][1]),\n            5 => result.push_str(ROMAN_DIGITS[i][2]),\n\
    \            6 => result.push_str(ROMAN_DIGITS[i][2]),\n            7 => result.push_str(ROMAN_DIGITS[i][2]),\n\
    \            8 => result.push_str(ROMAN_DIGITS[i][2]),\n            9 => result.push_str(ROMAN_DIGITS[i][3]),\n\
    \            _ => (),\n        }\n        i += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:16:34\n\
    \   |\n16 |             1 => result.push_str(ROMAN_DIGITS[i][0]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:17:34\n\
    \   |\n17 |             2 => result.push_str(ROMAN_DIGITS[i][0]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:18:34\n\
    \   |\n18 |             3 => result.push_str(ROMAN_DIGITS[i][0]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:19:34\n\
    \   |\n19 |             4 => result.push_str(ROMAN_DIGITS[i][1]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:20:34\n\
    \   |\n20 |             5 => result.push_str(ROMAN_DIGITS[i][2]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:21:34\n\
    \   |\n21 |             6 => result.push_str(ROMAN_DIGITS[i][2]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:22:34\n\
    \   |\n22 |             7 => result.push_str(ROMAN_DIGITS[i][2]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:23:34\n\
    \   |\n23 |             8 => result.push_str(ROMAN_DIGITS[i][2]),\n   |      \
    \                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxesyjrlc.rs:24:34\n\
    \   |\n24 |             9 => result.push_str(ROMAN_DIGITS[i][3]),\n   |      \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        if digit == 0 {\n            i += 1;\n            continue;\n\
    \        }\n        let roman_digit = match i {\n            0 => match digit\
    \ {\n                1 => 'i',\n                2 => 'ii',\n                3\
    \ => 'iii',\n                4 => 'iv',\n                5 => 'v',\n         \
    \       6 => 'vi',\n                7 => 'vii',\n                8 => 'viii',\n\
    \                9 => 'ix',\n                _ => '',\n            },\n      \
    \      1 => match digit {\n                1 => 'x',\n                2 => 'xx',\n\
    \                3 => 'xxx',\n                4 => 'xl',\n                5 =>\
    \ 'l',\n                6 => 'lx',\n                7 => 'lxx',\n            \
    \    8 => 'lxxx',\n                9 => 'xc',\n                _ => '',\n    \
    \        },\n            2 => match digit {\n                1 => 'c',\n     \
    \           2 => 'cc',\n                3 => 'ccc',\n                4 => 'cd',\n\
    \                5 => 'd',\n                6 => 'dc',\n                7 => 'dcc',\n\
    \                8 => 'dccc',\n                9 => 'cm',\n                _ =>\
    \ '',\n            },\n            3 => match digit {\n                1 => 'm',\n\
    \                2 => 'mm',\n                3 => 'mmm',\n                _ =>\
    \ '',\n            },\n            _ => '',\n        };\n        result.push(roman_digit);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:22:22\n\
    \   |\n22 |                 2 => 'ii',\n   |                      ^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n22 |   \
    \              2 => \"ii\",\n   |                      ~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:23:22\n  \
    \ |\n23 |                 3 => 'iii',\n   |                      ^^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n23 |   \
    \              3 => \"iii\",\n   |                      ~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:24:22\n  \
    \ |\n24 |                 4 => 'iv',\n   |                      ^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n24 |       \
    \          4 => \"iv\",\n   |                      ~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:26:22\n   |\n26 |\
    \                 6 => 'vi',\n   |                      ^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n26 |              \
    \   6 => \"vi\",\n   |                      ~~~~\n\nerror: character literal may\
    \ only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:27:22\n   |\n27 |    \
    \             7 => 'vii',\n   |                      ^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n27 |              \
    \   7 => \"vii\",\n   |                      ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:28:22\n   |\n28 |\
    \                 8 => 'viii',\n   |                      ^^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n28 |       \
    \          8 => \"viii\",\n   |                      ~~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmptvnb1hw0.rs:29:22\n  \
    \ |\n29 |                 9 => 'ix',\n   |                      ^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n29 |       \
    \          9 => \"ix\",\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        result = match digit {\n            0\
    \ => result,\n            1 => format!(\"{}{}\", ROMAN_DIGITS[i][0], result),\n\
    \            2 => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \            3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n            4 => format!(\"{}{}\", ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][1]),\n            5 => format!(\"{}\", ROMAN_DIGITS[i][1]),\n\
    \            6 => format!(\"{}{}\", ROMAN_DIGITS[i][1], ROMAN_DIGITS[i][0]),\n\
    \            7 => format!(\"{}{}{}\", ROMAN_DIGITS[i][1], ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n            8 => format!(\"{}{}{}{}\", ROMAN_DIGITS[i][1],\
    \ ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n            9\
    \ => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][2]),\n            _\
    \ => panic!(\"Invalid digit: {}\", digit),\n        };\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:17:34\n\
    \   |\n17 |             1 => format!(\"{}{}\", ROMAN_DIGITS[i][0], result),\n\
    \   |                                  ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:18:34\n\
    \   |\n18 |             2 => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                  ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:18:54\n\
    \   |\n18 |             2 => format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                                      ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n\
    \  --> /tmp/tmpzhn1wpfg.rs:19:36\n   |\n19 |             3 => format!(\"{}{}{}\"\
    , ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n   |         \
    \                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:19:56\n\
    \   |\n19 |             3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0],\
    \ ROMAN_DIGITS[i][0]),\n   |                                                 \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:19:76\n   |\n19 |  \
    \           3 => format!(\"{}{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][0]),\n\
    \   |                                                                        \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS`\
    \ in this scope\n  --> /tmp/tmpzhn1wpfg.rs:20:34\n   |\n20 |             4 =>\
    \ format!(\"{}{}\", ROMAN_DIGITS[i][0], ROMAN_DIGITS[i][1]),\n   |           \
    \                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpzhn1wpfg.rs:20:54\n\
    \   |\n20 |             4 => format!(\"{}{}\", R"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\",\
    \ 900),\n        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n\
    \        (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"\
    x\", 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n \
    \       (\"i\", 1),\n    ];\n    while number > 0 {\n        let (numeral, value)\
    \ = roman_numerals.pop().unwrap();\n        while number >= value {\n        \
    \    result.push_str(numeral);\n            number -= value;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmpftcms9g0.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpd91q7260.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        if digit == 0 {\n            i += 1;\n            continue;\n\
    \        }\n        let roman_digit = match i {\n            0 => match digit\
    \ {\n                1 => \"i\",\n                2 => \"ii\",\n             \
    \   3 => \"iii\",\n                4 => \"iv\",\n                5 => \"v\",\n\
    \                6 => \"vi\",\n                7 => \"vii\",\n               \
    \ 8 => \"viii\",\n                9 => \"ix\",\n                _ => \"\",\n \
    \           },\n            1 => match digit {\n                1 => \"x\",\n\
    \                2 => \"xx\",\n                3 => \"xxx\",\n               \
    \ 4 => \"xl\",\n                5 => \"l\",\n                6 => \"lx\",\n  \
    \              7 => \"lxx\",\n                8 => \"lxxx\",\n               \
    \ 9 => \"xc\",\n                _ => \"\",\n            },\n            2 => match\
    \ digit {\n                1 => \"c\",\n                2 => \"cc\",\n       \
    \         3 => \"ccc\",\n                4 => \"cd\",\n                5 => \"\
    d\",\n                6 => \"dc\",\n                7 => \"dcc\",\n          \
    \      8 => \"dccc\",\n                9 => \"cm\",\n                _ => \"\"\
    ,\n            },\n            3 => match digit {\n                1 => \"m\"\
    ,\n                2 => \"mm\",\n                3 => \"mmm\",\n             \
    \   _ => \"\",\n            },\n            _ => \"\",\n        };\n        result.insert_str(0,\
    \ roman_digit);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        if digit == 4 {\n            result.insert(0, ROMAN_NUMERALS[i + 1]);\n\
    \            result.insert(0, ROMAN_NUMERALS[i]);\n        } else if digit ==\
    \ 9 {\n            result.insert(0, ROMAN_NUMERALS[i + 2]);\n            result.insert(0,\
    \ ROMAN_NUMERALS[i]);\n        } else if digit < 4 {\n            for _ in 0..digit\
    \ {\n                result.insert(0, ROMAN_NUMERALS[i]);\n            }\n   \
    \     } else {\n            result.insert(0, ROMAN_NUMERALS[i + 1]);\n       \
    \     for _ in 0..(digit - 5) {\n                result.insert(0, ROMAN_NUMERALS[i]);\n\
    \            }\n        }\n        number /= 10;\n        i += 2;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:15:30\n\
    \   |\n15 |             result.insert(0, ROMAN_NUMERALS[i + 1]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:16:30\n\
    \   |\n16 |             result.insert(0, ROMAN_NUMERALS[i]);\n   |           \
    \                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:18:30\n\
    \   |\n18 |             result.insert(0, ROMAN_NUMERALS[i + 2]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:19:30\n\
    \   |\n19 |             result.insert(0, ROMAN_NUMERALS[i]);\n   |           \
    \                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:22:34\n\
    \   |\n22 |                 result.insert(0, ROMAN_NUMERALS[i]);\n   |       \
    \                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:25:30\n\
    \   |\n25 |             result.insert(0, ROMAN_NUMERALS[i + 1]);\n   |       \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmppl8ol1l5.rs:27:34\n\
    \   |\n27 |                 result.insert(0, ROMAN_NUMERALS[i]);\n   |       \
    \                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpzmjyvui1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp2ggxt2w_.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut num = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (roman, arabic) in roman_numerals {\n      \
    \  while num >= arabic {\n            result.push_str(roman);\n            num\
    \ -= arabic;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_map = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n    while number > 0 {\n        let (numeral,\
    \ value) = numeral_map.pop().unwrap();\n        let mut count = number / value;\n\
    \        number %= value;\n        if count == 4 {\n            result.push_str(numeral);\n\
    \            result.push_str(&numeral_map.last().unwrap().0);\n        } else\
    \ {\n            for _ in 0..count {\n                result.push_str(numeral);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmp2mkm01cd.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp7j68cf5m.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        if digit == 9 {\n            result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n\
    \            result.push_str(&MINI_ROMAN_DIGITS[i]);\n        } else if digit\
    \ == 4 {\n            result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n          \
    \  result.push_str(&MINI_ROMAN_DIGITS[i]);\n        } else if digit >= 5 {\n \
    \           result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n            for _ in\
    \ 0..digit - 5 {\n                result.push_str(&MINI_ROMAN_DIGITS[i]);\n  \
    \          }\n        } else {\n            for _ in 0..digit {\n            \
    \    result.push_str(&MINI_ROMAN_DIGITS[i]);\n            }\n        }\n     \
    \   number /= 10;\n        i += 2;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n  -->\
    \ /tmp/tmpxh0x2cap.rs:15:30\n   |\n15 |             result.push_str(&MINI_ROMAN_DIGITS[i\
    \ + 1]);\n   |                              ^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n\
    \  --> /tmp/tmpxh0x2cap.rs:16:30\n   |\n16 |             result.push_str(&MINI_ROMAN_DIGITS[i]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxh0x2cap.rs:18:30\n\
    \   |\n18 |             result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n   |    \
    \                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxh0x2cap.rs:19:30\n\
    \   |\n19 |             result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |        \
    \                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxh0x2cap.rs:21:30\n\
    \   |\n21 |             result.push_str(&MINI_ROMAN_DIGITS[i + 1]);\n   |    \
    \                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxh0x2cap.rs:23:34\n\
    \   |\n23 |                 result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MINI_ROMAN_DIGITS` in this scope\n  --> /tmp/tmpxh0x2cap.rs:27:34\n\
    \   |\n27 |                 result.push_str(&MINI_ROMAN_DIGITS[i]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            1 => \"\
    i\",\n            2 => \"ii\",\n            3 => \"iii\",\n            4 => \"\
    iv\",\n            5 => \"v\",\n            6 => \"vi\",\n            7 => \"\
    vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n            _ =>\
    \ \"\",\n        };\n        result = format!(\"{}{}\", roman_digit, result);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmppea0oo61.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let (one, five, ten) = match i {\n            0 => ('i',\
    \ 'v', 'x'),\n            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n\
    \            3 => ('m', 'v', 'x'),\n            _ => panic!(\"number too large\"\
    ),\n        };\n        match digit {\n            1 => result.push(one),\n  \
    \          2 => result.push_str(&[one, one].iter().collect::<String>()),\n   \
    \         3 => result.push_str(&[one, one, one].iter().collect::<String>()),\n\
    \            4 => result.push_str(&[one, five].iter().collect::<String>()),\n\
    \            5 => result.push(five),\n            6 => result.push_str(&[five,\
    \ one].iter().collect::<String>()),\n            7 => result.push_str(&[five,\
    \ one, one].iter().collect::<String>()),\n            8 => result.push_str(&[five,\
    \ one, one, one].iter().collect::<String>()),\n            9 => result.push_str(&[one,\
    \ ten].iter().collect::<String>()),\n            _ => (),\n        }\n       \
    \ i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ixx\"`,\n right: `\"xix\"`', /tmp/tmpc2wa84oh.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            1 => \"\
    i\",\n            2 => \"ii\",\n            3 => \"iii\",\n            4 => \"\
    iv\",\n            5 => \"v\",\n            6 => \"vi\",\n            7 => \"\
    vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n            _ =>\
    \ \"\",\n        };\n        result = format!(\"{}{}\", roman_digit, result);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp0zw8ia9o.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number >= 1000 {\n        result.push('m');\n        number\
    \ -= 1000;\n    }\n    if number >= 900 {\n        result.push_str(\"cm\");\n\
    \        number -= 900;\n    }\n    if number >= 500 {\n        result.push('d');\n\
    \        number -= 500;\n    }\n    if number >= 400 {\n        result.push_str(\"\
    cd\");\n        number -= 400;\n    }\n    while number >= 100 {\n        result.push('c');\n\
    \        number -= 100;\n    }\n    if number >= 90 {\n        result.push_str(\"\
    xc\");\n        number -= 90;\n    }\n    if number >= 50 {\n        result.push('l');\n\
    \        number -= 50;\n    }\n    if number >= 40 {\n        result.push_str(\"\
    xl\");\n        number -= 40;\n    }\n    while number >= 10 {\n        result.push('x');\n\
    \        number -= 10;\n    }\n    if number >= 9 {\n        result.push_str(\"\
    ix\");\n        number -= 9;\n    }\n    if number >= 5 {\n        result.push('v');\n\
    \        number -= 5;\n    }\n    if number >= 4 {\n        result.push_str(\"\
    iv\");\n        number -= 4;\n    }\n    while number >= 1 {\n        result.push('i');\n\
    \        number -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmposfojy0l.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut roman = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        roman = roman_digit.to_string() + &roman;\n\
    \        i += 1;\n    }\n    roman\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpsqelpaiy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    while number > 0 {\n        if number >= 1000 {\n            result.push('m');\n\
    \            number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        if digit > 0 {\n            result.insert_str(0, &mini_roman_digit(digit,\
    \ i));\n        }\n        number /= 10;\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp5wdxdlol.rs:15:35\n   |\n15 |             result.insert_str(0, &mini_roman_digit(digit,\
    \ i));\n   |                                   ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpjycpqkvs.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut symbols = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n    while number > 0 {\n        let (symbol,\
    \ value) = symbols.pop().unwrap();\n        let count = number / value;\n    \
    \    number %= value;\n        result.push_str(&symbol.repeat(count as usize));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmpc0_demgo.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_pairs = vec![\n        (1000, \"m\"),\n        (900, \"cm\"\
    ),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n   \
    \     (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10,\
    \ \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n \
    \       (1, \"i\"),\n    ];\n    while number > 0 {\n        let (numeral_value,\
    \ numeral_string) = numeral_pairs.pop().unwrap();\n        while number >= numeral_value\
    \ {\n            result.push_str(numeral_string);\n            number -= numeral_value;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iiiiiiiiiiiiiiiiiii\"`,\n right: `\"xix\"`', /tmp/tmp9tllap5f.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpkaq7rfvv.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpeoqecqed.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut digit = 0;\n    while number > 0 {\n        let digit_value = 10_isize.pow(digit);\n\
    \        let digit_char = match number / digit_value {\n            0 => ' ',\n\
    \            1 => 'i',\n            2 => 'x',\n            3 => 'c',\n       \
    \     4 => 'm',\n            _ => panic!(\"Invalid digit value: {}\", number /\
    \ digit_value),\n        };\n        let digit_count = number / digit_value;\n\
    \        if digit_count == 4 {\n            result.push(digit_char);\n       \
    \     result.push(match digit_char {\n                'i' => 'v',\n          \
    \      'x' => 'l',\n                'c' => 'd',\n                _ => panic!(\"\
    Invalid digit value: {}\", digit_char),\n            });\n        } else if digit_count\
    \ == 9 {\n            result.push(digit_char);\n            result.push(match\
    \ digit_char {\n                'i' => 'x',\n                'x' => 'c',\n   \
    \             'c' => 'm',\n                _ => panic!(\"Invalid digit value:\
    \ {}\", digit_char),\n            });\n        } else {\n            for _ in\
    \ 0..digit_count {\n                result.push(digit_char);\n            }\n\
    \        }\n        number %= digit_value;\n        digit += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'Invalid digit value: 19', /tmp/tmpvvx6g3rp.rs:20:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (roman, arabic) in roman_numerals {\n      \
    \  while number >= *arabic {\n            result.push_str(roman);\n          \
    \  number -= arabic;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp3njy89pu.rs:27:25\n\
    \   |\n27 |         while number >= *arabic {\n   |                         ^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (numeral, value) in roman_numerals.iter() {\n\
    \        while number >= *value {\n            result.push_str(numeral);\n   \
    \         number -= *value;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmplqmlarui.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let (one, five, ten) = match i {\n            0 => ('i',\
    \ 'v', 'x'),\n            1 => ('x', 'l', 'c'),\n            2 => ('c', 'd', 'm'),\n\
    \            3 => ('m', '?', '?'),\n            _ => panic!(\"Number too large\"\
    ),\n        };\n        if digit == 9 {\n            result.push(ten);\n     \
    \       result.push(one);\n        } else if digit >= 5 {\n            result.push(five);\n\
    \            for _ in 0..(digit - 5) {\n                result.push(one);\n  \
    \          }\n        } else if digit == 4 {\n            result.push(one);\n\
    \            result.push(five);\n        } else {\n            for _ in 0..digit\
    \ {\n                result.push(one);\n            }\n        }\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iilc\"`,\n right: `\"clii\"`', /tmp/tmpuhs2wp2s.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (numeral, value) in roman_numerals.iter() {\n\
    \        while number >= *value {\n            result.push_str(numeral);\n   \
    \         number -= *value;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        if digit == 0 {\n            i += 1;\n            continue;\n\
    \        }\n        let roman_digit = match i {\n            0 => match digit\
    \ {\n                1 => \"i\",\n                2 => \"ii\",\n             \
    \   3 => \"iii\",\n                4 => \"iv\",\n                5 => \"v\",\n\
    \                6 => \"vi\",\n                7 => \"vii\",\n               \
    \ 8 => \"viii\",\n                9 => \"ix\",\n                _ => \"\",\n \
    \           },\n            1 => match digit {\n                1 => \"x\",\n\
    \                2 => \"xx\",\n                3 => \"xxx\",\n               \
    \ 4 => \"xl\",\n                5 => \"l\",\n                6 => \"lx\",\n  \
    \              7 => \"lxx\",\n                8 => \"lxxx\",\n               \
    \ 9 => \"xc\",\n                _ => \"\",\n            },\n            2 => match\
    \ digit {\n                1 => \"c\",\n                2 => \"cc\",\n       \
    \         3 => \"ccc\",\n                4 => \"cd\",\n                5 => \"\
    d\",\n                6 => \"dc\",\n                7 => \"dcc\",\n          \
    \      8 => \"dccc\",\n                9 => \"cm\",\n                _ => \"\"\
    ,\n            },\n            3 => match digit {\n                1 => \"m\"\
    ,\n                2 => \"mm\",\n                3 => \"mmm\",\n             \
    \   _ => \"\",\n            },\n            _ => \"\",\n        };\n        result.insert_str(0,\
    \ roman_digit);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let symbols = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n   \
    \     (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n        (\"\
    xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\", 10),\n\
    \        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n        (\"\
    i\", 1),\n    ];\n    for (symbol, value) in symbols {\n        while number >=\
    \ value {\n            result.push_str(symbol);\n            number -= value;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut roman = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            roman.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            roman.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            roman.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            roman.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            roman.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            roman.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            roman.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            roman.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            roman.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            roman.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            roman.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            roman.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            roman.push('i');\n\
    \            num -= 1;\n        }\n    }\n    roman\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut digit = 0;\n    while number > 0 {\n        let digit_value\
    \ = number % 10;\n        number /= 10;\n        digit += 1;\n        result =\
    \ match digit {\n            1 => mini_roman_digit(digit_value, 'i', 'v', 'x'),\n\
    \            2 => mini_roman_digit(digit_value, 'x', 'l', 'c'),\n            3\
    \ => mini_roman_digit(digit_value, 'c', 'd', 'm'),\n            4 => mini_roman_digit(digit_value,\
    \ 'm', 'm', 'm'),\n            _ => panic!(\"number too large\"),\n        } +\
    \ &result;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpvg1gth5f.rs:17:18\n   |\n17 |             1 => mini_roman_digit(digit_value,\
    \ 'i', 'v', 'x'),\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `mini_roman_digit` in this scope\n  --> /tmp/tmpvg1gth5f.rs:18:18\n\
    \   |\n18 |             2 => mini_roman_digit(digit_value, 'x', 'l', 'c'),\n \
    \  |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `mini_roman_digit` in this scope\n  --> /tmp/tmpvg1gth5f.rs:19:18\n\
    \   |\n19 |             3 => mini_roman_digit(digit_value, 'c', 'd', 'm'),\n \
    \  |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `mini_roman_digit` in this scope\n  --> /tmp/tmpvg1gth5f.rs:20:18\n\
    \   |\n20 |             4 => mini_roman_digit(digit_value, 'm', 'm', 'm'),\n \
    \  |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            1 => 'i',\n\
    \            2 => 'ii',\n            3 => 'iii',\n            4 => 'iv',\n   \
    \         5 => 'v',\n            6 => 'vi',\n            7 => 'vii',\n       \
    \     8 => 'viii',\n            9 => 'ix',\n            _ => '',\n        };\n\
    \        result = format!(\"{}{}\", roman_digit, result);\n        i += 1;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpgbc0mu00.rs:17:18\n\
    \   |\n17 |             2 => 'ii',\n   |                  ^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n17 |          \
    \   2 => \"ii\",\n   |                  ~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpgbc0mu00.rs:18:18\n   |\n18 |         \
    \    3 => 'iii',\n   |                  ^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n18 |             3 => \"iii\",\n \
    \  |                  ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpgbc0mu00.rs:19:18\n   |\n19 |             4 => 'iv',\n   |    \
    \              ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n19 |             4 => \"iv\",\n   |                  ~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmpgbc0mu00.rs:21:18\n\
    \   |\n21 |             6 => 'vi',\n   |                  ^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n21 |          \
    \   6 => \"vi\",\n   |                  ~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpgbc0mu00.rs:22:18\n   |\n22 |         \
    \    7 => 'vii',\n   |                  ^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n22 |             7 => \"vii\",\n \
    \  |                  ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmpgbc0mu00.rs:23:18\n   |\n23 |             8 => 'viii',\n   |  \
    \                ^^^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n23 |             8 => \"viii\",\n   |                 \
    \ ~~~~~~\n\nerror: character literal may only contain one codepoint\n  --> /tmp/tmpgbc0mu00.rs:24:18\n\
    \   |\n24 |             9 => 'ix',\n   |                  ^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n24 |          \
    \   9 => \"ix\",\n   |                  ~~~~\n\nerror: empty character literal\n\
    \  --> /tmp/tmpgbc0mu00.rs:25:19\n   |\n25 |             _ => '',"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut roman = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            roman.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            roman.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            roman.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            roman.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            roman.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            roman.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            roman.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            roman.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            roman.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            roman.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            roman.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            roman.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            roman.push('i');\n\
    \            num -= 1;\n        }\n    }\n    roman\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        let roman_digit = match digit {\n            1 => \"\
    i\",\n            2 => \"ii\",\n            3 => \"iii\",\n            4 => \"\
    iv\",\n            5 => \"v\",\n            6 => \"vi\",\n            7 => \"\
    vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n            _ =>\
    \ \"\",\n        };\n        result = format!(\"{}{}\", roman_digit, result);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp2jalmvay.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        let roman_digit = match digit {\n    \
    \        1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n  \
    \          4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n \
    \           7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\"\
    ,\n            _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpykl6obp6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp_umiinwe.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\",\
    \ 900),\n        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n\
    \        (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"\
    x\", 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n \
    \       (\"i\", 1),\n    ];\n    while number > 0 {\n        for (numeral, value)\
    \ in roman_numerals.iter() {\n            if number >= *value {\n            \
    \    result.push_str(numeral);\n                number -= *value;\n          \
    \      break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    num /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpgsr_fk6m.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        if digit > 0 {\n            result.insert_str(0, &mini_roman_digit(digit,\
    \ i));\n        }\n        number /= 10;\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpc9kp2ina.rs:15:35\n   |\n15 |             result.insert_str(0, &mini_roman_digit(digit,\
    \ i));\n   |                                   ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        result = mini_roman_digit(digit, i) +\
    \ &result;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp_eabl0c8.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    while number > 0 {\n        if number >= 1000 {\n            result.push('m');\n\
    \            number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp41hw3i1r.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp_gtoygho.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = mini_roman_digit(digit, i) + &result;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp0uvrggn5.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    let mut i = 0;\n    while num > 0 {\n        let digit = num % 10;\n    \
    \    let roman_digit = match digit {\n            1 => \"i\",\n            2 =>\
    \ \"ii\",\n            3 => \"iii\",\n            4 => \"iv\",\n            5\
    \ => \"v\",\n            6 => \"vi\",\n            7 => \"vii\",\n           \
    \ 8 => \"viii\",\n            9 => \"ix\",\n            _ => \"\",\n        };\n\
    \        result = roman_digit.to_string() + &result;\n        num /= 10;\n   \
    \     i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpy2ckwe_4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut index = 0;\n    while number > 0 {\n        let digit\
    \ = number % 10;\n        number /= 10;\n        let roman_digit = match digit\
    \ {\n            1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\"\
    ,\n            4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\"\
    ,\n            7 => \"vii\",\n            8 => \"viii\",\n            9 => \"\
    ix\",\n            _ => \"\",\n        };\n        result = format!(\"{}{}\",\
    \ roman_digit, result);\n        index += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpn1jja_ba.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut digit = 0;\n    while number > 0 {\n        let digit_value\
    \ = number % 10;\n        number /= 10;\n        let mut digit_string = String::new();\n\
    \        if digit_value == 9 {\n            digit_string.push(match digit {\n\
    \                0 => 'i',\n                1 => 'x',\n                2 => 'c',\n\
    \                3 => 'm',\n                _ => panic!(\"Invalid digit: {}\"\
    , digit),\n            });\n            digit_string.push(match digit {\n    \
    \            0 => 'x',\n                1 => 'c',\n                2 => 'm',\n\
    \                3 => 'm',\n                _ => panic!(\"Invalid digit: {}\"\
    , digit),\n            });\n        } else if digit_value == 4 {\n           \
    \ digit_string.push(match digit {\n                0 => 'i',\n               \
    \ 1 => 'x',\n                2 => 'c',\n                3 => 'm',\n          \
    \      _ => panic!(\"Invalid digit: {}\", digit),\n            });\n         \
    \   digit_string.push(match digit {\n                0 => 'v',\n             \
    \   1 => 'l',\n                2 => 'd',\n                3 => 'm',\n        \
    \        _ => panic!(\"Invalid digit: {}\", digit),\n            });\n       \
    \ } else {\n            if digit_value >= 5 {\n                digit_string.push(match\
    \ digit {\n                    0 => 'v',\n                    1 => 'l',\n    \
    \                2 => 'd',\n                    3 => 'm',\n                  \
    \  _ => panic!(\"Invalid digit: {}\", digit),\n                });\n         \
    \       digit_value -= 5;\n            }\n            for _ in 0..digit_value\
    \ {\n                digit_string.push(match digit {\n                    0 =>\
    \ 'i',\n                    1 => 'x',\n                    2 => 'c',\n       \
    \             3 => 'm',\n                    _ => panic!(\"Invalid digit: {}\"\
    , digit),\n                });\n            }\n        }\n        result = digit_string\
    \ + &result;\n        digit += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `digit_value`\n\
    \  --> /tmp/tmpijmaayzz.rs:55:17\n   |\n13 |         let digit_value = number\
    \ % 10;\n   |             -----------\n   |             |\n   |             first\
    \ assignment to `digit_value`\n   |             help: consider making this binding\
    \ mutable: `mut digit_value`\n...\n55 |                 digit_value -= 5;\n  \
    \ |                 ^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut digit = 0;\n    while number > 0 {\n        let digit_value\
    \ = number % 10;\n        number /= 10;\n        match digit {\n            0\
    \ => {\n                result = mini_roman_digit(digit_value, 'i', 'v', 'x')\
    \ + &result;\n            }\n            1 => {\n                result = mini_roman_digit(digit_value,\
    \ 'x', 'l', 'c') + &result;\n            }\n            2 => {\n             \
    \   result = mini_roman_digit(digit_value, 'c', 'd', 'm') + &result;\n       \
    \     }\n            3 => {\n                result = mini_roman_digit(digit_value,\
    \ 'm', 'v', 'x') + &result;\n            }\n            _ => {}\n        }\n \
    \       digit += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmp3am_mc4b.rs:17:26\n   |\n17 |                 result = mini_roman_digit(digit_value,\
    \ 'i', 'v', 'x') + &result;\n   |                          ^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `mini_roman_digit`\
    \ in this scope\n  --> /tmp/tmp3am_mc4b.rs:20:26\n   |\n20 |                 result\
    \ = mini_roman_digit(digit_value, 'x', 'l', 'c') + &result;\n   |            \
    \              ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `mini_roman_digit` in this scope\n  --> /tmp/tmp3am_mc4b.rs:23:26\n\
    \   |\n23 |                 result = mini_roman_digit(digit_value, 'c', 'd', 'm')\
    \ + &result;\n   |                          ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `mini_roman_digit` in this scope\n\
    \  --> /tmp/tmp3am_mc4b.rs:26:26\n   |\n26 |                 result = mini_roman_digit(digit_value,\
    \ 'm', 'v', 'x') + &result;\n   |                          ^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmprls27m14.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        let roman_digit = match digit {\n    \
    \        1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n  \
    \          4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n \
    \           7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\"\
    ,\n            _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp7wiaaljs.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let digits = vec![\n        (1000, 'm'),\n        (900, 'c'),\n\
    \        (500, 'd'),\n        (400, 'c'),\n        (100, 'c'),\n        (90, 'x'),\n\
    \        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n        (9, 'i'),\n\
    \        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n    ];\n    for (digit,\
    \ letter) in digits {\n        while number >= digit {\n            result.push(letter);\n\
    \            number -= digit;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xi\"`,\n right: `\"xix\"`', /tmp/tmpziur5qrr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let (one, five, ten) = match i {\n           \
    \ 0 => ('i', 'v', 'x'),\n            1 => ('x', 'l', 'c'),\n            2 => ('c',\
    \ 'd', 'm'),\n            3 => ('m', 'v', 'x'),\n            _ => panic!(\"Number\
    \ too large\"),\n        };\n        if digit == 4 {\n            result.push(one);\n\
    \            result.push(five);\n        } else if digit == 9 {\n            result.push(one);\n\
    \            result.push(ten);\n        } else {\n            if digit >= 5 {\n\
    \                result.push(five);\n                digit -= 5;\n           \
    \ }\n            for _ in 0..digit {\n                result.push(one);\n    \
    \        }\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `digit`\n  -->\
    \ /tmp/tmpg1o7sk9u.rs:31:17\n   |\n13 |         let digit = number % 10;\n   |\
    \             -----\n   |             |\n   |             first assignment to\
    \ `digit`\n   |             help: consider making this binding mutable: `mut digit`\n\
    ...\n31 |                 digit -= 5;\n   |                 ^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut symbols = vec![\n        (1000, 'm'),\n        (900, 'c'),\n    \
    \    (500, 'd'),\n        (400, 'c'),\n        (100, 'c'),\n        (90, 'x'),\n\
    \        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n        (9, 'i'),\n\
    \        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n    ];\n    while number\
    \ > 0 {\n        let (value, symbol) = symbols.pop().unwrap();\n        if number\
    \ >= value {\n            number -= value;\n            result.push(symbol);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iivi\"`,\n right: `\"xix\"`', /tmp/tmpa1xorgnv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut index = 0;\n    while number > 0 {\n        let digit\
    \ = number % 10;\n        number /= 10;\n        let roman_digit = match digit\
    \ {\n            1 => \"i\",\n            2 => \"ii\",\n            3 => \"iii\"\
    ,\n            4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\"\
    ,\n            7 => \"vii\",\n            8 => \"viii\",\n            9 => \"\
    ix\",\n            _ => \"\",\n        };\n        result = format!(\"{}{}\",\
    \ roman_digit, result);\n        index += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpo4sg_jtv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        number /= 10;\n        result = mini_roman_digit(digit, i) +\
    \ &result;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mini_roman_digit` in this scope\n \
    \ --> /tmp/tmpk4j_n7sl.rs:15:18\n   |\n15 |         result = mini_roman_digit(digit,\
    \ i) + &result;\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmpsnz6ki4d.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_pairs = vec![\n        (1000, \"m\"),\n        (900, \"cm\"\
    ),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n   \
    \     (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10,\
    \ \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n \
    \       (1, \"i\"),\n    ];\n    while number > 0 {\n        for (int, numeral)\
    \ in numeral_pairs.iter() {\n            if number >= *int {\n               \
    \ result.push_str(numeral);\n                number -= *int;\n               \
    \ break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let symbols = [\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n    for (symbol, value) in symbols.iter()\
    \ {\n        while number >= *value {\n            result.push_str(symbol);\n\
    \            number -= *value;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xviiii\"`,\n right: `\"xix\"`', /tmp/tmpk47yjz6o.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut num = number;\n    let mut result = String::new();\n\
    \    let mut roman_numerals = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n\n    for (rn, val) in roman_numerals.iter_mut()\
    \ {\n        while num >= *val {\n            result.push_str(rn);\n         \
    \   num -= *val;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xviiii\"`,\n right: `\"xix\"`', /tmp/tmp53rsd4ih.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        let roman_digit = match digit {\n            1\
    \ => \"i\",\n            2 => \"ii\",\n            3 => \"iii\",\n           \
    \ 4 => \"iv\",\n            5 => \"v\",\n            6 => \"vi\",\n          \
    \  7 => \"vii\",\n            8 => \"viii\",\n            9 => \"ix\",\n     \
    \       _ => \"\",\n        };\n        result = format!(\"{}{}\", roman_digit,\
    \ result);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n\
    \    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iix\"`,\n right: `\"xix\"`', /tmp/tmp40ky9ij5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral = String::new();\n    let mut digit = 0;\n    let mut digit_value\
    \ = 0;\n    let mut next_digit_value = 0;\n    let mut next_digit = 0;\n    let\
    \ mut next_numeral = String::new();\n    let mut next_numeral_value = 0;\n   \
    \ let mut numeral_value = 0;\n    let mut numeral_index = 0;\n    let mut next_numeral_index\
    \ = 0;\n    let mut next_numeral_index_value = 0;\n    let mut numeral_index_value\
    \ = 0;\n    let mut numeral_index_value_next = 0;\n    let mut numeral_index_value_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next = 0;\n    let mut numeral_index_value_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next = 0;\n    let\
    \ mut numeral_index_value_next_next_next_next_next_next = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut numeral_index_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n  \
    \  assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp550red1f.rs:37:1\n  \
    \ |\n37 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        let digit = number % 10;\n\
    \        number /= 10;\n        result = match digit {\n            1 => format!(\"\
    i{}\", result),\n            2 => format!(\"ii{}\", result),\n            3 =>\
    \ format!(\"iii{}\", result),\n            4 => format!(\"iv{}\", result),\n \
    \           5 => format!(\"v{}\", result),\n            6 => format!(\"vi{}\"\
    , result),\n            7 => format!(\"vii{}\", result),\n            8 => format!(\"\
    viii{}\", result),\n            9 => format!(\"ix{}\", result),\n            _\
    \ => result,\n        };\n        i += 1;\n        if i == 2 {\n            result\
    \ = match number % 10 {\n                1 => format!(\"x{}\", result),\n    \
    \            2 => format!(\"xx{}\", result),\n                3 => format!(\"\
    xxx{}\", result),\n                4 => format!(\"xl{}\", result),\n         \
    \       5 => format!(\"l{}\", result),\n                6 => format!(\"lx{}\"\
    , result),\n                7 => format!(\"lxx{}\", result),\n               \
    \ 8 => format!(\"lxxx{}\", result),\n                9 => format!(\"xc{}\", result),\n\
    \                _ => result,\n            };\n            number /= 10;\n   \
    \     }\n        if i == 3 {\n            result = match number % 10 {\n     \
    \           1 => format!(\"c{}\", result),\n                2 => format!(\"cc{}\"\
    , result),\n                3 => format!(\"ccc{}\", result),\n               \
    \ 4 => format!(\"cd{}\", result),\n                5 => format!(\"d{}\", result),\n\
    \                6 => format!(\"dc{}\", result),\n                7 => format!(\"\
    dcc{}\", result),\n                8 => format!(\"dccc{}\", result),\n       \
    \         9 => format!(\"cm{}\", result),\n                _ => result,\n    \
    \        };\n            number /= 10;\n        }\n        if i == 4 {\n     \
    \       result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n   \
    \ assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptutfh2k7.rs:78:3\n\
    \   |\n8  | fn int_to_mini_roman(number: isize) -> String {\n   |            \
    \                                   - unclosed delimiter\n...\n12 |     while\
    \ number > 0 {\n   |                      - unclosed delimiter\n...\n58 |    \
    \     if i == 4 {\n   |                   - this delimiter might not be properly\
    \ closed...\n59 |             result\n60 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptutfh2k7.rs:59:13\n   |\n58 | /         if i == 4 {\n59\
    \ | |             result\n   | |             ^^^^^^ expected `()`, found struct\
    \ `String`\n60 | | }\n   | |_- expected this to be `()`\n   |\nhelp: you might\
    \ have meant to return this value\n   |\n59 |             return result;\n   |\
    \             ++++++       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptutfh2k7.rs:12:5\n\
    \   |\n8  |   fn int_to_mini_roman(number: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n12 | /     while number > 0 {\n13 | |         let digit = number % 10;\n\
    14 | |         number /= 10;\n15 | |         result = match digit {\n...  |\n\
    77 | |     assert_eq!(candidate(1000), String::from(\"m\"));\n78 | | }\n   | |__^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (numeral, value) in roman_numerals {\n     \
    \   while number >= *value {\n            result.push_str(numeral);\n        \
    \    number -= value;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpjmfb9ph0.rs:27:25\n\
    \   |\n27 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut roman = String::new();\n\
    \    let mut i = 0;\n    while number > 0 {\n        if number >= ROMAN_NUMERALS[i].0\
    \ {\n            roman.push_str(ROMAN_NUMERALS[i].1);\n            number -= ROMAN_NUMERALS[i].0;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    roman\n}\n\nfn main()\
    \ {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpk915xxpm.rs:13:22\n\
    \   |\n13 |         if number >= ROMAN_NUMERALS[i].0 {\n   |                 \
    \     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpk915xxpm.rs:14:28\n   |\n14 |\
    \             roman.push_str(ROMAN_NUMERALS[i].1);\n   |                     \
    \       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_NUMERALS` in this scope\n  --> /tmp/tmpk915xxpm.rs:15:23\n   |\n15 |\
    \             number -= ROMAN_NUMERALS[i].0;\n   |                       ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_map = vec![\n        (\"m\", 1000),\n        (\"d\", 500),\n\
    \        (\"c\", 100),\n        (\"l\", 50),\n        (\"x\", 10),\n        (\"\
    v\", 5),\n        (\"i\", 1),\n    ];\n    while number > 0 {\n        let mut\
    \ found = false;\n        for (numeral, value) in numeral_map.iter() {\n     \
    \       if number >= *value {\n                result.push_str(numeral);\n   \
    \             number -= *value;\n                found = true;\n             \
    \   break;\n            }\n        }\n        if !found {\n            let mut\
    \ last_numeral = numeral_map.pop().unwrap();\n            let mut last_value =\
    \ last_numeral.1;\n            while number < last_value {\n                last_numeral\
    \ = numeral_map.pop().unwrap();\n                last_value = last_numeral.1;\n\
    \            }\n            result.push_str(last_numeral.0);\n            result.push_str(numeral_map.last().unwrap().0);\n\
    \            number -= last_value - numeral_map.last().unwrap().1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xviiii\"`,\n right: `\"xix\"`', /tmp/tmprcoovfni.rs:47:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = [\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (roman, arabic) in roman_numerals.iter() {\n\
    \        while number >= *arabic {\n            result.push_str(roman);\n    \
    \        number -= arabic;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut roman = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        roman.push('m');\n        num -= 1000;\n   \
    \ }\n    if num >= 900 {\n        roman.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        roman.push('d');\n        num -= 500;\n \
    \   }\n    if num >= 400 {\n        roman.push_str(\"cd\");\n        num -= 400;\n\
    \    }\n    while num >= 100 {\n        roman.push('c');\n        num -= 100;\n\
    \    }\n    if num >= 90 {\n        roman.push_str(\"xc\");\n        num -= 90;\n\
    \    }\n    if num >= 50 {\n        roman.push('l');\n        num -= 50;\n   \
    \ }\n    if num >= 40 {\n        roman.push_str(\"xl\");\n        num -= 40;\n\
    \    }\n    while num >= 10 {\n        roman.push('x');\n        num -= 10;\n\
    \    }\n    if num >= 9 {\n        roman.push_str(\"ix\");\n        num -= 9;\n\
    \    }\n    if num >= 5 {\n        roman.push('v');\n        num -= 5;\n    }\n\
    \    if num >= 4 {\n        roman.push_str(\"iv\");\n        num -= 4;\n    }\n\
    \    while num >= 1 {\n        roman.push('i');\n        num -= 1;\n    }\n  \
    \  roman\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let mut numeral_pairs = vec![\n        (1000, \"m\"),\n        (900, \"cm\"\
    ),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n   \
    \     (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10,\
    \ \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n \
    \       (1, \"i\"),\n    ];\n    while number > 0 {\n        for (value, numeral)\
    \ in numeral_pairs.iter() {\n            if number >= *value {\n             \
    \   result.push_str(numeral);\n                number -= *value;\n           \
    \     break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num > 0 {\n        if num >= 1000 {\n            result.push('m');\n\
    \            num -= 1000;\n        } else if num >= 900 {\n            result.push_str(\"\
    cm\");\n            num -= 900;\n        } else if num >= 500 {\n            result.push('d');\n\
    \            num -= 500;\n        } else if num >= 400 {\n            result.push_str(\"\
    cd\");\n            num -= 400;\n        } else if num >= 100 {\n            result.push('c');\n\
    \            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"\
    xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push('l');\n\
    \            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"\
    xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push('x');\n\
    \            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"\
    ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push('v');\n\
    \            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"\
    iv\");\n            num -= 4;\n        } else if num >= 1 {\n            result.push('i');\n\
    \            num -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut number = number;\n    let mut result = String::new();\n\
    \    let roman_numerals = vec![\n        (\"m\", 1000),\n        (\"cm\", 900),\n\
    \        (\"d\", 500),\n        (\"cd\", 400),\n        (\"c\", 100),\n      \
    \  (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\", 40),\n        (\"x\"\
    , 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n        (\"iv\", 4),\n    \
    \    (\"i\", 1),\n    ];\n    for (numeral, value) in roman_numerals {\n     \
    \   while number >= *value {\n            result.push_str(numeral);\n        \
    \    number -= value;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"\
    xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251),\
    \ String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"\
    ));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1),\
    \ String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n\
    \    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90),\
    \ String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"\
    ));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900),\
    \ String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"\
    ));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpy93ood5n.rs:27:25\n\
    \   |\n27 |         while number >= *value {\n   |                         ^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    while number > 0 {\n        if number >= 1000 {\n           \
    \ result.push('m');\n            number -= 1000;\n        } else if number >=\
    \ 900 {\n            result.push_str(\"cm\");\n            number -= 900;\n  \
    \      } else if number >= 500 {\n            result.push('d');\n            number\
    \ -= 500;\n        } else if number >= 400 {\n            result.push_str(\"cd\"\
    );\n            number -= 400;\n        } else if number >= 100 {\n          \
    \  result.push('c');\n            number -= 100;\n        } else if number >=\
    \ 90 {\n            result.push_str(\"xc\");\n            number -= 90;\n    \
    \    } else if number >= 50 {\n            result.push('l');\n            number\
    \ -= 50;\n        } else if number >= 40 {\n            result.push_str(\"xl\"\
    );\n            number -= 40;\n        } else if number >= 10 {\n            result.push('x');\n\
    \            number -= 10;\n        } else if number >= 9 {\n            result.push_str(\"\
    ix\");\n            number -= 9;\n        } else if number >= 5 {\n          \
    \  result.push('v');\n            number -= 5;\n        } else if number >= 4\
    \ {\n            result.push_str(\"iv\");\n            number -= 4;\n        }\
    \ else if number >= 1 {\n            result.push('i');\n            number -=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\
    \    while num >= 1000 {\n        result.push('m');\n        num -= 1000;\n  \
    \  }\n    if num >= 900 {\n        result.push_str(\"cm\");\n        num -= 900;\n\
    \    }\n    if num >= 500 {\n        result.push('d');\n        num -= 500;\n\
    \    }\n    if num >= 400 {\n        result.push_str(\"cd\");\n        num -=\
    \ 400;\n    }\n    while num >= 100 {\n        result.push('c');\n        num\
    \ -= 100;\n    }\n    if num >= 90 {\n        result.push_str(\"xc\");\n     \
    \   num -= 90;\n    }\n    if num >= 50 {\n        result.push('l');\n       \
    \ num -= 50;\n    }\n    if num >= 40 {\n        result.push_str(\"xl\");\n  \
    \      num -= 40;\n    }\n    while num >= 10 {\n        result.push('x');\n \
    \       num -= 10;\n    }\n    if num >= 9 {\n        result.push_str(\"ix\");\n\
    \        num -= 9;\n    }\n    if num >= 5 {\n        result.push('v');\n    \
    \    num -= 5;\n    }\n    if num >= 4 {\n        result.push_str(\"iv\");\n \
    \       num -= 4;\n    }\n    while num >= 1 {\n        result.push('i');\n  \
    \      num -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n\
    \    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152),\
    \ String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"\
    ));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500),\
    \ String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n\
    \    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43),\
    \ String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"\
    ));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532),\
    \ String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"\
    ));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000),\
    \ String::from(\"m\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfn int_to_mini_roman(number:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut number\
    \ = number;\n    let mut i = 0;\n    while number > 0 {\n        let digit = number\
    \ % 10;\n        if digit == 9 {\n            result.push(ROMAN_DIGITS[i + 1]);\n\
    \            result.push(ROMAN_DIGITS[i - 1]);\n        } else if digit >= 5 {\n\
    \            result.push(ROMAN_DIGITS[i]);\n            for _ in 0..digit - 5\
    \ {\n                result.push(ROMAN_DIGITS[i - 1]);\n            }\n      \
    \  } else if digit == 4 {\n            result.push(ROMAN_DIGITS[i + 1]);\n   \
    \         result.push(ROMAN_DIGITS[i - 1]);\n        } else {\n            for\
    \ _ in 0..digit {\n                result.push(ROMAN_DIGITS[i - 1]);\n       \
    \     }\n        }\n        number /= 10;\n        i += 2;\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
    \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
    ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
    \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
    ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
    \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"\
    ));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
    \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
    ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
    \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"\
    m\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpnc00mybh.rs:15:25\n\
    \   |\n15 |             result.push(ROMAN_DIGITS[i + 1]);\n   |              \
    \           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpnc00mybh.rs:16:25\n   |\n\
    16 |             result.push(ROMAN_DIGITS[i - 1]);\n   |                     \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS`\
    \ in this scope\n  --> /tmp/tmpnc00mybh.rs:18:25\n   |\n18 |             result.push(ROMAN_DIGITS[i]);\n\
    \   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpnc00mybh.rs:20:29\n\
    \   |\n20 |                 result.push(ROMAN_DIGITS[i - 1]);\n   |          \
    \                   ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpnc00mybh.rs:23:25\n \
    \  |\n23 |             result.push(ROMAN_DIGITS[i + 1]);\n   |               \
    \          ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROMAN_DIGITS` in this scope\n  --> /tmp/tmpnc00mybh.rs:24:25\n   |\n24 |  \
    \           result.push(ROMAN_DIGITS[i - 1]);\n   |                         ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ROMAN_DIGITS` in\
    \ this scope\n  --> /tmp/tmpnc00mybh.rs:27:29\n   |\n27 |                 result.push(ROMAN_DIGITS[i\
    \ - 1]);\n   |                             ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 7 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
