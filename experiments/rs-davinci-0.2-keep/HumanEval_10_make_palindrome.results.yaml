name: HumanEval_10_make_palindrome
language: rust
results:
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut longest_postfix = String::new();\n    let mut\
    \ longest_postfix_len = 0;\n    let mut i = 0;\n    while i < string.len() {\n\
    \        let postfix = &string[i..];\n        if is_palindrome(postfix) {\n  \
    \          if postfix.len() > longest_postfix_len {\n                longest_postfix\
    \ = postfix.to_string();\n                longest_postfix_len = postfix.len();\n\
    \            }\n        }\n        i += 1;\n    }\n    if longest_postfix_len\
    \ > 0 {\n        let prefix = &string[..string.len() - longest_postfix_len];\n\
    \        let reversed_prefix = reverse_string(prefix);\n        result.push_str(&reversed_prefix);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp3o4o3phf.rs:18:12\n   |\n18 |         if is_palindrome(postfix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse_string` in this scope\n  --> /tmp/tmp3o4o3phf.rs:28:31\n\
    \   |\n28 |         let reversed_prefix = reverse_string(prefix);\n   |      \
    \                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut longest_palindrome_suffix = String::new();\n    for i in 0..string.len()\
    \ {\n        if string.ends_with(&reversed[i..]) {\n            longest_palindrome_suffix\
    \ = reversed[i..].to_string();\n            break;\n        }\n    }\n    result.push_str(&longest_palindrome_suffix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp7uuw3hta.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    while !is_palindrome(&suffix)\
    \ {\n        suffix.pop();\n    }\n    let prefix = string.split_off(string.len()\
    \ - suffix.len());\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6hpjha6p.rs:14:12\n   |\n14 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut longest_palindrome = String::new();\n\
    \n    for i in 0..string.len() {\n        suffix.push(string.pop().unwrap());\n\
    \        palindrome = suffix.clone();\n        palindrome.push_str(&prefix);\n\
    \        if is_palindrome(&palindrome) {\n            longest_palindrome = palindrome.clone();\n\
    \        }\n        prefix.push(suffix.pop().unwrap());\n    }\n\n    let mut\
    \ prefix = String::new();\n    for i in 0..string.len() {\n        prefix.push(string.pop().unwrap());\n\
    \    }\n    prefix.push_str(&longest_palindrome);\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxl995un8.rs:22:12\n   |\n22 |         if is_palindrome(&palindrome)\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpr8979wd2.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut palindrome_len = 0;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n   \
    \         palindrome_suffix_len += 1;\n            palindrome_prefix.push(string.chars().nth(j).unwrap());\n\
    \            palindrome_prefix_len += 1;\n            palindrome_len += 2;\n \
    \           i += 1;\n            j -= 1;\n        } else {\n            palindrome_suffix.clear();\n\
    \            palindrome_suffix_len = 0;\n            palindrome_prefix.clear();\n\
    \            palindrome_prefix_len = 0;\n            palindrome_len = 0;\n   \
    \         i = 0;\n            j -= 1;\n        }\n    }\n    if palindrome_len\
    \ == string.len() {\n        return string;\n    }\n    palindrome_prefix.pop();\n\
    \    palindrome_prefix_len -= 1;\n    palindrome_prefix.reverse();\n    string.insert_str(palindrome_suffix_len,\
    \ &palindrome_prefix);\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdix73d42.rs:44:23\n   |\n44 |     palindrome_prefix.reverse();\n\
    \   |                       ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = longest_palindrome_suffix(&string);\n\
    \    let mut prefix_to_append = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    prefix_to_append.reverse();\n    string.push_str(&prefix_to_append);\n  \
    \  string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpch_45kip.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n   |                                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpch_45kip.rs:15:22\n\
    \   |\n15 |     prefix_to_append.reverse();\n   |                      ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n  \
    \      if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            i = 0;\n            j -= 1;\n\
    \            suffix.clear();\n            prefix.clear();\n        }\n    }\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppqmmfi2r.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = String::new();\n    let mut suffix = String::new();\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_start = 0;\n    let mut longest_palindrome_end\
    \ = 0;\n    let mut current_palindrome_length = 0;\n    let mut current_palindrome_start\
    \ = 0;\n    let mut current_palindrome_end = 0;\n    let mut current_palindrome_center\
    \ = 0;\n    let mut current_palindrome_center_left = 0;\n    let mut current_palindrome_center_right\
    \ = 0;\n    let mut current_palindrome_center_left_left = 0;\n    let mut current_palindrome_center_right_right\
    \ = 0;\n    let mut current_palindrome_center_left_left_left = 0;\n    let mut\
    \ current_palindrome_center_right_right_right = 0;\n    let mut current_palindrome_center_left_left_left_left\
    \ = 0;\n    let mut current_palindrome_center_right_right_right_right = 0;\n \
    \   let mut current_palindrome_center_left_left_left_left_left = 0;\n    let mut\
    \ current_palindrome_center_right_right_right_right_right = 0;\n    let mut current_palindrome_center_left_left_left_left_left_left\
    \ = 0;\n    let mut current_palindrome_center_right_right_right_right_right_right\
    \ = 0;\n    let mut current_palindrome_center_left_left_left_left_left_left_left\
    \ = 0;\n    let mut current_palindrome_center_right_right_right_right_right_right_right\
    \ = 0;\n    let mut current_palindrome_center_left_left_left_left_left_left_left_left\
    \ = 0;\n    let mut current_palindrome_center_right_right_right_right_right_right_right_right\
    \ = 0;\n    let mut current_palindrome_center_left_left_left_left_left_left_left_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnhffjm31.rs:37:74\n   |\n\
    37 |     let mut current_palindrome_center_left_left_left_left_left_left_left_\n\
    \   |                                                                        \
    \  ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhffjm31.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut longest_palindrome_suffix = String::new();\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut current_palindrome_suffix = String::new();\n    let mut current_palindrome_suffix_length\
    \ = 0;\n    let mut i = 0;\n    while i < reversed.len() {\n        let mut j\
    \ = 0;\n        while j < result.len() && i + j < reversed.len() {\n         \
    \   if result.chars().nth(j) == reversed.chars().nth(i + j) {\n              \
    \  current_palindrome_suffix.push(result.chars().nth(j).unwrap());\n         \
    \       current_palindrome_suffix_length += 1;\n            } else {\n       \
    \         if current_palindrome_suffix_length > longest_palindrome_suffix_length\
    \ {\n                    longest_palindrome_suffix = current_palindrome_suffix.clone();\n\
    \                    longest_palindrome_suffix_length = current_palindrome_suffix_length;\n\
    \                }\n                current_palindrome_suffix = String::new();\n\
    \                current_palindrome_suffix_length = 0;\n            }\n      \
    \      j += 1;\n        }\n        if current_palindrome_suffix_length > longest_palindrome_suffix_length\
    \ {\n            longest_palindrome_suffix = current_palindrome_suffix.clone();\n\
    \            longest_palindrome_suffix_length = current_palindrome_suffix_length;\n\
    \        }\n        current_palindrome_suffix = String::new();\n        current_palindrome_suffix_length\
    \ = 0;\n        i += 1;\n    }\n    result.push_str(&reversed[0..result.len()\
    \ - longest_palindrome_suffix_length].to_string());\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmp42l6qgm4.rs:51:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.split_off(longest_palindrome_suffix.len());\n\
    \    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n   \
    \ prefix_reversed.push_str(&longest_palindrome_suffix);\n    prefix_reversed\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplk_ofozk.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut palindrome\
    \ = String::new();\n    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_index\
    \ = 0;\n\n    // Find the longest palindrome suffix\n    for i in 0..string.len()\
    \ {\n        let (prefix_slice, suffix_slice) = prefix.split_at(i);\n        if\
    \ suffix_slice == suffix_slice.chars().rev().collect::<String>() {\n         \
    \   if suffix_slice.len() > longest_palindrome_length {\n                longest_palindrome_length\
    \ = suffix_slice.len();\n                longest_palindrome_index = i;\n     \
    \       }\n        }\n    }\n\n    // Append the reverse of the prefix to the\
    \ end of the string\n    let (prefix_slice, _) = prefix.split_at(longest_palindrome_index);\n\
    \    palindrome.push_str(prefix_slice);\n    palindrome.push_str(prefix_slice.chars().rev().collect::<String>().as_str());\n\
    \n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"x\"`', /tmp/tmp7pcsbc5f.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    longest_palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_length\
    \ = i;\n        }\n    }\n    let prefix = &string[..longest_palindrome_suffix_length];\n\
    \    let prefix_reversed = prefix.chars().rev().collect::<String>();\n    string.push_str(&prefix_reversed);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpn79ht3ve.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    string.push_str(&string[..string.len() -\
    \ longest_palindrome_suffix_length].chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpimki0ct1.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix_length = 0;\n    let mut current_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix = String::new();\n    let mut current_palindrome_suffix_reversed\
    \ = String::new();\n    let mut string_length = string.len();\n    let mut string_chars\
    \ = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n  \
    \  let mut current_char = string_chars.next();\n    let mut current_char_rev =\
    \ string_chars_rev.next();\n    let mut next_char = string_chars.next();\n   \
    \ let mut next_char_rev = string_chars_rev.next();\n    let mut current_char_index\
    \ = 0;\n    let mut next_char_index = 1;\n    let mut current_char_rev_index =\
    \ string_length - 1;\n    let mut next_char_rev_index = string_length - 2;\n \
    \   while current_char.is_some() {\n        if current_char == next_char {\n \
    \           current_palindrome_suffix_length += 2;\n            current_palindrome_suffix_index\
    \ = current_char_index;\n            current_palindrome_suffix = string[current_char_index..next_char_index\
    \ + 1].to_string();\n            current_palindrome_suffix_reversed = string[current_char_rev_index..next_char_rev_index\
    \ + 1].to_string();\n            if current_palindrome_suffix_length > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix_length = current_palindrome_suffix_length;\n\
    \                longest_palindrome_suffix_index = current_palindrome_suffix_index;\n\
    \                longest_palindrome_suff\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvi7uwivs.rs:50:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n31 |     while current_char.is_some()\
    \ {\n   |                                  - unclosed delimiter\n32 |        \
    \ if current_char == next_char {\n   |                                      -\
    \ unclosed delimiter\n...\n37 |             if current_palindrome_suffix_length\
    \ > longest_palindrome_suffix_length {\n   |                                 \
    \                                                   - this delimiter might not\
    \ be properly closed...\n...\n41 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n50 | }\n   |   ^\n\nerror[E0425]: cannot find value\
    \ `longest_palindrome_suff` in this scope\n  --> /tmp/tmpvi7uwivs.rs:40:17\n \
    \  |\n40 |                 longest_palindrome_suff\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_palindrome_suffix`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvi7uwivs.rs:31:5\n   |\n11 | \
    \  fn make_palindrome(string: String) -> String {\n   |                      \
    \                   ------ expected `String` because of return type\n...\n31 |\
    \ /     while current_char.is_some() {\n32 | |         if current_char == next_char\
    \ {\n33 | |             current_palindrome_suffix_length += 2;\n34 | |       \
    \      current_palindrome_suffix_index = current_char_index;\n...  |\n49 | | \
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n50 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_length];\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpr034787m.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    for i in 0..string.len() {\n       \
    \ let suffix = &string[i..];\n        if is_palindrome(suffix) {\n           \
    \ longest_palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_len\
    \ = suffix.len();\n            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9pun9u6e.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = string.split_off(i);\n        if is_palindrome(&suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix;\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n        string = suffix;\n    }\n\
    \    let prefix = string.split_off(longest_palindrome_suffix_length);\n    prefix\
    \ + &longest_palindrome_suffix + &prefix.chars().rev().collect::<String>()\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpfyef_cry.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n  \
    \      if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            i = 0;\n            j -= 1;\n\
    \            suffix.clear();\n            prefix.clear();\n        }\n    }\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmph3xlu22v.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpg5mokkam.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut palindrome_length = 0;\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \    let mut string_chars_iter = string.chars();\n    let mut string_chars_rev_iter\
    \ = string.chars().rev();\n    let mut string_chars_iter_rev = string.chars();\n\
    \    let mut string_chars_rev_iter_rev = string.chars().rev();\n    let mut string_chars_iter_rev_rev\
    \ = string.chars();\n    let mut string_chars_rev_iter_rev_rev = string.chars().rev();\n\
    \    let mut string_chars_iter_rev_rev_rev = string.chars();\n    let mut string_chars_rev_iter_rev_rev_rev\
    \ = string.chars().rev();\n    let mut string_chars_iter_rev_rev_rev_rev = string.chars();\n\
    \    let mut string_chars_rev_iter_rev_rev_rev_rev = string.chars().rev();\n \
    \   let mut string_chars_iter_rev_rev_rev_rev_rev = string.chars();\n    let mut\
    \ string_chars_rev_iter_rev_rev_rev_rev_rev = string.chars().rev();\n    let mut\
    \ string_chars_iter_rev_rev_rev_rev_rev_rev = string.chars();\n    let mut string_chars_rev_iter_rev_rev_rev_rev_rev_rev\
    \ = string.chars().rev();\n    let mut string_chars_iter_rev_rev_rev_rev_rev_rev_rev\
    \ = string.chars();\n    let mut string_chars_rev_iter_rev_rev_rev_rev_rev_rev\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1hunlvxw.rs:36:58\n   |\n\
    36 |     let mut string_chars_rev_iter_rev_rev_rev_rev_rev_rev\n   |         \
    \                                                 ^ help: add `;` here\n37 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hunlvxw.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    palindrome_suffix.clear();\n            palindrome_suffix_len = 0;\n    \
    \        i = 0;\n            j -= 1;\n        }\n    }\n    palindrome_prefix\
    \ = palindrome_suffix.chars().rev().collect();\n    palindrome_prefix_len = palindrome_suffix_len;\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpo8afeo_3.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut longest_palindrome = String::new();\n\
    \n    for i in 0..string.len() {\n        suffix.push(string.pop().unwrap());\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome = suffix.clone();\n\
    \        }\n    }\n\n    for _ in 0..longest_palindrome.len() {\n        prefix.push(string.pop().unwrap());\n\
    \    }\n\n    palindrome.push_str(&string);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome.push_str(&longest_palindrome);\n\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpy3q96o2w.rs:20:12\n   |\n20 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_postfix = String::new();\n    let\
    \ mut longest_palindrome_postfix_length = 0;\n    for i in 0..string.len() {\n\
    \        let postfix = string.split_off(i);\n        if is_palindrome(&postfix)\
    \ {\n            if postfix.len() > longest_palindrome_postfix_length {\n    \
    \            longest_palindrome_postfix = postfix;\n                longest_palindrome_postfix_length\
    \ = postfix.len();\n            }\n        }\n        string.push_str(&postfix);\n\
    \    }\n    let prefix = string.split_off(longest_palindrome_postfix_length);\n\
    \    let mut prefix = prefix.chars().rev().collect::<String>();\n    prefix.push_str(&string);\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpfplqhh3c.rs:17:12\n   |\n17 |         if is_palindrome(&postfix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = String::new();\n    let mut i = 0;\n   \
    \ let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            palindrome.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    if i == j {\n        palindrome.push(string.chars().nth(i).unwrap());\n\
    \    }\n    let mut prefix = String::new();\n    for c in palindrome.chars().rev()\
    \ {\n        prefix.push(c);\n    }\n    palindrome.push_str(&prefix);\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptn843b_p.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut max_palindrome_length = 0;\n    let mut max_palindrome_index\
    \ = 0;\n    let mut current_palindrome_length = 0;\n    let mut current_palindrome_index\
    \ = 0;\n    let mut current_palindrome_index_end = 0;\n    let mut current_palindrome_index_start\
    \ = 0;\n    let mut current_palindrome_index_start_end = 0;\n    let mut current_palindrome_index_end_start\
    \ = 0;\n    let mut current_palindrome_index_end_end = 0;\n    let mut current_palindrome_index_start_start\
    \ = 0;\n    let mut current_palindrome_index_end_end_start = 0;\n    let mut current_palindrome_index_end_end_end\
    \ = 0;\n    let mut current_palindrome_index_start_start_start = 0;\n    let mut\
    \ current_palindrome_index_end_end_end_start = 0;\n    let mut current_palindrome_index_end_end_end_end\
    \ = 0;\n    let mut current_palindrome_index_start_start_start_start = 0;\n  \
    \  let mut current_palindrome_index_end_end_end_end_start = 0;\n    let mut current_palindrome_index_end_end_end_end_end\
    \ = 0;\n    let mut current_palindrome_index_start_start_start_start_start = 0;\n\
    \    let mut current_palindrome_index_end_end_end_end_end_start = 0;\n    let\
    \ mut current_palindrome_index_end_end_end_end_end_end = 0;\n    let mut current_palindrome_index_start_start_start_start_start_start\
    \ = 0;\n    let mut current_palindrome_index_end_end_end_end_end_end_start = 0;\n\
    \    let mut current_palindrome_index\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0wisp3wu.rs:38:37\n   |\n\
    38 |     let mut current_palindrome_index\n   |                              \
    \       ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0wisp3wu.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    let mut k = 0;\n    let mut l = 0;\n    let mut is_palindrome\
    \ = false;\n\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            i += 1;\n            j -= 1;\n        } else {\n            i\
    \ = 0;\n            j = string.len() - 1;\n            k += 1;\n            string.remove(0);\n\
    \        }\n    }\n\n    if k > 0 {\n        l = string.len() - 1;\n        while\
    \ l >= 0 {\n            prefix.push(string.chars().nth(l).unwrap());\n       \
    \     l -= 1;\n        }\n        palindrome.push_str(&string);\n        palindrome.push_str(&prefix);\n\
    \    } else {\n        is_palindrome = true;\n    }\n\n    if is_palindrome {\n\
    \        palindrome.push_str(&string);\n    }\n\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppvd8z3xn.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n    let mut bd = 0;\n    let mut be = 0;\n    let mut bf = 0;\n\
    \    let mut bg = 0;\n    let mut bh = 0;\n    let mut bi = 0;\n    let mut bj\
    \ = 0;\n    let mut bk = 0;\n    let mut bl = 0;\n    let mut b\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwuw2f07q.rs:72:14\n   |\n\
    72 |     let mut b\n   |              ^ help: add `;` here\n73 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwuw2f07q.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut is_palindrome = false;\n    while !is_palindrome\
    \ {\n        is_palindrome = is_palindrome(&suffix);\n        if !is_palindrome\
    \ {\n            prefix.push(suffix.pop().unwrap());\n        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmpjs861p75.rs:17:25\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n16 |     while !is_palindrome {\n17 |     \
    \    is_palindrome = is_palindrome(&suffix);\n   |                         ^^^^^^^^^^^^^---------\n\
    \   |                         |\n   |                         call expression\
    \ requires function\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpuqwrqzfz.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut palindrome_len = 0;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n   \
    \         palindrome_prefix.push(string.chars().nth(j).unwrap());\n          \
    \  palindrome_suffix_len += 1;\n            palindrome_prefix_len += 1;\n    \
    \        palindrome_len += 2;\n            i += 1;\n            j -= 1;\n    \
    \    } else {\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \            palindrome_suffix_len = 0;\n            palindrome_prefix_len = 0;\n\
    \            palindrome_len = 0;\n            i = 0;\n            j -= 1;\n  \
    \      }\n    }\n    if palindrome_suffix_len == 0 {\n        string\n    } else\
    \ {\n        let mut prefix = String::new();\n        for c in string.chars().take(string.len()\
    \ - palindrome_suffix_len) {\n            prefix.push(c);\n        }\n       \
    \ prefix.push_str(&palindrome_suffix);\n        prefix.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \        prefix\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj5gss3l8.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = string.len();\n    while i > 0 {\n        suffix.push_str(&string[i\
    \ - 1..i]);\n        prefix.push_str(&string[0..i]);\n        if is_palindrome(&prefix)\
    \ {\n            break;\n        }\n        i -= 1;\n    }\n    string.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplgdsws5a.rs:19:12\n   |\n19 |         if is_palindrome(&prefix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       if is_palindrome(suffix) {\n            if suffix.len() > longest_palindrome_suffix_len\
    \ {\n                longest_palindrome_suffix = suffix.to_string();\n       \
    \         longest_palindrome_suffix_len = suffix.len();\n                longest_palindrome_suffix_index\
    \ = i;\n            }\n        }\n    }\n    let prefix = &string[..longest_palindrome_suffix_index];\n\
    \    string.push_str(&reverse(prefix));\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9y67i709.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp9y67i709.rs:27:22\n   |\n\
    27 |     string.push_str(&reverse(prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut suffix_len = 0;\n    let mut\
    \ prefix_len = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n   \
    \ while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            suffix.push(string.chars().nth(i).unwrap());\n            suffix_len\
    \ += 1;\n            prefix.push(string.chars().nth(j).unwrap());\n          \
    \  prefix_len += 1;\n            i += 1;\n            j -= 1;\n        } else\
    \ {\n            i = 0;\n            j -= 1;\n            suffix_len = 0;\n  \
    \          suffix.clear();\n            prefix.clear();\n            prefix_len\
    \ = 0;\n        }\n    }\n    palindrome.push_str(&prefix);\n    palindrome.remove(0..suffix_len);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppcfcxa1x.rs:38:23\n   |\n\
    38 |     palindrome.remove(0..suffix_len);\n   |                       ^^^^^^^^^^^^^\
    \ expected `usize`, found struct `std::ops::Range`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `std::ops::Range<{integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n  \
    \  while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            palindrome_suffix.push(string.chars().nth(i).unwrap());\n       \
    \     palindrome_prefix.push(string.chars().nth(j).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            i = 0;\n            j\
    \ -= 1;\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp2ht488_f.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppp5lyfet.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    if longest_palindrome_suffix_length == 0\
    \ {\n        return string;\n    }\n    let prefix = &string[..string.len() -\
    \ longest_palindrome_suffix_length];\n    let reversed_prefix = reverse(prefix);\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpzuntvyui.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpzuntvyui.rs:28:27\n   |\n\
    28 |     let reversed_prefix = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    palindrome_suffix.clear();\n            palindrome_suffix_len = 0;\n    \
    \        i = 0;\n            j -= 1;\n        }\n    }\n    palindrome_prefix\
    \ = palindrome_suffix.chars().rev().collect();\n    palindrome_prefix_len = palindrome_suffix_len;\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6hd286yi.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_pos\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ if i + 1 == j {\n                longest_palindrome_suffix_len = 2;\n      \
    \          longest_palindrome_suffix_pos = i;\n            } else if i + 2 ==\
    \ j {\n                longest_palindrome_suffix_len = 3;\n                longest_palindrome_suffix_pos\
    \ = i;\n            }\n            i += 1;\n            j -= 1;\n        } else\
    \ {\n            i = 0;\n            j -= 1;\n        }\n    }\n    if longest_palindrome_suffix_len\
    \ > 0 {\n        longest_palindrome_suffix = string.chars().skip(longest_palindrome_suffix_pos).take(longest_palindrome_suffix_len).collect();\n\
    \        string.truncate(longest_palindrome_suffix_pos);\n    }\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string.push_str(&string.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppziic3_i.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut palindrome_length = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n   \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbgdjixgq.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let (head, tail)\
    \ = suffix.split_at(1);\n        prefix.push_str(head);\n        suffix = tail.to_string();\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8lgyk5p_.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    longest_palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_length\
    \ = suffix.len();\n            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpip9a4brz.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut is_palindrome = false;\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut\
    \ n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let\
    \ mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n   \
    \ let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc\
    \ = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let\
    \ mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n\
    \    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn\
    \ = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let\
    \ mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n\
    \    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy\
    \ = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let mut bbb = 0;\n    let\
    \ mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee = 0;\n    let mut fff =\
    \ 0;\n    let mut ggg = 0;\n   \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqke6g_0_.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    for i in 0..string.len() {\n       \
    \ let suffix = &string[i..];\n        if is_palindrome(suffix) {\n           \
    \ if suffix.len() > longest_palindrome_suffix_len {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_len = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_len];\n\
    \    let prefix_reversed = prefix.chars().rev().collect::<String>();\n    string.push_str(&prefix_reversed);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpx7p2l7az.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n    let\
    \ mut longest_palindrome_suffix_index = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_index = 0;\n    for i in 0..string.len()\
    \ {\n        let mut j = 0;\n        while i + j < string.len() && j < i {\n \
    \           if string.chars().nth(i + j) != string.chars().nth(i - j - 1) {\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   if j > longest_palindrome_suffix_length {\n            longest_palindrome_suffix_length\
    \ = j;\n            longest_palindrome_suffix_index = i;\n        }\n        j\
    \ = 0;\n        while i + j < string.len() && j < string.len() - i {\n       \
    \     if string.chars().nth(i + j) != string.chars().nth(string.len() - j - 1)\
    \ {\n                break;\n            }\n            j += 1;\n        }\n \
    \       if j > longest_palindrome_prefix_length {\n            longest_palindrome_prefix_length\
    \ = j;\n            longest_palindrome_prefix_index = i;\n        }\n    }\n \
    \   for i in 0..longest_palindrome_suffix_length {\n        palindrome_suffix.push(string.chars().nth(longest_palindrome_suffix_index\
    \ - i - 1).unwrap());\n    }\n    for i in 0..longest_palindrome_prefix_length\
    \ {\n        palindrome_prefix.push(string.chars().nth(longest_palindrome_prefix_index\
    \ + i).unwrap());\n    }\n    string.push_str(&palindrome_suffix);\n    string.push_str(&palindrome_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpw2tre5vc.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(palindrome_suffix.len());\n    prefix.reverse();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmpak908sky.rs:13:33\n   |\n13 |     let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `reverse` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpak908sky.rs:15:12\n   |\n15 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_length = 0;\n    let mut palindrome_start\
    \ = 0;\n    let mut palindrome_end = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac = 0;\n    let mut ad\
    \ = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let mut ag = 0;\n    let\
    \ mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n    let mut ak = 0;\n\
    \    let mut al = 0;\n    let mut am = 0;\n    let mut an = 0;\n    let mut ao\
    \ = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let mut ar = 0;\n    let\
    \ mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n    let mut av = 0;\n\
    \    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay = 0;\n    let mut az\
    \ = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let mut bc = 0;\n    let\
    \ mut bd = 0;\n    let mut be = 0;\n    let mut bf = 0;\n    let mut bg = 0;\n\
    \    let mut bh = 0;\n    let mut bi = 0;\n    let\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpckobrs93.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.clone();\n    let mut suffix\
    \ = String::new();\n    let mut palindrome_suffix = String::new();\n    let mut\
    \ palindrome_prefix = String::new();\n    let mut palindrome_suffix_len = 0;\n\
    \    let mut palindrome_prefix_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd\
    \ = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let\
    \ mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n\
    \    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo\
    \ = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let\
    \ mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n\
    \    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz\
    \ = 0;\n    let mut aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n   \
    \ let mut ddd = 0;\n    let mut eee = 0;\n    let mut fff = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl59szc5t.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = string.len();\n    while\
    \ i > 0 {\n        suffix.push_str(&string[i - 1..i]);\n        prefix.push_str(&string[0..i]);\n\
    \        if suffix == prefix {\n            palindrome.push_str(&string[i..]);\n\
    \            palindrome.push_str(&string[0..i]);\n            return palindrome;\n\
    \        }\n        i -= 1;\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmp_e4w4u8e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_suffix_len\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       if is_palindrome(suffix) {\n            palindrome_suffix = suffix.to_string();\n\
    \            palindrome_suffix_len = palindrome_suffix.len();\n            break;\n\
    \        }\n    }\n    let prefix = &string[..string.len() - palindrome_suffix_len];\n\
    \    let reverse_prefix = reverse(prefix);\n    string.push_str(&reverse_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4rajs67c.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp4rajs67c.rs:24:26\n   |\n\
    24 |     let reverse_prefix = reverse(prefix);\n   |                         \
    \ ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix_length = 0;\n    let mut current_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix = String::new();\n    let mut current_palindrome_suffix_reversed\
    \ = String::new();\n    let mut current_palindrome_suffix_reversed_length = 0;\n\
    \    let mut current_palindrome_suffix_reversed_index = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in_string\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in_string_length\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in_string_length_max\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in_string_length_max_index\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in_string_length_max_index_in_string\
    \ = 0;\n    let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi4lv5c4n.rs:31:83\n   |\n\
    31 |     let mut current_palindrome_suffix_reversed_index_in_string_length_max_index_in\n\
    \   |                                                                        \
    \           ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi4lv5c4n.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut palindrome_suffix = String::new();\n    for i\
    \ in (0..string.len()).rev() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    result.push_str(&string[..string.len()\
    \ - palindrome_suffix.len()].chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmc6wkbcx.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !suffix.is_empty() {\n        if is_palindrome(&suffix)\
    \ {\n            result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            return result;\n        }\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpeapocfwc.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            palindrome_prefix.push(string.chars().nth(j).unwrap());\n\
    \            palindrome_prefix_len += 1;\n            i += 1;\n            j -=\
    \ 1;\n        } else {\n            palindrome_suffix.clear();\n            palindrome_suffix_len\
    \ = 0;\n            palindrome_prefix.clear();\n            palindrome_prefix_len\
    \ = 0;\n            i = 0;\n            j -= 1;\n        }\n    }\n    string.push_str(&palindrome_prefix);\n\
    \    string.remove(0..palindrome_suffix_len);\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr5juywyj.rs:37:19\n   |\n\
    37 |     string.remove(0..palindrome_suffix_len);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `std::ops::Range`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `std::ops::Range<{integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut suffix = String::new();\n  \
    \  let mut prefix = String::new();\n    let mut longest_palindrome_length = 0;\n\
    \n    for i in 0..string.len() {\n        let substring = &string[i..];\n    \
    \    if is_palindrome(substring) {\n            longest_palindrome_length = substring.len();\n\
    \            suffix = substring.to_string();\n            prefix = string[..i].to_string();\n\
    \        }\n    }\n\n    let mut result = String::new();\n    result.push_str(&string);\n\
    \    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpdut0t8sn.rs:22:12\n   |\n22 |         if is_palindrome(substring) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_idx\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev = 0;\n    let mut longest_palindrome_suffix_idx_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev = 0;\n    let mut\
    \ longest_palindrome_suffix_idx_rev_len_rev_len = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len = 0;\n\
    \    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev = 0;\n\
    \    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len = 0;\n\
    \    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4iwletor.rs:29:83\n   |\n\
    29 |     let mut longest_palindrome_suffix_idx_rev_len_rev_len_rev_len_rev_len_rev_len_\n\
    \   |                                                                        \
    \           ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4iwletor.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = String::new();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut longest_palindrome_length =\
    \ 0;\n    let mut longest_palindrome_index = 0;\n\n    for i in 0..string.len()\
    \ {\n        for j in i..string.len() {\n            if is_palindrome(&string[i..j])\
    \ {\n                if j - i > longest_palindrome_length {\n                \
    \    longest_palindrome_length = j - i;\n                    longest_palindrome_index\
    \ = i;\n                }\n            }\n        }\n    }\n\n    prefix = string[0..longest_palindrome_index].to_string();\n\
    \    suffix = string[longest_palindrome_index..longest_palindrome_index + longest_palindrome_length].to_string();\n\
    \    palindrome.push_str(&suffix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6fpvx7cp.rs:21:16\n   |\n21 |             if is_palindrome(&string[i..j])\
    \ {\n   |                ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let mut palindrome_prefix = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    palindrome_prefix.reverse();\n    string.push_str(&palindrome_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpge6qdc1b.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpge6qdc1b.rs:15:23\n   |\n15 |     palindrome_prefix.reverse();\n\
    \   |                       ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n\
    \    let mut is_palindrome = false;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix_len += 1;\n            prefix_len += 1;\n            i\
    \ += 1;\n            j -= 1;\n        } else {\n            suffix_len = 0;\n\
    \            prefix_len = 0;\n            i = 0;\n            j -= 1;\n      \
    \  }\n        if j == 0 {\n            is_palindrome = true;\n            break;\n\
    \        }\n    }\n    if !is_palindrome {\n        palindrome.push_str(&string[0..prefix_len].chars().rev().collect::<String>());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpl268hh7b.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    let mut reversed_prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut suffix_length = 0;\n    let mut prefix_length\
    \ = 0;\n    let mut is_palindrome = false;\n\n    while !is_palindrome {\n   \
    \     suffix_length += 1;\n        suffix = string.chars().skip(string.len() -\
    \ suffix_length).collect();\n        prefix_length = string.len() - suffix_length;\n\
    \        reversed_prefix = string.chars().take(prefix_length).rev().collect();\n\
    \        is_palindrome = suffix == reversed_prefix;\n    }\n\n    palindrome.push_str(&reversed_prefix);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp0zf5rprp.rs:23:62\n     |\n23   |         reversed_prefix = string.chars().take(prefix_length).rev().collect();\n\
    \     |                                                              ^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\n     = note: required because of the requirements on the impl\
    \ of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\nnote: required by\
    \ a bound in `rev`\n\nerror[E0599]: the method `collect` exists for struct `Rev<std::iter::Take<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp0zf5rprp.rs:23:68\n \
    \  |\n23 |            reversed_prefix = string.chars().take(prefix_length).rev().collect();\n\
    \   |                                                                       ^^^^^^^\
    \ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n           which\
    \ is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           `Rev<std::iter::Take<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Rev<std::iter::Take<Chars<'_>>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n  \
    \  while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            palindrome_suffix.push(string.chars().nth(i).unwrap());\n       \
    \     palindrome_prefix.push(string.chars().nth(j).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            i = 0;\n            j\
    \ -= 1;\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplbddurnq.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut palindrome_length = 0;\n    let mut palindrome_length_max\
    \ = 0;\n    let mut palindrome_length_max_index = 0;\n    let mut palindrome_length_max_index_end\
    \ = 0;\n    let mut palindrome_length_max_index_end_max = 0;\n    let mut palindrome_length_max_index_end_max_index\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end = 0;\n    let\
    \ mut palindrome_length_max_index_end_max_index_end_max = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max_index\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max_index_end\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max_index_end_max\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max_index_end_max_index\
    \ = 0;\n    let mut palindrome_length_max_index_end_max_index_end_max_index_end_max_index_end_max_index_end\
    \ = 0;\n    let mut palindrome_length_max_index_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphoxky3w5.rs:33:41\n   |\n\
    33 |     let mut palindrome_length_max_index_\n   |                          \
    \               ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphoxky3w5.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            if suffix.len()\
    \ > 0 {\n                string = string.chars().skip(i).collect();\n        \
    \        i = 0;\n                j = string.len() - 1;\n                suffix.clear();\n\
    \                prefix.clear();\n            } else {\n                i += 1;\n\
    \            }\n        }\n    }\n    palindrome.push_str(&string);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbsnbepky.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpn8df62w3.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut longest_palindrome_suffix = String::new();\n    for i in 0..string.len()\
    \ {\n        if string.ends_with(&reversed[i..]) {\n            longest_palindrome_suffix\
    \ = reversed[i..].to_string();\n            break;\n        }\n    }\n    result.push_str(&longest_palindrome_suffix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpu87fht2n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = string.split_off(i);\n        if is_palindrome(&suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix;\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n        string = suffix;\n    }\n\
    \    let prefix = string.split_off(longest_palindrome_suffix_length);\n    let\
    \ mut prefix = prefix.chars().rev().collect::<String>();\n    prefix.push_str(&longest_palindrome_suffix);\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2oy_xu7g.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.split_off(string.len()\
    \ - longest_palindrome_suffix.len());\n    let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpllajyra3.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            palindrome_prefix.push(string.chars().nth(j).unwrap());\n\
    \            palindrome_prefix_len += 1;\n            i += 1;\n            j -=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n    if palindrome_suffix_len\
    \ > 0 {\n        string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp22vk84o8.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut max_palindrome_length = 0;\n    let mut max_palindrome_index\
    \ = 0;\n    let mut max_palindrome_index_length = 0;\n    let mut max_palindrome_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_length_index_length = 0;\n    let mut\
    \ max_palindrome_index_length_index_length_index = 0;\n    let mut max_palindrome_index_length_index_length_index_length\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut max_palindrome_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut max_palindrome_index_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzgzxr38o.rs:33:34\n   |\n\
    33 |     let mut max_palindrome_index_\n   |                                 \
    \ ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzgzxr38o.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.split_off(longest_palindrome_suffix.len());\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgmss2gf6.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = string.split_off(i);\n        if is_palindrome(&suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix;\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n        string = suffix;\n    }\n\
    \    let mut prefix = string.split_off(longest_palindrome_suffix_length);\n  \
    \  prefix.reverse();\n    prefix + &longest_palindrome_suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplnzeecp6.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmplnzeecp6.rs:26:12\n\
    \   |\n26 |     prefix.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n \
    \   let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n   \
    \     if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            suffix_len += 1;\n            i += 1;\n            j -= 1;\n    \
    \    } else {\n            if suffix_len > prefix_len {\n                prefix_len\
    \ = suffix_len;\n                prefix = suffix.clone();\n            }\n   \
    \         suffix_len = 0;\n            suffix = String::new();\n            i\
    \ = 0;\n            j -= 1;\n        }\n    }\n    if suffix_len > prefix_len\
    \ {\n        prefix_len = suffix_len;\n        prefix = suffix.clone();\n    }\n\
    \    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd5og6aag.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = String::new();\n    let mut prefix =\
    \ String::new();\n    let mut i = string.len();\n    while i > 0 {\n        suffix.push(string.chars().nth(i\
    \ - 1).unwrap());\n        prefix.push(string.chars().nth(string.len() - i).unwrap());\n\
    \        if is_palindrome(&suffix) {\n            result.push_str(&prefix);\n\
    \            break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjhnepd6o.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpt5jak06s.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev = 0;\n    let mut longest_palindrome_suffix_index_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev = 0;\n    let\
    \ mut longest_palindrome_suffix_index_rev_len_rev_len = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len =\
    \ 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_index_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len_rev_len\
    \ = 0;\n    let mut longest\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6m0eta4l.rs:30:20\n   |\n\
    30 |     let mut longest\n   |                    ^ help: add `;` here\n31 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6m0eta4l.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n    let\
    \ mut longest_palindrome_suffix_index = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_index = 0;\n    let mut i = 0;\n\
    \    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            if i == j {\n                palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \                palindrome_prefix.push(string.chars().nth(i).unwrap());\n   \
    \         } else {\n                palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \                palindrome_prefix.push(string.chars().nth(j).unwrap());\n   \
    \         }\n            if palindrome_suffix.len() > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix_length = palindrome_suffix.len();\n\
    \                longest_palindrome_suffix_index = i;\n            }\n       \
    \     if palindrome_prefix.len() > longest_palindrome_prefix_length {\n      \
    \          longest_palindrome_prefix_length = palindrome_prefix.len();\n     \
    \           longest_palindrome_prefix_index = j;\n            }\n            i\
    \ += 1;\n            j -= 1;\n        } else {\n            palindrome_suffix.clear();\n\
    \            palindrome_prefix.clear();\n            i = longest_palindrome_suffix_index\
    \ + 1;\n            j = longest_palindrome_prefix_index - 1;\n        }\n    }\n\
    \    let mut prefix = String::new();\n    let mut suffix = String::new();\n  \
    \  if longest_palindrome_suffix_length > longest_palindrome_prefix_length {\n\
    \        prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplwhfx0lf.rs:60:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n49 |     if longest_palindrome_suffix_length\
    \ > longest_palindrome_prefix_length {\n   |                                 \
    \                                           - this delimiter might not be properly\
    \ closed...\n50 |         prefix\n51 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n60 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplwhfx0lf.rs:50:9\n   |\n49 | /     if longest_palindrome_suffix_length\
    \ > longest_palindrome_prefix_length {\n50 | |         prefix\n   | |        \
    \ ^^^^^^ expected `()`, found struct `String`\n51 | | }\n   | |_- expected this\
    \ to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n50\
    \ |         return prefix;\n   |         ++++++       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplwhfx0lf.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_index = 0;\n    for i in 0..string_chars.len()\
    \ {\n        let mut j = 0;\n        while i - j >= 0 && i + j < string_chars.len()\
    \ && string_chars[i - j] == string_chars[i + j] {\n            j += 1;\n     \
    \   }\n        if j > longest_palindrome_suffix_length {\n            longest_palindrome_suffix_length\
    \ = j;\n            longest_palindrome_suffix_index = i;\n        }\n    }\n \
    \   let mut palindrome = string.clone();\n    for i in 0..longest_palindrome_suffix_index\
    \ - longest_palindrome_suffix_length + 1 {\n        palindrome.push(string_chars[i]);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpeb3whooe.rs:27:25\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_length];\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0kewpzn8.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n \
    \   let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n   \
    \     if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            suffix_len += 1;\n            i += 1;\n            j -= 1;\n    \
    \    } else {\n            if suffix_len > prefix_len {\n                prefix\
    \ = suffix.clone();\n                prefix_len = suffix_len;\n            }\n\
    \            suffix = String::new();\n            suffix_len = 0;\n          \
    \  i = 0;\n            j -= 1;\n        }\n    }\n    if suffix_len > prefix_len\
    \ {\n        prefix = suffix.clone();\n        prefix_len = suffix_len;\n    }\n\
    \    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwd4a2zwf.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix_length = 0;\n    let mut current_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_suffix = String::new();\n    let mut current_palindrome_suffix_reversed\
    \ = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n\
    \    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut\
    \ ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n   \
    \ let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll =\
    \ 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut\
    \ pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n   \
    \ let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww =\
    \ 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut\
    \ aaa = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptk403quy.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut is_palindrome = true;\n    while !suffix.is_empty()\
    \ {\n        if is_palindrome {\n            prefix.push(suffix.pop().unwrap());\n\
    \        }\n        if suffix.is_empty() {\n            break;\n        }\n  \
    \      is_palindrome = is_palindrome_string(&suffix);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome_string` in this scope\n\
    \  --> /tmp/tmp4gymb9fg.rs:23:25\n   |\n23 |         is_palindrome = is_palindrome_string(&suffix);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.clone();\n    let mut postfix\
    \ = String::new();\n    let mut postfix_len = 0;\n    let mut prefix_len = 0;\n\
    \    let mut is_palindrome = false;\n    while !is_palindrome {\n        postfix_len\
    \ += 1;\n        prefix_len = string.len() - postfix_len;\n        postfix = string[prefix_len..].to_string();\n\
    \        prefix = string[..prefix_len].to_string();\n        is_palindrome = is_palindrome(&postfix);\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp4m6ic8o6.rs:23:25\n\
    \   |\n17 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n23 |         is_palindrome = is_palindrome(&postfix);\n\
    \   |                         ^^^^^^^^^^^^^----------\n   |                  \
    \       |\n   |                         call expression requires function\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut j = 0;\n        while j < string.len() - i {\n          \
    \  if string[i..i + j] == string[i + j..].chars().rev().collect::<String>() {\n\
    \                if j > longest_palindrome_suffix_len {\n                    longest_palindrome_suffix\
    \ = string[i..i + j].to_string();\n                    longest_palindrome_suffix_len\
    \ = j;\n                }\n            }\n            j += 1;\n        }\n   \
    \     i += 1;\n    }\n    string.push_str(&string[..string.len() - longest_palindrome_suffix_len].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpcdf_r6gv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut is_palindrome = false;\n    while !is_palindrome\
    \ {\n        let last_char = suffix.pop();\n        if last_char.is_none() {\n\
    \            break;\n        }\n        prefix.push(last_char.unwrap());\n   \
    \     is_palindrome = is_palindrome_string(&suffix);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome_string` in this scope\n\
    \  --> /tmp/tmplbnwtoq5.rs:22:25\n   |\n22 |         is_palindrome = is_palindrome_string(&suffix);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n    let\
    \ mut longest_palindrome_suffix_index = 0;\n    for i in 0..string.len() {\n \
    \       let suffix = &string[i..];\n        let prefix = &string[..string.len()\
    \ - i];\n        if is_palindrome(suffix) {\n            if suffix.len() > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix_length = suffix.len();\n      \
    \          longest_palindrome_suffix_index = i;\n            }\n        }\n  \
    \      if is_palindrome(prefix) {\n            palindrome_prefix = prefix.to_string();\n\
    \        }\n    }\n    palindrome_suffix = string[longest_palindrome_suffix_index..].to_string();\n\
    \    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string.push_str(&palindrome_suffix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpv9emhy9u.rs:20:12\n   |\n20 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmpv9emhy9u.rs:26:12\n\
    \   |\n26 |         if is_palindrome(prefix) {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string.push_str(&longest_palindrome_suffix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppfabap2e.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string.clone();\n    reversed_string.reverse();\n    let mut result = string.clone();\n\
    \    result.push_str(&reversed_string[string.len()..]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprcuybm3y.rs:13:21\n   |\n13 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(palindrome_suffix.len());\n    prefix.reverse();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmppeb6k_2u.rs:13:33\n   |\n13 |     let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `reverse` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmppeb6k_2u.rs:15:12\n   |\n15 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut longest_palindrome = String::new();\n\
    \n    for (i, _) in string.chars().enumerate() {\n        prefix.push(string.pop().unwrap());\n\
    \        if is_palindrome(&prefix) {\n            palindrome = prefix.clone();\n\
    \            if palindrome.len() > longest_palindrome.len() {\n              \
    \  longest_palindrome = palindrome.clone();\n            }\n        }\n    }\n\
    \n    for _ in 0..longest_palindrome.len() {\n        string.pop();\n    }\n\n\
    \    for _ in 0..string.len() {\n        suffix.push(string.pop().unwrap());\n\
    \    }\n\n    return format!(\"{}{}{}\", string, longest_palindrome, suffix);\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgvxov0tw.rs:20:12\n   |\n20 |         if is_palindrome(&prefix) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut is_palindrome = false;\n    while !is_palindrome\
    \ {\n        let suffix_len = suffix.len();\n        let prefix_len = prefix.len();\n\
    \        if suffix_len > 0 {\n            suffix.remove(suffix_len - 1);\n   \
    \         prefix.push(string.chars().nth(prefix_len).unwrap());\n        } else\
    \ {\n            break;\n        }\n        is_palindrome = is_palindrome(&suffix);\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp_0reg9zu.rs:25:25\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n25 |         is_palindrome = is_palindrome(&suffix);\n\
    \   |                         ^^^^^^^^^^^^^---------\n   |                   \
    \      |\n   |                         call expression requires function\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = String::new();\n    let mut prefix = String::new();\n  \
    \  let mut i = 0;\n    while i < string.len() {\n        if string.chars().nth(i)\
    \ == reversed.chars().nth(i) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(reversed.chars().nth(i).unwrap());\n        } else {\n\
    \            break;\n        }\n        i += 1;\n    }\n    result.push_str(&prefix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpgj7bz1zl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let last_char\
    \ = suffix.pop().unwrap();\n        prefix.push(last_char);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpycbjvgrz.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let (first, rest)\
    \ = suffix.split_at(1);\n        suffix = rest.to_string();\n        prefix =\
    \ format!(\"{}{}\", first, prefix);\n    }\n    result.push_str(&prefix);\n  \
    \  result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9v9i_7_w.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    longest_palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_length\
    \ = suffix.len();\n            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp37yiukyj.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.chars().rev().collect::<String>();\n\
    \    let mut prefix = String::new();\n    for _ in 0..string.len() {\n       \
    \ if is_palindrome(&result) {\n            break;\n        }\n        prefix.push(suffix.pop().unwrap());\n\
    \        result.push_str(&prefix);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpa2dgiftl.rs:16:12\n   |\n16 |         if is_palindrome(&result) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n \
    \   let mut max_palindrome_len = 0;\n    let mut max_palindrome_start = 0;\n \
    \   let mut max_palindrome_end = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc = 0;\n    let mut dd\
    \ = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let mut gg = 0;\n    let\
    \ mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n    let mut kk = 0;\n\
    \    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn = 0;\n    let mut oo\
    \ = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let mut rr = 0;\n    let\
    \ mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n    let mut vv = 0;\n\
    \    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy = 0;\n    let mut zz\
    \ = 0;\n    let mut aaa = 0;\n    let mut bbb = 0;\n    let mut ccc = 0;\n   \
    \ let mut ddd = 0;\n    let mut eee = 0;\n    let mut fff\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpay6j3_yg.rs:69:16\n   |\n\
    69 |     let mut fff\n   |                ^ help: add `;` here\n70 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpay6j3_yg.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.clone();\n    let mut suffix\
    \ = String::new();\n    let mut palindrome_length = 0;\n    let mut max_palindrome_length\
    \ = 0;\n    let mut max_palindrome_index = 0;\n    let mut max_palindrome_suffix\
    \ = String::new();\n    let mut max_palindrome_prefix = String::new();\n\n   \
    \ for i in 0..string.len() {\n        let c = string.chars().nth(i).unwrap();\n\
    \        suffix.push(c);\n        prefix.pop();\n\n        if is_palindrome(&suffix)\
    \ {\n            palindrome_length = suffix.len();\n            if palindrome_length\
    \ > max_palindrome_length {\n                max_palindrome_length = palindrome_length;\n\
    \                max_palindrome_index = i;\n                max_palindrome_suffix\
    \ = suffix.clone();\n                max_palindrome_prefix = prefix.clone();\n\
    \            }\n        }\n    }\n\n    result.push_str(&max_palindrome_prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpogjx7ptg.rs:26:12\n   |\n26 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_end = 0;\n    let mut longest_palindrome_suffix_center\
    \ = 0;\n    let mut longest_palindrome_suffix_center_length = 0;\n    let mut\
    \ longest_palindrome_suffix_center_start = 0;\n    let mut longest_palindrome_suffix_center_end\
    \ = 0;\n    let mut longest_palindrome_suffix_center_left = 0;\n    let mut longest_palindrome_suffix_center_right\
    \ = 0;\n    let mut longest_palindrome_suffix_center_left_length = 0;\n    let\
    \ mut longest_palindrome_suffix_center_right_length = 0;\n    let mut longest_palindrome_suffix_center_left_start\
    \ = 0;\n    let mut longest_palindrome_suffix_center_left_end = 0;\n    let mut\
    \ longest_palindrome_suffix_center_right_start = 0;\n    let mut longest_palindrome_suffix_center_right_end\
    \ = 0;\n    let mut longest_palindrome_suffix_center_left_start_index = 0;\n \
    \   let mut longest_palindrome_suffix_center_left_end_index = 0;\n    let mut\
    \ longest_palindrome_suffix_center_right_start_index = 0;\n    let mut longest_palindrome_suffix_center_right_end_index\
    \ = 0;\n    let mut longest_palindrome_suffix_center_left_start_index_index =\
    \ 0;\n    let mut longest_palindrome_suffix_center_left_end_index_index = 0;\n\
    \    let mut longest_palindrome_suffix_center_right_start_index_index = 0;\n \
    \   let mut longest_palindrome_suffix_center_right_end_index_index = 0;\n    let\
    \ mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3eish8n4.rs:37:21\n   |\n\
    37 |     let mut longest_\n   |                     ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3eish8n4.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    for i in (0..string.len()).rev() {\n        if string[0..i] == reversed[0..i]\
    \ {\n            result.push_str(&reversed[i..]);\n            break;\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpp38yss5v.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    for i in 0..string.len() {\n        let mut j = 0;\n        while\
    \ i - j >= 0 && i + j < string.len() {\n            if string.chars().nth(i -\
    \ j).unwrap() != string.chars().nth(i + j).unwrap() {\n                break;\n\
    \            }\n            j += 1;\n        }\n        if j > longest_palindrome_suffix_len\
    \ {\n            longest_palindrome_suffix_len = j;\n            longest_palindrome_suffix_start\
    \ = i - j + 1;\n        }\n    }\n    let mut longest_palindrome_suffix_end =\
    \ longest_palindrome_suffix_start + longest_palindrome_suffix_len;\n    if longest_palindrome_suffix_end\
    \ > string.len() {\n        longest_palindrome_suffix_end = string.len();\n  \
    \  }\n    longest_palindrome_suffix.push_str(&string[longest_palindrome_suffix_start..longest_palindrome_suffix_end]);\n\
    \    string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmm9f4f09.rs:18:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    if string.is_empty() {\n        return string;\n    }\n    let\
    \ mut palindrome_suffix = String::new();\n    let mut palindrome_prefix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_length\
    \ = palindrome_suffix.len();\n            break;\n        }\n    }\n    if longest_palindrome_suffix_length\
    \ == 0 {\n        return string;\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    palindrome_prefix = prefix.chars().rev().collect();\n\
    \    palindrome_prefix.push_str(&string);\n    palindrome_prefix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp1p1kbmcn.rs:21:12\n   |\n21 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = string.clone();\n    let mut suffix_len = 0;\n    let mut\
    \ prefix_len = 0;\n    while suffix_len < string.len() {\n        if is_palindrome(&suffix)\
    \ {\n            result.push_str(&prefix[prefix_len..]);\n            break;\n\
    \        }\n        suffix_len += 1;\n        prefix_len += 1;\n        suffix.remove(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpz04v54rd.rs:18:12\n   |\n18 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut palindrome_suffix = String::new();\n    let mut\
    \ palindrome_prefix = String::new();\n    let mut is_palindrome = false;\n\n \
    \   while !is_palindrome {\n        if suffix.len() == 0 {\n            break;\n\
    \        }\n        if is_palindrome_string(&suffix) {\n            palindrome_suffix\
    \ = suffix.clone();\n            is_palindrome = true;\n        } else {\n   \
    \         prefix.push(suffix.pop().unwrap());\n        }\n    }\n\n    if palindrome_suffix.len()\
    \ > 0 {\n        palindrome_prefix = prefix.chars().rev().collect();\n       \
    \ result.push_str(&palindrome_prefix);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome_string` in this scope\n\
    \  --> /tmp/tmpc6pcya2_.rs:23:12\n   |\n23 |         if is_palindrome_string(&suffix)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_length = 0;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = 0;\n        while j <= i {\n\
    \            let mut k = 0;\n            while k < (i - j + 1) / 2 {\n       \
    \         if string.chars().nth(j + k) != string.chars().nth(i - k) {\n      \
    \              break;\n                }\n                k += 1;\n          \
    \  }\n            if k == (i - j + 1) / 2 {\n                palindrome_length\
    \ = i - j + 1;\n                palindrome_suffix = string.chars().skip(j).take(palindrome_length).collect();\n\
    \                palindrome_prefix = string.chars().take(j).collect();\n     \
    \           break;\n            }\n            j += 1;\n        }\n        i +=\
    \ 1;\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..])\
    \ {\n            palindrome_suffix = string[i..].to_string();\n            palindrome_prefix\
    \ = string[..i].chars().rev().collect();\n            break;\n        }\n    }\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpkw4qr44v.rs:16:12\n   |\n16 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    for i in (0..string.len()).rev()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            palindrome_suffix = suffix.to_string();\n            break;\n   \
    \     }\n    }\n    string.push_str(&string[..string.len() - palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpk6gieewl.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            if suffix.len()\
    \ > 0 {\n                string = string.chars().skip(suffix.len()).collect();\n\
    \                i = 0;\n                j = string.len() - 1;\n             \
    \   suffix.clear();\n                prefix.clear();\n            } else {\n \
    \               i += 1;\n            }\n        }\n    }\n    palindrome.push_str(&string);\n\
    \    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphakuqjvw.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let rev = string.chars().rev().collect::<String>();\n\
    \    let mut i = 0;\n    while !is_palindrome(&result) {\n        result.push(rev.chars().nth(i).unwrap());\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8c1fh57v.rs:15:12\n   |\n15 |     while !is_palindrome(&result) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if prefix[i..] == result[..j] {\n         \
    \   suffix = prefix[..i].to_string();\n            break;\n        }\n       \
    \ i += 1;\n        j -= 1;\n    }\n    result.push_str(&suffix);\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqurvu3bq.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_end = 0;\n    for i in 0..string.len()\
    \ {\n        let (mut start, mut end) = (i, i);\n        while start >= 0 && end\
    \ < string.len() && string.chars().nth(start) == string.chars().nth(end) {\n \
    \           start -= 1;\n            end += 1;\n        }\n        if end - start\
    \ - 1 > longest_palindrome_suffix_len {\n            longest_palindrome_suffix_len\
    \ = end - start - 1;\n            longest_palindrome_suffix_start = start + 1;\n\
    \            longest_palindrome_suffix_end = end - 1;\n        }\n        start\
    \ = i;\n        end = i + 1;\n        while start >= 0 && end < string.len() &&\
    \ string.chars().nth(start) == string.chars().nth(end) {\n            start -=\
    \ 1;\n            end += 1;\n        }\n        if end - start - 1 > longest_palindrome_suffix_len\
    \ {\n            longest_palindrome_suffix_len = end - start - 1;\n          \
    \  longest_palindrome_suffix_start = start + 1;\n            longest_palindrome_suffix_end\
    \ = end - 1;\n        }\n    }\n    if longest_palindrome_suffix_len == 0 {\n\
    \        return string;\n    }\n    for i in longest_palindrome_suffix_start..longest_palindrome_suffix_end\
    \ + 1 {\n        longest_palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplvrjqdzc.rs:20:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    prefix.reverse();\n    string.push_str(&prefix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpvgsr51pk.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpvgsr51pk.rs:15:12\n   |\n15 |     prefix.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut max_palindrome_length =\
    \ 0;\n    let mut max_palindrome_index = 0;\n\n    for i in 0..string.len() {\n\
    \        let (mut suffix_length, mut prefix_length) = (0, 0);\n        let (mut\
    \ suffix_index, mut prefix_index) = (i, i);\n\n        while suffix_index >= 0\
    \ && prefix_index < string.len() {\n            suffix_length += 1;\n        \
    \    prefix_length += 1;\n\n            suffix = string.chars().skip(suffix_index).take(suffix_length).collect();\n\
    \            prefix = string.chars().skip(prefix_index).take(prefix_length).collect();\n\
    \n            if suffix == prefix {\n                if suffix_length > max_palindrome_length\
    \ {\n                    max_palindrome_length = suffix_length;\n            \
    \        max_palindrome_index = suffix_index;\n                }\n           \
    \ }\n\n            suffix_index -= 1;\n            prefix_index += 1;\n      \
    \  }\n    }\n\n    palindrome = string.chars().skip(max_palindrome_index).take(max_palindrome_length).collect();\n\
    \    string.push_str(&palindrome.chars().rev().collect::<String>());\n\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpb6ndk7q6.rs:37:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    string.push_str(&string[..string.len() - palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpc_muwhje.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp5004tv5r.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut palindrome_len = 0;\n    let mut palindrome_start = 0;\n \
    \   let mut palindrome_end = 0;\n    let mut max_palindrome_len = 0;\n    let\
    \ mut max_palindrome_start = 0;\n    let mut max_palindrome_end = 0;\n    let\
    \ mut max_palindrome_suffix_len = 0;\n    let mut max_palindrome_prefix_len =\
    \ 0;\n    let mut max_palindrome_suffix = String::new();\n    let mut max_palindrome_prefix\
    \ = String::new();\n    let mut max_palindrome = String::new();\n    let mut string_len\
    \ = string.len();\n    let mut string_chars = string.chars();\n    let mut string_chars_rev\
    \ = string.chars().rev();\n    let mut string_chars_rev_vec = string.chars().rev().collect::<Vec<char>>();\n\
    \    let mut string_chars_vec = string.chars().collect::<Vec<char>>();\n    let\
    \ mut string_chars_rev_len = string_chars_rev_vec.len();\n    let mut string_chars_len\
    \ = string_chars_vec.len();\n    let mut string_chars_rev_iter = string_chars_rev_vec.iter();\n\
    \    let mut string_chars_iter = string_chars_vec.iter();\n    let mut string_chars_rev_iter_clone\
    \ = string_chars_rev_vec.iter();\n    let mut string_chars_iter_clone = string_chars_vec.iter();\n\
    \    let mut string_chars_rev_iter_clone_clone = string_chars_rev_vec.iter();\n\
    \    let mut string_chars_iter_clone_clone = string_chars_vec.iter();\n   \n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf1by9ou.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = string.len();\n    while\
    \ i > 0 {\n        let (s, p) = string.split_at(i);\n        if is_palindrome(s)\
    \ {\n            suffix = s.to_string();\n            prefix = p.to_string();\n\
    \            break;\n        }\n        i -= 1;\n    }\n    palindrome.push_str(&prefix);\n\
    \    palindrome.push_str(&suffix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmphw1po3w0.rs:19:12\n   |\n19 |         if is_palindrome(s) {\n   |  \
    \          ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `palindrome`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = String::new();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut longest_palindrome_length =\
    \ 0;\n    let mut longest_palindrome_index = 0;\n\n    for i in 0..string.len()\
    \ {\n        let (p, s) = string.split_at(i);\n        if is_palindrome(p) {\n\
    \            if p.len() > longest_palindrome_length {\n                longest_palindrome_length\
    \ = p.len();\n                longest_palindrome_index = i;\n            }\n \
    \       }\n    }\n\n    let (p, s) = string.split_at(longest_palindrome_index);\n\
    \    prefix = p.to_string();\n    suffix = s.to_string();\n    palindrome.push_str(&prefix);\n\
    \    palindrome.push_str(&suffix.chars().rev().collect::<String>());\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxhta0ep8.rs:21:12\n   |\n21 |         if is_palindrome(p) {\n   |  \
    \          ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `palindrome`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = string.len();\n    while i > 0 {\n       \
    \ let (prefix, suffix) = string.split_at(i);\n        if is_palindrome(suffix)\
    \ {\n            palindrome_suffix = suffix.to_string();\n            palindrome_prefix\
    \ = prefix.chars().rev().collect();\n            break;\n        }\n        i\
    \ -= 1;\n    }\n    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpa84_w1xd.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while\
    \ i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n     \
    \       prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmrr6nxzx.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpn_ufdqd3.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpz2gle75r.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            palindrome.push(string.chars().nth(i).unwrap());\n          \
    \  i += 1;\n            j -= 1;\n        } else {\n            if palindrome.len()\
    \ > 0 {\n                suffix = palindrome.clone();\n                prefix\
    \ = string.chars().take(i).collect();\n                break;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n    }\n    if palindrome.len()\
    \ > 0 {\n        suffix = palindrome.clone();\n        prefix = string.chars().take(i).collect();\n\
    \    }\n    prefix.chars().rev().collect::<String>() + &suffix + &prefix\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqpa4bz_f.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            palindrome_suffix = suffix.to_string();\n            break;\n   \
    \     }\n    }\n    let prefix = &string[..string.len() - palindrome_suffix.len()];\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp5tg0ot14.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmbzuq3ao.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    palindrome_suffix.clear();\n            palindrome_suffix_len = 0;\n    \
    \        i = 0;\n            j -= 1;\n        }\n    }\n    palindrome_prefix_len\
    \ = string.len() - palindrome_suffix_len;\n    palindrome_prefix = string.chars().take(palindrome_prefix_len).collect();\n\
    \    palindrome_prefix = palindrome_prefix.chars().rev().collect();\n    string.push_str(&palindrome_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzkl8obxj.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = string.clone();\n    suffix.reverse();\n   \
    \ let mut prefix = string.clone();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        if suffix.starts_with(&prefix) {\n            break;\n        }\n\
    \        prefix.remove(0);\n        i += 1;\n    }\n    let mut result = string.clone();\n\
    \    result.push_str(&suffix[i..]);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp56p64776.rs:14:12\n   |\n14 |     suffix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = string.len();\n    while i > 0 {\n        suffix.push_str(&string[i\
    \ - 1..i]);\n        prefix.push_str(&string[..i]);\n        if is_palindrome(&prefix)\
    \ {\n            break;\n        }\n        i -= 1;\n    }\n    string.push_str(&suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_2bwfkzo.rs:19:12\n   |\n19 |         if is_palindrome(&prefix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n \
    \   let mut max_palindrome_len = 0;\n    let mut max_palindrome_pos = 0;\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n   \n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk065u9py.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpzvy40_e8.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut is_palindrome = false;\n    let mut i = 0;\n    let mut j\
    \ = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ palindrome_suffix.clear();\n            palindrome_prefix.clear();\n       \
    \     palindrome_suffix_length = 0;\n            palindrome_prefix_length = 0;\n\
    \            i = 0;\n            j -= 1;\n        }\n        if palindrome_suffix_length\
    \ > 0 && palindrome_prefix_length > 0 {\n            is_palindrome = true;\n \
    \       }\n    }\n    if is_palindrome {\n        let mut prefix = String::new();\n\
    \        for i in 0..string.len() - palindrome_suffix_length {\n            prefix.push(string.chars().nth(i).unwrap());\n\
    \        }\n        let mut suffix = String::new();\n        for i in 0..palindrome_prefix_length\
    \ {\n            suffix.push(palindrome_prefix.chars().nth(palindrome_prefix_length\
    \ - i - 1).unwrap());\n        }\n        string.push_str(&suffix);\n        string.insert_str(0,\
    \ &prefix);\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjt7ldrfc.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let (s, p) = string.split_at(i);\n        if is_palindrome(s) {\n\
    \            prefix = p.to_string();\n            break;\n        }\n        i\
    \ += 1;\n    }\n    suffix = prefix.chars().rev().collect();\n    palindrome.push_str(&suffix);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyuxytt50.rs:19:12\n   |\n19 |         if is_palindrome(s) {\n   |  \
    \          ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `palindrome`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut prefix_len = 0;\n    while !is_palindrome(&suffix)\
    \ {\n        suffix.pop();\n        prefix.push(string.chars().nth(prefix_len).unwrap());\n\
    \        prefix_len += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsvls4dui.rs:16:12\n   |\n16 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut longest_palindrome_suffix_index_end = 0;\n    let mut longest_palindrome_suffix_index_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_end = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start = 0;\n    let mut longest_palindrome_suffix_index_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start = 0;\n \
    \   let mut longest_palindrome_suffix_index_start_start_start_end = 0;\n    let\
    \ mut longest_palindrome_suffix_index_start_start_start_start = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start_start_start_end = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start_start_start_start = 0;\n    let\
    \ mut longest_palindrome_suffix_index_start_start_start_start_start_end = 0;\n\
    \    let mut longest_palindrome_suffix_index_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_start_end\
    \ = 0;\n   \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7es2qy47.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    for i in 0..string.len() {\n       \
    \ let suffix = &string[i..];\n        if is_palindrome(suffix) {\n           \
    \ if suffix.len() > longest_palindrome_suffix_len {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_len = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_len];\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwjncnwam.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    palindrome.push_str(&string);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpva8xrdgf.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpspkgcrvh.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n  \
    \      if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            break;\n        }\n    }\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp65momj6b.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut palindrome_length = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let\
    \ mut iii = 0;\n    let mut jjj = 0;\n   \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsh0zphvp.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxbbvhbjz.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = string.clone();\n    let mut suffix\
    \ = String::new();\n    let mut is_palindrome = false;\n    while !is_palindrome\
    \ {\n        suffix.push(prefix.pop().unwrap());\n        is_palindrome = is_palindrome_string(&prefix);\n\
    \    }\n    result.push_str(&suffix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome_string` in this scope\n\
    \  --> /tmp/tmpwl7ta4kh.rs:18:25\n   |\n18 |         is_palindrome = is_palindrome_string(&prefix);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = String::new();\n    let mut prefix =\
    \ String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while\
    \ i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n     \
    \       suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzlo_puxa.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    palindrome_suffix.clear();\n            palindrome_suffix_len = 0;\n    \
    \        i = 0;\n            j -= 1;\n        }\n    }\n    palindrome_prefix\
    \ = palindrome_suffix.chars().rev().collect();\n    palindrome_prefix_len = palindrome_suffix_len;\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpsr44d8qs.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_length];\n\
    \    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n   \
    \ string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpti0qt0_4.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpkh8jjc8i.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string.clone();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i..=i] == s[j..=j] {\n            i += 1;\n            j -= 1;\n      \
    \  } else {\n            s.insert(j + 1, s[i]);\n            j += 1;\n       \
    \ }\n    }\n    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9v8rdp8r.rs:20:29\n\
    \   |\n20 |             s.insert(j + 1, s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    reversed.reverse();\n    let mut palindrome = string.clone();\n\
    \    palindrome.push_str(&reversed);\n    let mut longest_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        let\
    \ prefix = &string[..string.len() - i];\n        if suffix == prefix {\n     \
    \       longest_suffix = suffix.to_string();\n        }\n    }\n    let mut prefix\
    \ = string.clone();\n    prefix.truncate(string.len() - longest_suffix.len());\n\
    \    prefix.reverse();\n    palindrome.push_str(&prefix);\n    palindrome\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpeeouts10.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpeeouts10.rs:26:12\n   |\n26 | \
    \    prefix.reverse();\n   |            ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut is_palindrome = false;\n    while !is_palindrome\
    \ {\n        let suffix_len = suffix.len();\n        let prefix_len = prefix.len();\n\
    \        if suffix_len == 0 {\n            break;\n        }\n        if suffix_len\
    \ == 1 {\n            result.push(suffix.pop().unwrap());\n            break;\n\
    \        }\n        if suffix_len == 2 {\n            let last = suffix.pop().unwrap();\n\
    \            let first = suffix.pop().unwrap();\n            if last == first\
    \ {\n                result.push(last);\n                result.push(first);\n\
    \                break;\n            } else {\n                result.push(first);\n\
    \                result.push(last);\n                break;\n            }\n \
    \       }\n        let last = suffix.pop().unwrap();\n        let first = suffix.pop().unwrap();\n\
    \        if last == first {\n            result.push(last);\n            prefix.push(first);\n\
    \            is_palindrome = true;\n        } else {\n            result.push(first);\n\
    \            result.push(last);\n            is_palindrome = false;\n        }\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp41pod1zy.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmlw75v5z.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    palindrome.push_str(&string);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp10a7347h.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut j = 0;\n        while i + j < string.len() && string.chars().nth(i\
    \ + j) == string.chars().nth(string.len() - 1 - j) {\n            j += 1;\n  \
    \      }\n        if j > longest_palindrome_suffix_len {\n            longest_palindrome_suffix_len\
    \ = j;\n            longest_palindrome_suffix = string.chars().skip(i).take(j).collect();\n\
    \        }\n        i += 1;\n    }\n    string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpajv6a5fx.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_pos\
    \ = 0;\n    let mut longest_palindrome_prefix = String::new();\n    let mut longest_palindrome_prefix_len\
    \ = 0;\n    let mut longest_palindrome_prefix_pos = 0;\n    let mut longest_palindrome_len\
    \ = 0;\n    let mut longest_palindrome_pos = 0;\n    let mut longest_palindrome\
    \ = String::new();\n    let mut string_len = string.len();\n    let mut string_pos\
    \ = 0;\n    let mut string_rev = string.chars().rev().collect::<String>();\n \
    \   let mut string_rev_len = string_rev.len();\n    let mut string_rev_pos = 0;\n\
    \    let mut string_rev_chars = string_rev.chars();\n    let mut string_chars\
    \ = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n  \
    \  let mut string_chars_rev_len = string_chars_rev.len();\n    let mut string_chars_rev_pos\
    \ = 0;\n    let mut string_chars_len = string_chars.len();\n    let mut string_chars_pos\
    \ = 0;\n    let mut string_chars_rev_next = string_chars_rev.next();\n    let\
    \ mut string_chars_next = string_chars.next();\n    let mut string_chars_rev_next_char\
    \ = ' ';\n    let mut string_chars_next_char = ' ';\n    let mut string_chars_rev_next_char_opt\
    \ = None;\n    let mut string_chars_next_char_opt = None;\n    let mut string_chars_rev_next_char_opt_clone\
    \ = None;\n    let mut string_chars_next_char_opt_clone = None;\n    let mut string_chars_rev_next_char_opt_clone_clone\
    \ = None;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `len` exists for struct `Rev<Chars<'_>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpqze_yzh1.rs:30:53\n   |\n\
    30 |       let mut string_chars_rev_len = string_chars_rev.len();\n   |      \
    \                                                 ^^^ method cannot be called\
    \ on `Rev<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n\
    \           which is required by `Rev<Chars<'_>>: ExactSizeIterator`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpqze_yzh1.rs:32:45\n\
    \   |\n32 |     let mut string_chars_len = string_chars.len();\n   |         \
    \                                    ^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqze_yzh1.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut suffix_len = string.len();\n\
    \    while suffix_len > 0 {\n        let suffix = &string[string.len() - suffix_len..];\n\
    \        if is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            longest_palindrome_suffix_len = suffix_len;\n            break;\n\
    \        }\n        suffix_len -= 1;\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpiv47ysi7.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n  \
    \  while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            palindrome_suffix.push(string.chars().nth(i).unwrap());\n       \
    \     palindrome_prefix.push(string.chars().nth(j).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            i = 0;\n            j\
    \ -= 1;\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpo3yviyhc.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    for i in 0..string.len() {\n\
    \        let (p, s) = string.split_at(i);\n        if p == s.chars().rev().collect::<String>()\
    \ && p.len() > longest_palindrome_length {\n            longest_palindrome_length\
    \ = p.len();\n            prefix = p.to_string();\n            suffix = s.to_string();\n\
    \        }\n    }\n    format!(\"{}{}{}\", prefix, suffix.chars().rev().collect::<String>(),\
    \ suffix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"x\"`', /tmp/tmpg8f98fke.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut result = String::new();\n    let mut palindrome_length = 0;\n   \
    \ let mut palindrome_index = 0;\n    let mut i = 0;\n    let mut j = 0;\n\n  \
    \  if string.len() == 0 {\n        return string;\n    }\n\n    while i < string.len()\
    \ {\n        j = 0;\n        while j < string.len() - i {\n            if string.chars().nth(i\
    \ + j) != string.chars().nth(string.len() - 1 - j) {\n                break;\n\
    \            }\n            j += 1;\n        }\n        if j > palindrome_length\
    \ {\n            palindrome_length = j;\n            palindrome_index = i;\n \
    \       }\n        i += 1;\n    }\n\n    suffix = string.chars().skip(palindrome_index).take(palindrome_length).collect();\n\
    \    prefix = string.chars().take(palindrome_index).collect();\n    result.push_str(&suffix);\n\
    \    result.push_str(&prefix.chars().rev().collect::<String>());\n\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpc48t_noj.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmps61bl_f9.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n  \
    \  let mut is_palindrome = true;\n    while i < j {\n        if string.chars().nth(i)\
    \ != string.chars().nth(j) {\n            is_palindrome = false;\n           \
    \ break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    if is_palindrome\
    \ {\n        return string;\n    }\n    i = 0;\n    j = string.len() - 1;\n  \
    \  while i < j {\n        if string.chars().nth(i) != string.chars().nth(j) {\n\
    \            palindrome_suffix.push(string.chars().nth(i).unwrap());\n       \
    \     palindrome_prefix.push(string.chars().nth(j).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        }\n    }\n    if i == j {\n\
    \        palindrome_suffix.push(string.chars().nth(i).unwrap());\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpx1m2cyja.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut max_palindrome_len = 0;\n    let mut max_palindrome_pos =\
    \ 0;\n    let mut string_len = string.len();\n    let mut string_chars = string.chars();\n\
    \    let mut string_chars_rev = string.chars().rev();\n    let mut string_chars_rev_iter\
    \ = string_chars_rev.clone();\n    let mut string_chars_iter = string_chars.clone();\n\
    \    let mut string_chars_iter_rev = string_chars_rev.clone();\n    let mut string_chars_iter_rev_iter\
    \ = string_chars_rev.clone();\n    let mut string_chars_iter_iter = string_chars.clone();\n\
    \    let mut string_chars_iter_iter_rev = string_chars_rev.clone();\n    let mut\
    \ string_chars_iter_iter_rev_iter = string_chars_rev.clone();\n    let mut string_chars_iter_iter_iter\
    \ = string_chars.clone();\n    let mut string_chars_iter_iter_iter_rev = string_chars_rev.clone();\n\
    \    let mut string_chars_iter_iter_iter_rev_iter = string_chars_rev.clone();\n\
    \    let mut string_chars_iter_iter_iter_iter = string_chars.clone();\n    let\
    \ mut string_chars_iter_iter_iter_iter_rev = string_chars_rev.clone();\n    let\
    \ mut string_chars_iter_iter_iter_iter_rev_iter = string_chars_rev.clone();\n\
    \    let mut string_chars_iter_iter_iter_iter_iter = string_chars.clone();\n \
    \   let mut string_chars_iter_iter_iter_iter_iter_rev = string_chars_rev.clone();\n\
    \    let mut\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp41u68nzi.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_index\
    \ = 0;\n    for i in 0..string.len() {\n        let (mut p, mut s) = string.split_at(i);\n\
    \        if p.len() > s.len() {\n            break;\n        }\n        if p ==\
    \ s.chars().rev().collect::<String>() {\n            if p.len() > longest_palindrome_length\
    \ {\n                longest_palindrome_length = p.len();\n                longest_palindrome_index\
    \ = i;\n            }\n        }\n    }\n    let (prefix, suffix) = string.split_at(longest_palindrome_index);\n\
    \    string.push_str(prefix.chars().rev().collect::<String>().as_str());\n   \
    \ string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmp90888qfd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut is_palindrome = false;\n\
    \    let mut i = 0;\n    while !is_palindrome {\n        if i >= string.len()\
    \ {\n            break;\n        }\n        suffix.push(string.pop().unwrap());\n\
    \        if is_palindrome(&string) {\n            is_palindrome = true;\n    \
    \    }\n        i += 1;\n    }\n    if is_palindrome {\n        palindrome.push_str(&string);\n\
    \        palindrome.push_str(&suffix);\n        palindrome.push_str(&prefix);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmpxurz3wtt.rs:23:12\n\
    \   |\n16 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n23 |         if is_palindrome(&string)\
    \ {\n   |            ^^^^^^^^^^^^^---------\n   |            |\n   |         \
    \   call expression requires function\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_length];\n\
    \    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n   \
    \ string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpd6b62qv1.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    let mut suffix_length = 1;\n    while\
    \ suffix_length <= string.len() {\n        let suffix = &string[string.len() -\
    \ suffix_length..];\n        if is_palindrome(suffix) {\n            longest_palindrome_suffix\
    \ = suffix.to_string();\n            longest_palindrome_suffix_length = suffix_length;\n\
    \        }\n        suffix_length += 1;\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpkdrs3g5x.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    reversed.reverse();\n    let mut result = string.clone();\n\
    \    result.push_str(&reversed);\n    let mut suffix = String::new();\n    let\
    \ mut prefix = String::new();\n    for i in 0..string.len() {\n        suffix.push(string.chars().nth(i).unwrap());\n\
    \        prefix.push(reversed.chars().nth(i).unwrap());\n        if suffix ==\
    \ prefix {\n            result = string.clone();\n            result.push_str(&reversed[i\
    \ + 1..].chars().rev().collect::<String>());\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptd9n37t3.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = longest_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    prefix.reverse();\n    string.push_str(&prefix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmp6fhygsyv.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n   |                                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmp6fhygsyv.rs:15:12\n\
    \   |\n15 |     prefix.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    longest_palindrome_suffix = suffix.to_string();\n            longest_palindrome_suffix_length\
    \ = i;\n        }\n    }\n    let prefix = &string[..longest_palindrome_suffix_length];\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpza2p_7x8.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if i == j {\n        palindrome.push_str(&string);\n  \
    \      palindrome.push(string.chars().nth(i).unwrap());\n    } else {\n      \
    \  palindrome.push_str(&string);\n        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppan1hztn.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_index\
    \ = 0;\n    let mut current_palindrome_length = 0;\n    let mut current_palindrome_index\
    \ = 0;\n    let mut current_palindrome_prefix_index = 0;\n    let mut current_palindrome_suffix_index\
    \ = 0;\n    let mut current_palindrome_prefix = String::new();\n    let mut current_palindrome_suffix\
    \ = String::new();\n    let mut current_palindrome_prefix_reversed = String::new();\n\
    \    let mut current_palindrome_suffix_reversed = String::new();\n    let mut\
    \ current_palindrome_prefix_reversed_chars = Vec::new();\n    let mut current_palindrome_suffix_reversed_chars\
    \ = Vec::new();\n    let mut current_palindrome_prefix_chars = Vec::new();\n \
    \   let mut current_palindrome_suffix_chars = Vec::new();\n    let mut string_chars\
    \ = string.chars().collect::<Vec<char>>();\n    let string_length = string_chars.len();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n   \n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmwf9wn5z.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let ch = suffix.remove(0);\n\
    \        prefix.push(ch);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp38p3tp6j.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9qnxzft8.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(palindrome_suffix.len());\n    prefix.reverse();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmpvuxn89up.rs:13:33\n   |\n13 |     let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `reverse` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpvuxn89up.rs:15:12\n   |\n15 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix_length += 1;\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            palindrome_suffix_length\
    \ = 0;\n            palindrome_suffix.clear();\n            i = 0;\n         \
    \   j -= 1;\n        }\n    }\n    if palindrome_suffix_length == 0 {\n      \
    \  palindrome_suffix_length = 1;\n        palindrome_suffix.push(string.chars().nth(0).unwrap());\n\
    \    }\n    palindrome_prefix_length = string.len() - palindrome_suffix_length;\n\
    \    for i in 0..palindrome_prefix_length {\n        palindrome_prefix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpheq5avx4.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut prefix = String::new();\n    let mut suffix =\
    \ String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while\
    \ i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n     \
    \       prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmlcbr677.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    let mut k = 0;\n \
    \   let mut l = 0;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            i += 1;\n            j -= 1;\n        } else {\n            i\
    \ = 0;\n            j = string.len() - 1 - k;\n            k += 1;\n        }\n\
    \    }\n    l = string.len() - k;\n    suffix = string.chars().skip(l).collect();\n\
    \    prefix = string.chars().take(l).collect();\n    string.push_str(&suffix);\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdhdl2fbm.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_index\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ if i + 1 == j {\n                longest_palindrome_length = 2;\n          \
    \      longest_palindrome_index = i;\n            } else {\n                longest_palindrome_length\
    \ = j - i + 1;\n                longest_palindrome_index = i;\n            }\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    if longest_palindrome_length\
    \ > 0 {\n        suffix = string.chars().skip(longest_palindrome_index).take(longest_palindrome_length).collect();\n\
    \        prefix = string.chars().take(longest_palindrome_index).collect();\n \
    \   }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9_rk535f.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n  \
    \      if string.chars().nth(i) == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            break;\n        }\n    }\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu6vt5he8.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplrazba1z.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut i = 0;\n    let mut j =\
    \ string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if i == j {\n        palindrome.push_str(&string);\n  \
    \      palindrome.push(string.chars().nth(i).unwrap());\n    } else {\n      \
    \  palindrome.push_str(&string);\n        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzxdt1wtw.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    prefix.reverse();\n    string.push_str(&prefix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmp3ryq3nfi.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp3ryq3nfi.rs:15:12\n   |\n15 |     prefix.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_pos\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ if i + 1 == j {\n                if longest_palindrome_suffix_len < 2 {\n  \
    \                  longest_palindrome_suffix_len = 2;\n                    longest_palindrome_suffix_pos\
    \ = i;\n                }\n            } else {\n                if longest_palindrome_suffix_len\
    \ < j - i + 1 {\n                    longest_palindrome_suffix_len = j - i + 1;\n\
    \                    longest_palindrome_suffix_pos = i;\n                }\n \
    \           }\n        }\n        i += 1;\n        j -= 1;\n    }\n    if longest_palindrome_suffix_len\
    \ > 0 {\n        longest_palindrome_suffix = string.chars().skip(longest_palindrome_suffix_pos).take(longest_palindrome_suffix_len).collect();\n\
    \        string.truncate(longest_palindrome_suffix_pos);\n        string.push_str(&longest_palindrome_suffix);\n\
    \        string.push_str(&string.chars().rev().collect::<String>());\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7f_8y2zb.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = String::new();\n    let mut prefix =\
    \ String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while\
    \ i < j {\n        if result[i..j] == result[i..j].chars().rev().collect::<String>()\
    \ {\n            suffix = result[i..j].to_string();\n            prefix = result[0..i].to_string();\n\
    \            break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpci642e21.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut palindrome = String::new();\n    let mut max_palindrome_length =\
    \ 0;\n    let mut max_palindrome_index = 0;\n\n    for i in 0..string.len() {\n\
    \        let (mut left, mut right) = (i, i);\n        let mut palindrome_length\
    \ = 0;\n\n        while left >= 0 && right < string.len() {\n            if string.chars().nth(left)\
    \ == string.chars().nth(right) {\n                palindrome_length += 1;\n  \
    \              left -= 1;\n                right += 1;\n            } else {\n\
    \                break;\n            }\n        }\n\n        if palindrome_length\
    \ > max_palindrome_length {\n            max_palindrome_length = palindrome_length;\n\
    \            max_palindrome_index = i;\n        }\n    }\n\n    if max_palindrome_length\
    \ > 0 {\n        suffix = string.chars().skip(max_palindrome_index - max_palindrome_length\
    \ + 1).take(max_palindrome_length).collect();\n        prefix = string.chars().take(max_palindrome_index\
    \ - max_palindrome_length + 1).collect();\n        palindrome = string.chars().skip(max_palindrome_index\
    \ - max_palindrome_length + 1).take(max_palindrome_length).collect();\n    }\n\
    \n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6fyg79f4.rs:26:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut prefix_len = 0;\n    while !is_palindrome(&suffix)\
    \ {\n        prefix.push(suffix.pop().unwrap());\n        prefix_len += 1;\n \
    \   }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppqxtlyad.rs:16:12\n   |\n16 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_pos\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev = 0;\n    let mut longest_palindrome_suffix_pos_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev = 0;\n    let mut\
    \ longest_palindrome_suffix_pos_rev_len_rev_pos = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len = 0;\n\
    \    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev = 0;\n\
    \    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos = 0;\n\
    \    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len_rev_pos\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len_rev_pos_rev\
    \ = 0;\n    let mut longest_palindrome_suffix_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len_rev_pos_rev_len\
    \ = 0;\n    let mut longest\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1wre5g3u.rs:30:20\n   |\n\
    30 |     let mut longest\n   |                    ^ help: add `;` here\n31 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wre5g3u.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        let c = suffix.pop().unwrap();\n\
    \        prefix.push(c);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpze29fwml.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !suffix.is_empty() {\n        if is_palindrome(&suffix)\
    \ {\n            palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            return palindrome;\n        }\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmphe81diop.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !is_palindrome(&suffix) {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8t4es24l.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut i = 0;\n    let mut j = string.len() - 1;\n  \
    \  while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            palindrome_suffix.push(string.chars().nth(i).unwrap());\n       \
    \     palindrome_prefix.push(string.chars().nth(j).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            i = 0;\n            j\
    \ -= 1;\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcf6irjuu.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    if suffix.len() > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_length];\n\
    \    let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n   \
    \ string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp5guguqoa.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string.ends_with(&reversed[i..])\
    \ {\n            result.push_str(&reversed[..i]);\n            break;\n      \
    \  }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmproash36a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ palindrome_suffix.push(string.chars().nth(i).unwrap());\n            palindrome_suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    palindrome_suffix.clear();\n            palindrome_suffix_len = 0;\n    \
    \        i = 0;\n            j -= 1;\n        }\n    }\n    palindrome_prefix\
    \ = palindrome_suffix.chars().rev().collect();\n    palindrome_prefix_len = palindrome_suffix_len;\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt4ca10ta.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if result.starts_with(&reversed[i..])\
    \ {\n            result.push_str(&reversed[..i]);\n            break;\n      \
    \  }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmp6ce2ieiy.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_start\
    \ = 0;\n    for i in 0..string.len() {\n        let mut j = 0;\n        while\
    \ i + j < string.len() && string.chars().nth(i + j) == string.chars().nth(string.len()\
    \ - 1 - j) {\n            j += 1;\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j;\n            longest_palindrome_start\
    \ = i;\n        }\n    }\n    suffix = string.chars().skip(longest_palindrome_start).take(longest_palindrome_length).collect();\n\
    \    prefix = string.chars().take(string.len() - longest_palindrome_length).collect();\n\
    \    prefix.chars().rev().chain(string.chars()).collect()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"yxxyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpq5k97u_5.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut suffix = String::new();\n    let mut prefix = String::new();\n\
    \    let mut is_palindrome = false;\n    let mut i = 0;\n    while !is_palindrome\
    \ {\n        let (s, p) = string.split_at(i);\n        suffix = s.to_string();\n\
    \        prefix = p.to_string();\n        is_palindrome = is_palindrome(&suffix);\n\
    \        i += 1;\n    }\n    let mut result = suffix.clone();\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp1lolqe_u.rs:21:25\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n21 |         is_palindrome = is_palindrome(&suffix);\n\
    \   |                         ^^^^^^^^^^^^^---------\n   |                   \
    \      |\n   |                         call expression requires function\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome_suffix = String::new();\n    let mut palindrome_prefix\
    \ = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n    let\
    \ mut longest_palindrome_suffix_index = 0;\n    for i in 0..string.len() {\n \
    \       let suffix = &string[i..];\n        if is_palindrome(suffix) {\n     \
    \       if suffix.len() > longest_palindrome_suffix_length {\n               \
    \ longest_palindrome_suffix_length = suffix.len();\n                longest_palindrome_suffix_index\
    \ = i;\n            }\n        }\n    }\n    palindrome_suffix = string.split_off(longest_palindrome_suffix_index);\n\
    \    palindrome_prefix = string.chars().rev().collect();\n    palindrome_suffix.push_str(&palindrome_prefix);\n\
    \    palindrome_suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_3p8o91z.rs:19:12\n   |\n19 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed = string.clone();\n    reversed.reverse();\n\
    \    let mut suffix = String::new();\n    for i in 0..string.len() {\n       \
    \ if string[i..] == reversed[..string.len() - i] {\n            suffix = string[i..].to_string();\n\
    \            break;\n        }\n    }\n    string.push_str(&suffix);\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwu4n7949.rs:14:14\n   |\n14 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    while !suffix.is_empty()\
    \ {\n        if is_palindrome(&suffix) {\n            palindrome_suffix_len =\
    \ suffix.len();\n            break;\n        }\n        let last_char = suffix.pop().unwrap();\n\
    \        prefix.push(last_char);\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result.drain(..palindrome_suffix_len);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpejk6qf91.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::new();\n    while !suffix.is_empty() {\n        if is_palindrome(&suffix)\
    \ {\n            result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            return result;\n        }\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpqrhp1jv0.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    for i\
    \ in 0..string.len() {\n        let suffix = string.split_off(string.len() - i);\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n            break;\n        }\n    }\n    let prefix = string.split_off(string.len()\
    \ - longest_palindrome_suffix.len());\n    prefix + &longest_palindrome_suffix\
    \ + &prefix.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp30yjkg4n.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    for i in 0..string.len() {\n       \
    \ let suffix = &string[i..];\n        if is_palindrome(suffix) {\n           \
    \ if suffix.len() > longest_palindrome_suffix_len {\n                longest_palindrome_suffix\
    \ = suffix.to_string();\n                longest_palindrome_suffix_len = suffix.len();\n\
    \            }\n        }\n    }\n    let prefix = &string[..string.len() - longest_palindrome_suffix_len];\n\
    \    let prefix_reversed = prefix.chars().rev().collect::<String>();\n    string.push_str(&prefix_reversed);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpueybj1m2.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_palindrome_suffix = String::new();\n    let mut\
    \ longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_end = 0;\n    let mut longest_palindrome_suffix_center\
    \ = 0;\n    let mut longest_palindrome_suffix_center_len = 0;\n    let mut longest_palindrome_suffix_center_start\
    \ = 0;\n    let mut longest_palindrome_suffix_center_end = 0;\n    let mut longest_palindrome_suffix_center_center\
    \ = 0;\n    let mut longest_palindrome_suffix_center_center_len = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_start = 0;\n    let mut longest_palindrome_suffix_center_center_end\
    \ = 0;\n    let mut longest_palindrome_suffix_center_center_center = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_len = 0;\n    let mut longest_palindrome_suffix_center_center_center_start\
    \ = 0;\n    let mut longest_palindrome_suffix_center_center_center_end = 0;\n\
    \    let mut longest_palindrome_suffix_center_center_center_center = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_center_len = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_center_start = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_center_end = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_center_center = 0;\n    let\
    \ mut longest_palindrome_suffix_center_center_center_center_center_len = 0;\n\
    \    let mut longest_palindrome_suffix_center_center_center_center_center_start\
    \ = 0;\n    let mut longest_palindrome_suffix_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqfuji1rt.rs:36:39\n   |\n\
    36 |     let mut longest_palindrome_suffix_\n   |                            \
    \           ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqfuji1rt.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
