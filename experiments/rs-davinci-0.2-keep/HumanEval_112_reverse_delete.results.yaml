name: HumanEval_112_reverse_delete
language: rust
results:
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppgvf47dd.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmruu_kx9.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    let s_rev: String = s.chars().rev().collect();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpy9sbrccl.rs:12:9\n\
    \   |\n12 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpy9sbrccl.rs:16:9\n\
    \   |\n14 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    15 |     let s_rev: String = s.chars().rev().collect();\n16 |     (s, s == s_rev)\n\
    \   |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let mut s1 = s.clone();\n\
    \    s1.make_ascii_lowercase();\n    let mut s2 = s1.clone();\n    s2.make_ascii_lowercase();\n\
    \    s2.chars().rev().collect::<String>() == s1 && s != \"\"\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoygj2zne.rs:20:5\n   |\n\
    10 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                                     -------------- expected `(String, bool)`\
    \ because of return type\n...\n20 |     s2.chars().rev().collect::<String>() ==\
    \ s1 && s != \"\"\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n\
    \               found type `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let c: HashSet<char> =\
    \ c.chars().collect();\n    s.retain(|c| !c.is_ascii_lowercase() || !c.is_ascii_uppercase());\n\
    \    (s, s.chars().rev().collect::<String>() == s)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8wpod_rn.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg6qn9w3r.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp99dqzmf7.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpqizic0jh.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result: String = s.chars().filter(|&x|\
    \ !c.contains(x)).collect();\n    let mut is_palindrome = true;\n    let mut i\
    \ = 0;\n    let mut j = result.len() - 1;\n    while i < j {\n        if result.chars().nth(i)\
    \ != result.chars().nth(j) {\n            is_palindrome = false;\n           \
    \ break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptrh0b_h5.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpiayvd96x.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp52nm71dt.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n \
    \   let c: Vec<char> = c.chars().collect();\n    let mut result: Vec<char> = Vec::new();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    let mut result_str: String = String::new();\n    for i\
    \ in 0..result.len() {\n        result_str.push(result[i]);\n    }\n    let mut\
    \ result_str_rev: String = String::new();\n    for i in 0..result.len() {\n  \
    \      result_str_rev.push(result[result.len() - i - 1]);\n    }\n    (result_str,\
    \ result_str == result_str_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result_str`\n  --> /tmp/tmpdm_bkm4i.rs:27:18\n\
    \   |\n19 |     let mut result_str: String = String::new();\n   |         --------------\
    \ move occurs because `result_str` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n27 |     (result_str, result_str == result_str_rev)\n\
    \   |      ----------  ^^^^^^^^^^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9_nk0hkm.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4dyzxh2_.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmprvzu3zbo.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp1y9mp97l.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp042u9fjj.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpz9lbpxhp.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpz9lbpxhp.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpe6827t78.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp_7zagz48.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4qv3fjgd.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp92guk7b9.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpkxfol9or.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp93dz87vq.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmplac10xzz.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpizmlzix7.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpetqwaec_.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpm0ba9ypf.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut res = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    let mut res_rev = res.clone();\n    res_rev.chars().rev().collect::<String>();\n\
    \    (res, res == res_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmptdxwq1aq.rs:11:9\n\
    \   |\n11 |     let mut res = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         ----^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmptdxwq1aq.rs:12:9\n   |\n12 |     let mut\
    \ res_rev = res.clone();\n   |         ----^^^^^^^\n   |         |\n   |     \
    \    help: remove this `mut`\n\nerror[E0382]: borrow of moved value: `res`\n \
    \ --> /tmp/tmptdxwq1aq.rs:14:11\n   |\n11 |     let mut res = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n   |         ------- move occurs because\
    \ `res` has type `String`, which does not implement the `Copy` trait\n...\n14\
    \ |     (res, res == res_rev)\n   |      ---  ^^^ value borrowed here after move\n\
    \   |      |\n   |      value moved here\n\nerror: aborting due to previous error;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpwjf5eite.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp93sptx2z.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps061rx68.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8ci0vdx3.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmphifm3bbg.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpcezv_f6w.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s: String = s.chars().rev().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpoymj1dh1.rs:16:9\n\
    \   |\n15 |     let s: String = s.chars().rev().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    16 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.make_ascii_lowercase();\n    s_rev = s_rev.chars().rev().collect();\n\
    \    (s, s_rev == s)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpl8ad2s2i.rs:18:18\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s_rev == s)\n   |      -           ^ value borrowed here after move\n   |  \
    \    |\n   |      value moved here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpzpl8s0qn.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpa65tp5l7.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpa1hd163q.rs:12:9\n\
    \   |\n12 |     let mut s = s.chars().collect::<Vec<char>>();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpa1hd163q.rs:19:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n19 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpld5108ym.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpchzquflg.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcm4drpjo.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpiartjvzx.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut result_rev = String::new();\n    for ch in result.chars().rev()\
    \ {\n        result_rev.push(ch);\n    }\n    (result, result == result_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpa7fwo1ln.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpej_pv_22.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp36_218nz.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpujkn8z_j.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpr6vkga2v.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpwtg6s9do.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpi8t572jc.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpn8p_6s9s.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.make_ascii_lowercase();\n    s_rev = s_rev.chars().rev().collect();\n\
    \    (s, s_rev == s)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp_2nfi6b9.rs:18:18\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s_rev == s)\n   |      -           ^ value borrowed here after move\n   |  \
    \    |\n   |      value moved here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    while let Some(ch) = chars.next() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpz_tsqfen.rs:18:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpaaimr9u6.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpvzegyvct.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp7tb9oneh.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp7tb9oneh.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfu93eo4e.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpufz156l1.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ s_chars = s.chars();\n    let mut c_chars = c.chars();\n    let mut s_char =\
    \ s_chars.next();\n    let mut c_char = c_chars.next();\n    while s_char != None\
    \ {\n        if c_char == None {\n            result.push(s_char.unwrap());\n\
    \            s_char = s_chars.next();\n        } else if s_char.unwrap() == c_char.unwrap()\
    \ {\n            s_char = s_chars.next();\n            c_char = c_chars.next();\n\
    \        } else if s_char.unwrap() < c_char.unwrap() {\n            result.push(s_char.unwrap());\n\
    \            s_char = s_chars.next();\n        } else {\n            c_char =\
    \ c_chars.next();\n        }\n    }\n    let mut result_chars = result.chars();\n\
    \    let mut result_char = result_chars.next();\n    let mut result_char_rev =\
    \ result.chars().rev().next();\n    while result_char != None && result_char_rev\
    \ != None {\n        if result_char.unwrap() != result_char_rev.unwrap() {\n \
    \           return (result, false);\n        }\n        result_char = result_chars.next();\n\
    \        result_char_rev = result.chars().rev().next();\n    }\n    (result, true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"cdedcba\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmpli_hsymt.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp29y2rxcq.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut is_palindrome = true;\n    for i in 0..s.len() / 2 {\n        if\
    \ s[i] != s[s.len() - i - 1] {\n            is_palindrome = false;\n         \
    \   break;\n        }\n    }\n    (s.iter().collect(), is_palindrome)\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp8ewemokd.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpqey02r21.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpp8qv5ypy.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmph6dt0xhw.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpy27raw7n.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp5jylylw8.rs:12:9\n\
    \   |\n12 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp5jylylw8.rs:22:9\n\
    \   |\n21 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    22 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpfmc50iv1.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in 0..c.len() {\n        s = s.replace(c.chars().nth(i).unwrap(), \"\");\n\
    \    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpwz0najma.rs:12:9\n\
    \   |\n12 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpwz0najma.rs:16:9\n\
    \   |\n16 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpwz0najma.rs:18:9\n   |\n11 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n18 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp5w40rwlf.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp4wil5ao3.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp147pvvei.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpapxkfyg2.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjlchgh28.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp2svz25p_.rs:12:9\n\
    \   |\n12 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp2svz25p_.rs:16:9\n \
    \  |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n16 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h3aevn4.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp3r_rhm9f.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    (s.iter().collect::<String>(), s == s.iter().rev().collect::<Vec<&char>>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `char` with `&char`\n  --> /tmp/tmpb2vt5xfc.rs:16:38\n\
    \   |\n16 |     (s.iter().collect::<String>(), s == s.iter().rev().collect::<Vec<&char>>())\n\
    \   |                                      ^^ no implementation for `char == &char`\n\
    \   |\n   = help: the trait `PartialEq<&char>` is not implemented for `char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp1gu40850.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp1gu40850.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp6t96gcwz.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut result_rev = String::new();\n    for ch in result.chars().rev()\
    \ {\n        result_rev.push(ch);\n    }\n    (result, result == result_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpfwng4wd6.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp0aas9e3g.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp0aas9e3g.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars: Vec<char> = s.chars().collect();\n    let mut chars_c: Vec<char> = c.chars().collect();\n\
    \    for i in 0..chars.len() {\n        if !chars_c.contains(&chars[i]) {\n  \
    \          result.push(chars[i]);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpq95hexpk.rs:12:9\n\
    \   |\n12 |     let mut chars: Vec<char> = s.chars().collect();\n   |        \
    \ ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmpq95hexpk.rs:13:9\n   |\n13 |     let mut chars_c:\
    \ Vec<char> = c.chars().collect();\n   |         ----^^^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved value:\
    \ `result`\n  --> /tmp/tmpq95hexpk.rs:19:14\n   |\n11 |     let mut result = String::new();\n\
    \   |         ---------- move occurs because `result` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n19 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpkasoyfh2.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp847btmqe.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut is_palindrome = true;\n    let mut i = 0;\n   \
    \ let mut j = result.len() - 1;\n    while i < j {\n        if result.chars().nth(i)\
    \ != result.chars().nth(j) {\n            is_palindrome = false;\n           \
    \ break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpq2jxsod_.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmplqti34x1.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpswu8mvmq.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjgs9fbk4.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfl4ttu1v.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpe3rgh54r.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpipb1mfsr.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmiis3w25.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5szw7_d9.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmprx4x_fsg.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpu85m6ayq.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    while let Some(c) = chars.next() {\n        if !c.is_whitespace()\
    \ && !c.is_alphanumeric() {\n            continue;\n        }\n        result.push(c);\n\
    \    }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_alphanumeric() {\n  \
    \          result.push(c);\n        }\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if !c.is_whitespace() && !c.is_alphanumeric() {\n            continue;\n\
    \        }\n        result.push(c);\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_alphanumeric() {\n            result.push(c);\n        }\n  \
    \  }\n    let mut chars = result.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric()\
    \ {\n            continue;\n        }\n        result.push(c);\n    }\n    let\
    \ mut chars = result.chars();\n    let mut result = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        if c.is_alphanumeric() {\n           \
    \ result.push(c);\n        }\n    }\n    let mut chars = result.chars();\n   \
    \ let mut result = String::new();\n    while let Some(c) = chars.next() {\n  \
    \      if !c.is_whitespace() && !c.is_alphanumeric() {\n            continue;\n\
    \        }\n        result.push(c);\n    }\n    let mut chars = result.chars();\n\
    \    let mut result = String::new();\n    while let\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1pp7acec.rs:67:1\n  \
    \ |\n66 |     while let\n   |     ----- while parsing the condition of this `while`\
    \ expression\n67 | }\n   | ^ expected pattern\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnvssi3zb.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyu03b7o1.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpr4c3_7fr.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp3_zjmdos.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpi2vpummt.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmprx0wwg2l.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut res = String::new();\n    for ch in\
    \ s.chars() {\n        if !c.contains(ch) {\n            res.push(ch);\n     \
    \   }\n    }\n    let mut rev = res.clone();\n    rev.chars().rev().collect::<String>();\n\
    \    (res, res == rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvuw76oxy.rs:17:9\n\
    \   |\n17 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpvuw76oxy.rs:19:11\n\
    \   |\n11 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n19 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpb9k9qg16.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpzkw37fl5.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8xk3h_sf.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmponq4v_5k.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmponq4v_5k.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt13pdkw2.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpq9tettt1.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut res = String::new();\n    let mut s:\
    \ Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            res.push(s[i]);\n\
    \        }\n    }\n    let mut res_rev = res.clone();\n    res_rev.chars().rev().collect::<String>();\n\
    \    (res, res == res_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8o28ciof.rs:12:9\n\
    \   |\n12 |     let mut s: Vec<char> = s.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp8o28ciof.rs:19:9\n\
    \   |\n19 |     let mut res_rev = res.clone();\n   |         ----^^^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `res`\n  --> /tmp/tmp8o28ciof.rs:21:11\n   |\n11 |     let mut res =\
    \ String::new();\n   |         ------- move occurs because `res` has type `String`,\
    \ which does not implement the `Copy` trait\n...\n21 |     (res, res == res_rev)\n\
    \   |      ---  ^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error; 2 warnings emitted\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpw61sodlg.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7ymuq06i.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    let\
    \ mut result = String::new();\n    let mut is_palindrome = true;\n    for i in\
    \ 0..s.len() {\n        if !c.contains(s.chars().nth(i).unwrap()) {\n        \
    \    result.push(s.chars().nth(i).unwrap());\n        }\n    }\n    for i in 0..result.len()\
    \ {\n        if result.chars().nth(i).unwrap() != result.chars().rev().nth(i).unwrap()\
    \ {\n            is_palindrome = false;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp1vbs1pre.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    let mut c_chars = c.chars();\n    let mut c_set = HashSet::new();\n\
    \    while let Some(c) = c_chars.next() {\n        c_set.insert(c);\n    }\n \
    \   while let Some(c) = chars.next() {\n        if !c_set.contains(&c) {\n   \
    \         result.push(c);\n        }\n    }\n    let mut chars = result.chars();\n\
    \    let mut chars_rev = result.chars().rev();\n    let mut is_palindrome = true;\n\
    \    while let Some(c) = chars.next() {\n        if let Some(c_rev) = chars_rev.next()\
    \ {\n            if c != c_rev {\n                is_palindrome = false;\n   \
    \             break;\n            }\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmponvd_nkf.rs:14:21\n   |\n14 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpj1y5lyx7.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut result_rev = String::new();\n    for ch in result.chars().rev()\
    \ {\n        result_rev.push(ch);\n    }\n    (result, result == result_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpfqqgge79.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpvkfrriy1.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmptyby2c01.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    while let Some(c) = chars.next() {\n        if !c.is_whitespace()\
    \ && !c.is_alphanumeric() {\n            continue;\n        }\n        result.push(c);\n\
    \    }\n    let mut result = result.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    let is_palindrome = result.chars().eq(result.chars().rev());\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpvygacy9t.rs:19:60\n\
    \     |\n19   |     let mut result = result.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \     |                                                   -------- ^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                      |\n     |                                             \
    \      required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n19   |     let mut result = result.chars().filter(|x|\
    \ !c.contains(*x)).collect::<String>();\n     |                              \
    \                              +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ is_palindrome = true;\n    let mut s_chars = s.chars();\n    let mut c_chars\
    \ = c.chars();\n    let mut s_char = s_chars.next();\n    let mut c_char = c_chars.next();\n\
    \    while s_char.is_some() {\n        if c_char.is_none() {\n            c_char\
    \ = c_chars.next();\n        }\n        if s_char.unwrap() != c_char.unwrap()\
    \ {\n            result.push(s_char.unwrap());\n            s_char = s_chars.next();\n\
    \        } else {\n            s_char = s_chars.next();\n            c_char =\
    \ c_chars.next();\n        }\n    }\n    let mut result_chars = result.chars();\n\
    \    let mut result_char = result_chars.next();\n    let mut result_char_rev =\
    \ result.chars().rev().next();\n    while result_char.is_some() {\n        if\
    \ result_char.unwrap() != result_char_rev.unwrap() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n        result_char = result_chars.next();\n\
    \        result_char_rev = result.chars().rev().next();\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpz1fqipai.rs:21:38\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ is_palindrome = true;\n    let mut s_chars: Vec<char> = s.chars().collect();\n\
    \    let mut c_chars: Vec<char> = c.chars().collect();\n    for i in 0..s_chars.len()\
    \ {\n        if !c_chars.contains(&s_chars[i]) {\n            result.push(s_chars[i]);\n\
    \        }\n    }\n    let mut result_chars: Vec<char> = result.chars().collect();\n\
    \    for i in 0..result_chars.len() {\n        if result_chars[i] != result_chars[result_chars.len()\
    \ - 1 - i] {\n            is_palindrome = false;\n            break;\n       \
    \ }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate =\
    \ reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpj5bgewui.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwr7qahwf.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp4mt3gipv.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let mut s_rev\
    \ = s.clone();\n    s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmps22ejxwg.rs:12:9\n\
    \   |\n12 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmps22ejxwg.rs:16:9\n\
    \   |\n16 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmps22ejxwg.rs:18:9\n   |\n11 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n18 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    let mut result_reversed = result.chars().rev().collect::<String>();\n\
    \    (result, result == result_reversed)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpj63uvzg1.rs:12:9\n\
    \   |\n12 |     let mut s = s.chars().collect::<Vec<char>>();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpj63uvzg1.rs:19:9\n\
    \   |\n19 |     let mut result_reversed = result.chars().rev().collect::<String>();\n\
    \   |         ----^^^^^^^^^^^^^^^\n   |         |\n   |         help: remove this\
    \ `mut`\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpj63uvzg1.rs:20:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result_reversed)\n   |      ------ \
    \ ^^^^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    while let Some(c) = chars.next() {\n        if !c.is_whitespace()\
    \ && !c.is_alphanumeric() {\n            continue;\n        }\n        result.push(c);\n\
    \    }\n    let mut chars = c.chars();\n    while let Some(c) = chars.next() {\n\
    \        if !c.is_whitespace() && !c.is_alphanumeric() {\n            continue;\n\
    \        }\n        result = result.replace(c, \"\");\n    }\n    let mut chars\
    \ = result.chars();\n    let mut result_rev = String::new();\n    while let Some(c)\
    \ = chars.next_back() {\n        result_rev.push(c);\n    }\n    (result, result\
    \ == result_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr9n1gp7e.rs:31:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n31 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp5_14x2b8.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpj146ymcb.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpsduvb1w5.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmphh6lz3m0.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpd94mlu10.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyt0msbpz.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpybjw9l21.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpc_r4dxm6.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let mut s_rev\
    \ = s.clone();\n    s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbqi449gv.rs:12:9\n\
    \   |\n12 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpbqi449gv.rs:16:9\n\
    \   |\n16 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpbqi449gv.rs:18:9\n   |\n11 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n18 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let is_palindrome = s == s.chars().rev().collect::<String>();\n\
    \    (s, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjt9dv9sv.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjt9dv9sv.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpjpaigz8g.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmplihgreya.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpf8fttu8a.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let mut s = s.chars().collect::<Vec<char>>();\n\
    \    let mut s_rev = s.clone();\n    s_rev.reverse();\n    let res = s == s_rev;\n\
    \    (s.into_iter().collect(), res)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmplggx85eq.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut new_s = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            new_s.push(ch);\n\
    \        }\n    }\n    let mut new_s_rev = String::new();\n    for ch in new_s.chars().rev()\
    \ {\n        new_s_rev.push(ch);\n    }\n    (new_s, new_s == new_s_rev)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `new_s`\n  --> /tmp/tmpld6khfvw.rs:21:13\n\
    \   |\n11 |     let mut new_s = String::new();\n   |         --------- move occurs\
    \ because `new_s` has type `String`, which does not implement the `Copy` trait\n\
    ...\n21 |     (new_s, new_s == new_s_rev)\n   |      -----  ^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    let mut is_palindrome = true;\n    while let Some(c)\
    \ = chars.next() {\n        if !c.is_whitespace() && !c.is_alphanumeric() {\n\
    \            continue;\n        }\n        if !c.is_alphanumeric() {\n       \
    \     continue;\n        }\n        if c.is_alphanumeric() && !c.is_whitespace()\
    \ {\n            result.push(c);\n        }\n    }\n    let mut chars = result.chars();\n\
    \    let mut chars_rev = result.chars().rev();\n    while let Some(c) = chars.next()\
    \ {\n        if let Some(c_rev) = chars_rev.next() {\n            if c != c_rev\
    \ {\n                is_palindrome = false;\n                break;\n        \
    \    }\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcde\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmpatwnudpc.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8n2yjd0x.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut result_rev = String::new();\n    for ch in result.chars().rev()\
    \ {\n        result_rev.push(ch);\n    }\n    (result, result == result_rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpkja10pzw.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpzxbk18tg.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpzxbk18tg.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvgmkaftl.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvgmkaftl.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp6ho0yh6r.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpqgllygo2.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp6s0uljwg.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpvdm1gqrc.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s_rev: String = s.chars().rev().collect();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp8pqhxbph.rs:16:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n16 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.into_iter().collect(), false);\n  \
    \      }\n        i += 1;\n        j -= 1;\n    }\n    (s.into_iter().collect(),\
    \ true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp74tl2o2z.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp1tqlnyi7.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let c: HashSet<char> =\
    \ c.chars().collect();\n    s.retain(|x| !c.contains(x));\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyuj33wq7.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpujpv805p.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if c.contains(&s[i]) {\n            s.remove(i);\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpn_u0kiq_.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptx0ogwf8.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpk7_p1ncc.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpc42gt5v3.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let s_rev: String = s.chars().rev().collect();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpx85qjpgz.rs:16:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n16 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in 0..c.len() {\n        s = s.replace(c.chars().nth(i).unwrap(), \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp6l7172n5.rs:12:9\n\
    \   |\n12 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp6l7172n5.rs:16:9\n \
    \  |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n16 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpqsux4b_u.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    let mut s_rev = s.clone();\n \
    \   s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpy4vi90av.rs:12:9\n\
    \   |\n12 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpy4vi90av.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpy4vi90av.rs:17:9\n   |\n14 |     let s = s.iter().collect::<String>();\n\
    \   |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n17 |     (s, s == s_rev)\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpdcl12d26.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpc1ujb3x4.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpj6atp9ql.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ chars = s.chars();\n    let mut c_chars = c.chars();\n    let mut c_set = HashSet::new();\n\
    \    for c in c_chars {\n        c_set.insert(c);\n    }\n    for c in chars {\n\
    \        if !c_set.contains(&c) {\n            result.push(c);\n        }\n  \
    \  }\n    let mut result_chars = result.chars();\n    let mut result_chars_rev\
    \ = result.chars().rev();\n    let mut is_palindrome = true;\n    for _ in 0..result.len()\
    \ {\n        if result_chars.next() != result_chars_rev.next() {\n           \
    \ is_palindrome = false;\n            break;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpwv78tqvz.rs:14:21\n   |\n14 |     let mut c_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnbdgfenh.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    for\
    \ i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let mut s1 = s.clone();\n\
    \    s1.make_ascii_lowercase();\n    let mut s2 = s1.clone();\n    s2.make_ascii_lowercase();\n\
    \    s2.chars().rev().collect::<String>() == s1 && s.len() > 0\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjqp5_wfi.rs:20:5\n   |\n\
    10 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                                     -------------- expected `(String, bool)`\
    \ because of return type\n...\n20 |     s2.chars().rev().collect::<String>() ==\
    \ s1 && s.len() > 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n\
    \               found type `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ s = s.chars().collect::<Vec<char>>();\n    let c = c.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            result.push(s[i]);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcxp0aq_q.rs:12:9\n\
    \   |\n12 |     let mut s = s.chars().collect::<Vec<char>>();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpcxp0aq_q.rs:19:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n19 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmphfe1h6fh.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ c_vec: Vec<char> = c.chars().collect();\n    let mut s_vec: Vec<char> = s.chars().collect();\n\
    \    s_vec.retain(|x| !c_vec.contains(x));\n    result.extend(s_vec);\n    (result,\
    \ result == result.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpt37u8go9.rs:12:9\n\
    \   |\n12 |     let mut c_vec: Vec<char> = c.chars().collect();\n   |        \
    \ ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved value:\
    \ `result`\n  --> /tmp/tmpt37u8go9.rs:16:14\n   |\n11 |     let mut result = String::new();\n\
    \   |         ---------- move occurs because `result` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n16 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for i in c.chars() {\n\
    \        s = s.replace(i, \"\");\n    }\n    let mut s2 = s.clone();\n    s2.make_ascii_lowercase();\n\
    \    (s, s2 == s2.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpb8kmjbxy.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    let mut c = c;\n    let\
    \ mut result = String::new();\n    let mut is_palindrome = true;\n    let mut\
    \ i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if c.contains(s.get(i..i\
    \ + 1).unwrap()) {\n            s.remove(i);\n            i -= 1;\n        }\n\
    \        if c.contains(s.get(j..j + 1).unwrap()) {\n            s.remove(j);\n\
    \            j += 1;\n        }\n        if s.get(i..i + 1).unwrap() != s.get(j..j\
    \ + 1).unwrap() {\n            is_palindrome = false;\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    result = s;\n    (result, is_palindrome)\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmo3b8_ud.rs:20:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpjchp38u5.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    let s = s.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n       \
    \ if s[i] != s[j] {\n            return (s.iter().collect(), false);\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    (s.iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpthufbuc9.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpfeukwps4.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed = String::new();\n    for ch in result.chars().rev()\
    \ {\n        reversed.push(ch);\n    }\n    (result, result == reversed)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjplwovwr.rs:21:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpleorj91t.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: HashSet<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    (s.iter().collect(), s == s.iter().rev().collect())\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp0izne_55.rs:12:12\n\
    \   |\n12 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp9077xddv.rs:17:14\n\
    \   |\n11 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n   \
    \ s_rev.chars().rev().collect::<String>();\n    (s, s == s_rev)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmprg5pbpht.rs:15:9\n\
    \   |\n15 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmprg5pbpht.rs:17:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n17 |     (s,\
    \ s == s_rev)\n   |      -  ^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars() {\n\
    \        s = s.replace(c, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmps9ribbln.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for ch in c.chars() {\n\
    \        s = s.replace(ch, \"\");\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmppua65bxw.rs:15:9\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
