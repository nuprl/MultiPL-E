name: HumanEval_89_encrypt
language: rust
results:
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 4;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp7fnxze7y.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = (new_char\
    \ - 122) + 96;\n        }\n        result.push(new_char as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpelqjn5rc.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 4;\n        if new_char > 'z' as u8 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        i += 2 * 2;\n        result.push(i as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5eni8s96.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x += 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpoc7_2nck.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = (new_char\
    \ - 122) + 96;\n        }\n        result.push(new_char as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_pr_c6ik.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp2rwd5ldi.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    let mut alphabet_vec: Vec<char> = alphabet.chars().collect();\n    let\
    \ mut s_vec: Vec<char> = s.chars().collect();\n    for i in 0..s_vec.len() {\n\
    \        let mut index = 0;\n        for j in 0..alphabet_vec.len() {\n      \
    \      if s_vec[i] == alphabet_vec[j] {\n                index = j;\n        \
    \        break;\n            }\n        }\n        let mut new_index = index +\
    \ 2 * 2;\n        if new_index > 25 {\n            new_index = new_index - 26;\n\
    \        }\n        result.push(alphabet_vec[new_index]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = vec!['a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut alphabet_length = alphabet.len();\n \
    \   let mut s_length = s.len();\n    let mut s_vec = s.chars().collect::<Vec<char>>();\n\
    \    for i in 0..s_length {\n        for j in 0..alphabet_length {\n         \
    \   if s_vec[i] == alphabet[j] {\n                result.push(alphabet[(j + 2)\
    \ % alphabet_length]);\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpl7s2a_vt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpihxbrw17.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        i += 2 * 2;\n        result.push(i as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpee9e1cu3.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmprbnp73zm.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpp27y2s44.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 'z' as u8 + 'a' as u8 - 1;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp934czzkr.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + (2 * 2);\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpdne5duf1.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        i += 2 * 2;\n        result.push(i as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp2z3xg_yf.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        if c > 'z' as u8 {\n            c -= 26;\n\
    \        }\n        result.push(c as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpa3dfnf5q.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpg9tw5qdt.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c_num = c\
    \ as u8;\n        c_num += 2;\n        c_num *= 2;\n        result.push(c_num\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpd1jsvo3z.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = (c + 2 * 2) as char;\n        result.push(c);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjc_dl7pg.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp3wxx2wn3.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmple9cp2za.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let encrypted_char\
    \ = ((c as u8) + 2 * 2) as char;\n        encrypted_string.push(encrypted_char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpghu59hon.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        if c > 122 {\n            c -= 26;\n     \
    \   }\n        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmpdmtg_5_e.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        if c >= 97 && c <= 122 {\n            let c = c + 2 * 2;\n          \
    \  if c > 122 {\n                let c = c - 26;\n                encrypted.push(c\
    \ as char);\n            } else {\n                encrypted.push(c as char);\n\
    \            }\n        } else {\n            encrypted.push(c as char);\n   \
    \     }\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let mut\
    \ new_char = c as u8;\n        new_char += 2;\n        new_char *= 2;\n      \
    \  encrypted_string.push(new_char as char);\n    }\n    encrypted_string\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpc9k6t2t5.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp53qf50z8.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    let mut alphabet_vec: Vec<char> = alphabet.chars().collect();\n\
    \    let mut s_vec: Vec<char> = s.chars().collect();\n    for i in 0..s_vec.len()\
    \ {\n        let index = alphabet_vec.iter().position(|&r| r == s_vec[i]).unwrap();\n\
    \        let new_index = (index + (2 * 2)) % 26;\n        encrypted_string.push(alphabet_vec[new_index]);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmprujt9jba.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_ds0n8bl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        result.push(new_char as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + 4;\n        let c = c as char;\n        encrypted.push(c);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7ztugoc0.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp6yapmj29.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp0flk9i3j.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        if c > 122 {\n            c -= 26;\n     \
    \   }\n        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \    for c in s.chars() {\n        let index = alphabet.find(c).unwrap();\n  \
    \      let new_index = (index + 4) % 26;\n        result.push(alphabet.chars().nth(new_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x = x + 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp9ed3t_0w.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpt7ezli_d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpm2niswrx.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c_int = c\
    \ as u8;\n        c_int += 2 * 2;\n        result.push(c_int as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpewibzpn7.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpdbnqnwpm.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        if c > 122 {\n            c -= 26;\n     \
    \   }\n        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmp62m1imyo.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpktj7gdqk.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        if c < 97 {\n            c += 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmpbacqsq_3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut c = c\
    \ as u8;\n        c += 2 * 2;\n        encrypted.push(c as char);\n    }\n   \
    \ encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp0cb1oqhz.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 4;\n        if c > 122 {\n            c -= 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpt6od36j4.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x += 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmppljrhqw_.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpi9i46f00.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpldolu5ys.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_cqb_ixs.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpdlh8c4m4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpv6h_gjwt.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x += 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmppa08wcy_.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpz42r14id.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        encrypted_string.push(rotate_char(c,\
    \ 2*2));\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp7oluoii2.rs:13:31\n\
    \   |\n13 |         encrypted_string.push(rotate_char(c, 2*2));\n   |        \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let encrypted_char\
    \ = match c {\n            'a' => 'c',\n            'b' => 'd',\n            'c'\
    \ => 'e',\n            'd' => 'f',\n            'e' => 'g',\n            'f' =>\
    \ 'h',\n            'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n\
    \            'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n \
    \           'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n  \
    \          'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n   \
    \         's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n    \
    \        'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n     \
    \       'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        encrypted_string.push(encrypted_char);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp06eahhty.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpmexsedy8.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    for c in s.chars() {\n        let mut c = c as u8;\n\
    \        c += 2 * 2;\n        res.push(c as char);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpe37zs95k.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp3qdrhokp.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut num = c as\
    \ u8;\n        num += 2 * 2;\n        result.push(num as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp35nqbhe4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpkasf6fod.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 4;\n        if c > 122 {\n            c -= 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpme4z7g_d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdn4eo6ek.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpksd4d0y2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 4;\n        if c > 122 {\n            c -= 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpah35i4ld.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmp59l7vl47.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpzrt1m30l.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 'z' as u8 + 'a' as u8 - 1;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x = x + 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpguucn6f5.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpu017dlpq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        result.push(new_char as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = vec!['a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        let new_index = (index + 2) % 26;\n        result.push(alphabet[new_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmppt5sqaxy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpcv3dbvah.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5u14h_oh.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpcfyshsgb.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmprv1n6v3w.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmps53ona6h.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let mut\
    \ encrypted_char = c as u8;\n        encrypted_char += 2 * 2;\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpta1t1dyh.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp6rjkpw6q.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        result.push(new_char as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x = x + 2 * 2;\n        result.push(x as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpwxf2d_l2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \    for c in s.chars() {\n        let index = alphabet.find(c).unwrap();\n  \
    \      let new_index = (index + 2) % 26;\n        result.push(alphabet.chars().nth(new_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmptq09vqca.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        let c = c + 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp8srbs05c.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_iw80mb1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \    for c in s.chars() {\n        let mut index = alphabet.find(c).unwrap();\n\
    \        index = (index + 2) * 2;\n        result.push(alphabet.chars().nth(index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmpwv931arz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpmt_1gvd1.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1lvh76hr.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpup4y722e.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp84qj0ai5.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1ujj8s5h.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let mut\
    \ encrypted_char = c as u8 + 2 * 2;\n        if encrypted_char > 122 {\n     \
    \       encrypted_char = encrypted_char - 26;\n        }\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpiw44nig3.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2*2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpbc1uwxjh.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2*2));\n   |                  \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        result.push(new_char as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8aggrtyr.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let encrypted_char\
    \ = ((c as u8) + 2 * 2) as char;\n        encrypted_string.push(encrypted_char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp8n_tadh3.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        i += 2 * 2;\n        result.push(i as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpl75wr2vd.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp8e8c0zo6.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c);\n\
    \        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hhii\"`,\n right: `\"lm\"`', /tmp/tmpowt2h631.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpk5_5am0q.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8hklnzvt.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5f6hwjdf.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        encrypted.push(new_char as char);\n   \
    \ }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut c_int\
    \ = c as u8;\n        c_int += 2 * 2;\n        encrypted.push(c_int as char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp4kte2ihm.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let encrypted_char\
    \ = match c {\n            'a' => 'c',\n            'b' => 'd',\n            'c'\
    \ => 'e',\n            'd' => 'f',\n            'e' => 'g',\n            'f' =>\
    \ 'h',\n            'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n\
    \            'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n \
    \           'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n  \
    \          'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n   \
    \         's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n    \
    \        'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n     \
    \       'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        encrypted_string.push(encrypted_char);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpn93afre0.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpn742hi2g.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmpak7476fc.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_string = String::new();\n    for c in s.chars() {\n        let new_char\
    \ = ((c as u8) + 2 * 2) as char;\n        new_string.push(new_char);\n    }\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp8e2648mk.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpfiukd3ne.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut x = c as\
    \ u8;\n        x += 2;\n        x *= 2;\n        result.push(x as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpwzxv9zzq.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp0a4qogao.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        if i >= 97 && i <= 122 {\n            i += 2;\n            if i\
    \ > 122 {\n                i -= 26;\n            }\n        }\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpymvgfda6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpzjee8jfd.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpg1st_m9d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_c = c\
    \ as u8;\n        new_c += 2 * 2;\n        result.push(new_c as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpri2q_8xj.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let new_char = (((c\
    \ as u8) - 97 + 2 * 2) % 26 + 97) as char;\n        result.push(new_char);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpxtc_hv9j.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb66cg87j.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpqymqfhtz.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c_int = c as\
    \ u8;\n        let c_int_new = c_int + (2 * 2);\n        let c_new = c_int_new\
    \ as char;\n        result.push(c_new);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmposo4s9aa.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp0m0jikjz.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let new_char = match\
    \ c {\n            'a' => 'c',\n            'b' => 'd',\n            'c' => 'e',\n\
    \            'd' => 'f',\n            'e' => 'g',\n            'f' => 'h',\n \
    \           'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n  \
    \          'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n   \
    \         'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n    \
    \        'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n     \
    \       's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n      \
    \      'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n       \
    \     'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        result.push(new_char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpgy46uava.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        encrypted.push(c.wrapping_add(2));\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp2eiyk6r0.rs:13:26\n   |\n13 |         encrypted.push(c.wrapping_add(2));\n\
    \   |                          ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmphdz49mwm.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut c = c\
    \ as u8;\n        c += 2 * 2;\n        encrypted.push(c as char);\n    }\n   \
    \ encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7nj1_jqd.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c_num = c as\
    \ u8;\n        let c_num_shifted = c_num + 2 * 2;\n        let c_shifted = c_num_shifted\
    \ as char;\n        result.push(c_shifted);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpmp72od_6.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            let mut new_char = c as u8 + 2;\n            if new_char > 122\
    \ {\n                new_char = new_char - 26;\n            }\n            encrypted.push(new_char\
    \ as char);\n        } else {\n            encrypted.push(c);\n        }\n   \
    \ }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpf_u6ua4s.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2 * 2;\n        result.push(new_char as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpe45qjmif.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let encrypted_char\
    \ = match c {\n            'a' => 'c',\n            'b' => 'd',\n            'c'\
    \ => 'e',\n            'd' => 'f',\n            'e' => 'g',\n            'f' =>\
    \ 'h',\n            'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n\
    \            'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n \
    \           'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n  \
    \          'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n   \
    \         's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n    \
    \        'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n     \
    \       'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        encrypted_string.push(encrypted_char);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpk4bzm0z8.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c_num = c as\
    \ u8;\n        let c_num_shifted = c_num + 2 * 2;\n        let c_shifted = c_num_shifted\
    \ as char;\n        result.push(c_shifted);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpso14425n.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = (new_char\
    \ - 122) + 96;\n        }\n        result.push(new_char as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpsxvk99yt.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut chars = s.chars();\n    while let Some(c)\
    \ = chars.next() {\n        result.push(rotate(c, 2));\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpy0z27wui.rs:14:21\n\
    \   |\n14 |         result.push(rotate(c, 2));\n   |                     ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 4;\n        if c > 122 {\n            c -= 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 'z' as u8 {\n            new_char\
    \ = new_char - 26;\n        }\n        result.push(new_char as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut letter\
    \ = c as u8;\n        letter += 2 * 2;\n        encrypted.push(letter as char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvjpcr7im.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut c = c\
    \ as u8;\n        c += 2 * 2;\n        encrypted.push(c as char);\n    }\n   \
    \ encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp4r3q6d19.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppmb9hpe3.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let mut\
    \ encrypted_char = c as u8;\n        encrypted_char += 2 * 2;\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7glmqi_a.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        if c < 97 {\n            c += 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmpy39lzcvz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_c = c\
    \ as u8;\n        new_c += 4;\n        if new_c > 122 {\n            new_c -=\
    \ 26;\n        }\n        result.push(new_c as char);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        if c > 122 {\n            c -= 26;\n     \
    \   }\n        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    let mut alphabet_vec: Vec<char> = alphabet.chars().collect();\n\
    \    let mut s_vec: Vec<char> = s.chars().collect();\n    for i in 0..s_vec.len()\
    \ {\n        let index = alphabet_vec.iter().position(|&r| r == s_vec[i]).unwrap();\n\
    \        let new_index = (index + (2 * 2)) % 26;\n        result.push(alphabet_vec[new_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    let mut alphabet_vec: Vec<char> = alphabet.chars().collect();\n\
    \    let mut s_vec: Vec<char> = s.chars().collect();\n    for i in 0..s_vec.len()\
    \ {\n        let mut index = alphabet_vec.iter().position(|&r| r == s_vec[i]).unwrap();\n\
    \        index = (index + (2 * 2)) % 26;\n        result.push(alphabet_vec[index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpluy9w8x4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpyooed6e7.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        if c > 122 {\n            c -= 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpho0novbs.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut alphabet = vec!['a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&r|\
    \ r == c).unwrap();\n        let new_index = (index + 2) % 26;\n        result.push(alphabet[new_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp2z4xgqyj.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c = c.wrapping_add(2);\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8eive0nn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let c = c as u8;\n\
    \        if c >= 97 && c <= 122 {\n            let c = c + 2;\n            if\
    \ c > 122 {\n                let c = c - 26;\n                result.push(c as\
    \ char);\n            } else {\n                result.push(c as char);\n    \
    \        }\n        } else {\n            result.push(c as char);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmptwdakks0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut i = c as\
    \ u8;\n        i += 2 * 2;\n        result.push(i as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpsuhxn30a.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        if c < 97 {\n            c += 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmpu97rfzq6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmpuxm2otqp.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        encrypted.push(new_char as char);\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp1_393h21.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2 * 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpp367iiof.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2 * 2;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmphoxs3n6j.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpm12_0a8s.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut encrypted = String::new();\n\
    \    for c in s.chars() {\n        let index = alphabet.find(c).unwrap();\n  \
    \      let new_index = (index + 4) % 26;\n        encrypted.push(alphabet.chars().nth(new_index).unwrap());\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 2 * 2;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp26xpyb4m.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xCC\xCE\"`,\n right: `\"lm\"`', /tmp/tmpalsokngl.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let new_char = match\
    \ c {\n            'a' => 'c',\n            'b' => 'd',\n            'c' => 'e',\n\
    \            'd' => 'f',\n            'e' => 'g',\n            'f' => 'h',\n \
    \           'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n  \
    \          'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n   \
    \         'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n    \
    \        'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n     \
    \       's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n      \
    \      'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n       \
    \     'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        result.push(new_char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpi98y7up2.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8;\n        new_char += 2;\n        new_char *= 2;\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpj0rnn_hx.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c -= 2;\n        if c < 97 {\n            c += 26;\n        }\n\
    \        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmpc2su9gfg.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2 * 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp6w7jnegk.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut new_char\
    \ = c as u8 + 4;\n        if new_char > 122 {\n            new_char = new_char\
    \ - 26;\n        }\n        result.push(new_char as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpi8c805em.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(rotate_char(c,\
    \ 2 * 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpwwwh2wlu.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut c = c as\
    \ u8;\n        c += 2;\n        c *= 2;\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp5dzn4dnk.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
