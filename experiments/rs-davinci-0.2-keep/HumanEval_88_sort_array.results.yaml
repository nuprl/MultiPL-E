name: HumanEval_88_sort_array
language: rust
results:
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi7uoqq8d.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    if len == 1 {\n        return array;\n    }\n    if (array[0] + array[len\
    \ - 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n  \
    \      array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if array[i] > array[i + 1] {\n\
    \                sorted = false;\n                array.swap(i, i + 1);\n    \
    \        }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp636ejb30.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort();\n    if array.len() > 0 && array[0]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpf57gc0kn.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec()).as_mut_slice();\n        right\
    \ = sort_array(right.to_vec()).as_mut_slice();\n        let mut left_index = 0;\n\
    \        let mut right_index = 0;\n        while left_index < left.len() && right_index\
    \ < right.len() {\n            if left[left_index] > right[right_index] {\n  \
    \              array[left_index + right_index] = left[left_index];\n         \
    \       left_index += 1;\n            } else {\n                array[left_index\
    \ + right_index] = right[right_index];\n                right_index += 1;\n  \
    \          }\n        }\n        while left_index < left.len() {\n           \
    \ array[left_index + right_index] = left[left_index];\n            left_index\
    \ += 1;\n        }\n        while right_index < right.len() {\n            array[left_index\
    \ + right_index] = right[right_index];\n            right_index += 1;\n      \
    \  }\n    }\n    if array.len() > 1 && array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmph2ranmg6.rs:14:56\n   |\n14 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmph2ranmg6.rs:14:56\n   |\n14\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmph2ranmg6.rs:14:37\n\
    \   |\n14 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmph2ranmg6.rs:15:16\n\
    \   |\n15 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n19 |         while left_index\
    \ < left.len() && right_index < right.len() {\n   |                          \
    \  ---------- borrow later used here\n   |\n   = note: consider using a `let`\
    \ binding to create a longer lived value\n\nerror[E0716]: temporary value dropped\
    \ while borrowed\n  --> /tmp/tmph2ranmg6.rs:16:17\n   |\n16 |         right =\
    \ sort_array(right.to_vec()).as_mut_slice();\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \               - temporary value is freed at the end of this statement\n   |\
    \                 |\n   |                 creates a temporary which is freed while\
    \ still in use\n...\n19 |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdm838aqx.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array[..i].sort();\n\
    \        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        array[i..].sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkhe8ixse.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let sum = array[0] + array[array.len() - 1];\n\
    \        if sum % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n    \
    \    } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if i\
    \ == j && array[i] % 2 == 0 {\n            array.swap(i, j);\n        }\n    \
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            array.reverse();\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8d5arf9b.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut i, mut j) = (0, array.len() - 1);\n\
    \        while i < j {\n            while i < j && (array[i] + array[j]) % 2 ==\
    \ 0 {\n                i += 1;\n            }\n            while i < j && (array[i]\
    \ + array[j]) % 2 == 1 {\n                j -= 1;\n            }\n           \
    \ array.swap(i, j);\n        }\n        array[..i].sort();\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 4, 5, 3, 2, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp0w_wbfoi.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        merge(left, right)\n    } else {\n        array\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpewy0jahf.rs:17:9\n\
    \   |\n17 |         merge(left, right)\n   |         ^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpewy0jahf.rs:15:16\n   |\n14 |\
    \         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n \
    \  |              -------- expected due to the type of this binding\n15 |    \
    \     left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpewy0jahf.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    while i < j {\n        if is_odd {\n\
    \            if array[i] % 2 == 0 {\n                while array[j] % 2 == 0 {\n\
    \                    j -= 1;\n                }\n                array.swap(i,\
    \ j);\n            }\n        } else {\n            if array[i] % 2 == 1 {\n \
    \               while array[j] % 2 == 1 {\n                    j -= 1;\n     \
    \           }\n                array.swap(i, j);\n            }\n        }\n \
    \       i += 1;\n    }\n    array.sort_by(|a, b| if is_odd { a.cmp(b) } else {\
    \ b.cmp(a) });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcfl3i90r.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array = array;\n    let mut i = 0;\n\
    \    let mut j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j])\
    \ % 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n    \
    \    j -= 1;\n    }\n    array.sort();\n    if (array[0] + array[array.len() -\
    \ 1]) % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            i += 1;\n        } else if array[j]\
    \ % 2 == 1 {\n            j -= 1;\n        } else {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpibge8_j_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdemd9_lx.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let mut is_odd = false;\n    if array.len() > 1 {\n        is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    }\n    result.sort_by(|a, b| {\n  \
    \      if is_odd {\n            b.cmp(a)\n        } else {\n            a.cmp(b)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmplexyjkrc.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp84ox4ss1.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvykaa303.rs:15:16\n   |\n\
    14 |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |              -------- expected due to the type of this binding\n15 |   \
    \      left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvykaa303.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpeh2vj3pd.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdgv5rmsz.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp7usvw8_e.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkc03b4nf.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort();\n    if array.len() > 0 && array[0]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmps0efljyq.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpehdw4rmx.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpajadk4ju.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    let mut i = 0;\n    let mut j = array.len()\
    \ - 1;\n    while !sorted {\n        sorted = true;\n        if i < j {\n    \
    \        if array[i] > array[j] {\n                array.swap(i, j);\n       \
    \         sorted = false;\n            }\n            if (i + j) % 2 == 0 {\n\
    \                i += 1;\n            } else {\n                j -= 1;\n    \
    \        }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpz5c9wfu5.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3a3vimii.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 1 {\n            array[i..].sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array[i..].sort();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpphphnbf9.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut odd_indexes = vec![];\n    let mut even_indexes = vec![];\n    for\
    \ (index, value) in array.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            odd_indexes.push(value);\n        } else {\n            even_indexes.push(value);\n\
    \        }\n    }\n    odd_indexes.sort();\n    even_indexes.sort();\n    even_indexes.reverse();\n\
    \    for (index, value) in odd_indexes.iter().enumerate() {\n        array[index\
    \ * 2] = *value;\n    }\n    for (index, value) in even_indexes.iter().enumerate()\
    \ {\n        array[index * 2 + 1] = *value;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz3j433s4.rs:26:28\n   |\n\
    26 |         array[index * 2] = *value;\n   |         ----------------   ^^^^^^\
    \ expected `isize`, found `&isize`\n   |         |\n   |         expected due\
    \ to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n26 |         array[index * 2] = **value;\n   |                        \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3j433s4.rs:29:32\n  \
    \ |\n29 |         array[index * 2 + 1] = *value;\n   |         --------------------\
    \   ^^^^^^ expected `isize`, found `&isize`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n29 |         array[index * 2 + 1] = **value;\n   |                    \
    \            +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort_by(|a, b| if a % 2 == 0 { b.cmp(a)\
    \ } else { a.cmp(b) });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmparheyr8b.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n       \
    \     array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppzlsw6ek.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array = array;\n    let mut i = 0;\n\
    \    let mut j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j])\
    \ % 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n    \
    \    j -= 1;\n    }\n    array.sort();\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe6pdk3fz.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if array[i] > array[i + 1] {\n\
    \                array.swap(i, i + 1);\n                sorted = false;\n    \
    \        }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpo9livkg7.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        if array.len() % 2 == 0 {\n            result.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            result.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpt5fvz970.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut is_odd = true;\n    if array.len() > 1 {\n        is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    }\n    if is_odd {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp7yqtj01i.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut i, mut j) = (0, array.len() - 1);\n\
    \        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n    \
    \            array.swap(i, j);\n            }\n            i += 1;\n         \
    \   j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmponh03r01.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \n    let mut i = 0;\n    let mut j = len - 1;\n    let mut is_odd = (array[0]\
    \ + array[len - 1]) % 2 == 1;\n    while i < j {\n        if is_odd {\n      \
    \      if array[i] % 2 == 0 {\n                i += 1;\n            } else if\
    \ array[j] % 2 == 1 {\n                j -= 1;\n            } else {\n       \
    \         array.swap(i, j);\n                i += 1;\n                j -= 1;\n\
    \            }\n        } else {\n            if array[i] % 2 == 1 {\n       \
    \         i += 1;\n            } else if array[j] % 2 == 0 {\n               \
    \ j -= 1;\n            } else {\n                array.swap(i, j);\n         \
    \       i += 1;\n                j -= 1;\n            }\n        }\n    }\n\n\
    \    if is_odd {\n        array[i..].sort();\n    } else {\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 0, 1, 3, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpyqq8f6zf.rs:58:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpe3gbidw0.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpqqxnpifq.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() > 1 && array[0] % 2 == 0 {\n\
    \        array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1sd89dgh.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpvje0ao7d.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut start = 0;\n    let mut end = array.len() - 1;\n    let mut is_odd\
    \ = (array[start] + array[end]) % 2 == 1;\n    while start < end {\n        if\
    \ is_odd {\n            if array[start] % 2 == 0 {\n                array.swap(start,\
    \ end);\n                end -= 1;\n            } else {\n                start\
    \ += 1;\n            }\n        } else {\n            if array[start] % 2 == 1\
    \ {\n                array.swap(start, end);\n                end -= 1;\n    \
    \        } else {\n                start += 1;\n            }\n        }\n   \
    \ }\n    if is_odd {\n        array[start..].sort();\n    } else {\n        array[start..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqud2y05a.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpap7wh4r9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut odd_indexes = Vec::new();\n    let mut even_indexes = Vec::new();\n\
    \    for (i, &x) in array.iter().enumerate() {\n        if i % 2 == 0 {\n    \
    \        odd_indexes.push(x);\n        } else {\n            even_indexes.push(x);\n\
    \        }\n    }\n    odd_indexes.sort();\n    even_indexes.sort();\n    even_indexes.reverse();\n\
    \    for (i, &x) in odd_indexes.iter().enumerate() {\n        array[i * 2] = x;\n\
    \    }\n    for (i, &x) in even_indexes.iter().enumerate() {\n        array[i\
    \ * 2 + 1] = x;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 4, 3, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8ddl86zq.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        if i < j {\n           \
    \ if array[i] > array[j] {\n                array.swap(i, j);\n              \
    \  sorted = false;\n            }\n            i += 1;\n            j -= 1;\n\
    \        } else {\n            i = 0;\n            j = array.len() - 1;\n    \
    \    }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpq2h15gqc.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp88ewyht4.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            array.swap(i, j);\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    array.sort();\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpsy49lbvf.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpbqxgfs76.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        let sum = array[0] + array[array.len() - 1];\n\
    \        if sum % 2 == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            result.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let (mut left, mut right) = (0, array.len() - 1);\n    let mut is_odd = (array[0]\
    \ + array[right]) % 2 == 1;\n    while left < right {\n        if is_odd {\n \
    \           if array[left] % 2 == 0 {\n                array.swap(left, right);\n\
    \                right -= 1;\n            } else {\n                left += 1;\n\
    \            }\n        } else {\n            if array[left] % 2 == 1 {\n    \
    \            array.swap(left, right);\n                right -= 1;\n         \
    \   } else {\n                left += 1;\n            }\n        }\n    }\n  \
    \  if is_odd {\n        array[..left].sort();\n        array[left..].sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array[..left].sort_by(|a, b| b.cmp(a));\n\
    \        array[left..].sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9jafn8cr.rs:13:37\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpc1kswttb.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpn8v2q1s7.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array = array;\n    if (array[0] +\
    \ array[array.len() - 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            if (array[start] + array[end])\
    \ % 2 == 0 {\n                array.swap(start, end);\n            }\n       \
    \     start += 1;\n            end -= 1;\n        }\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpppkivrps.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 {\n          \
    \      while i < j && array[j] % 2 == 0 {\n                    j -= 1;\n     \
    \           }\n                if i < j {\n                    array.swap(i, j);\n\
    \                }\n            }\n            i += 1;\n        }\n        if\
    \ array[0] % 2 == 0 {\n            array.reverse();\n        }\n        array[..i].sort();\n\
    \        array[i..].sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 3, 5, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8lq4n_17.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let mut odd_indexes = Vec::new();\n    let mut even_indexes = Vec::new();\n\
    \    for (i, val) in array.iter().enumerate() {\n        if i % 2 == 0 {\n   \
    \         odd_indexes.push(*val);\n        } else {\n            even_indexes.push(*val);\n\
    \        }\n    }\n    odd_indexes.sort();\n    even_indexes.sort();\n    even_indexes.reverse();\n\
    \    for (i, val) in result.iter_mut().enumerate() {\n        if i % 2 == 0 {\n\
    \            *val = odd_indexes[i / 2];\n        } else {\n            *val =\
    \ even_indexes[i / 2];\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 4, 3, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpn707zk27.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpr1y3t7_5.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            i += 1;\n        } else if array[j]\
    \ % 2 == 1 {\n            j -= 1;\n        } else {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8z2q1akl.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        j -= 1;\n        while i > j {\n            if array[i] < array[i - 1]\
    \ {\n                array.swap(i, i - 1);\n                sorted = false;\n\
    \            }\n            i -= 1;\n        }\n        j += 1;\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpppb7hriz.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut i, mut j) = (0, array.len() - 1);\n\
    \        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n    \
    \            array.swap(i, j);\n            }\n            i += 1;\n         \
    \   j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpgob7iszd.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i, j);\n   \
    \     }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7fiuzzn9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort();\n    if array.len() > 0 && array[0]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpv9t_ta4w.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpndpczx8i.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpcgcj_xtu.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjefferc9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmptqn6s3ir.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            if (array[start] + array[end])\
    \ % 2 == 0 {\n                array.swap(start, end);\n            }\n       \
    \     start += 1;\n            end -= 1;\n        }\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp35kbiax9.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpfovbe6b6.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array[..i].sort();\n    array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg5moa3ab.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbymuvw42.rs:15:16\n   |\n\
    14 |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |              -------- expected due to the type of this binding\n15 |   \
    \      left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbymuvw42.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9zghhwbp.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpuat3hek1.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyvl3zx0j.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        array = merge(left, right);\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpvpoans1n.rs:17:17\n\
    \   |\n17 |         array = merge(left, right);\n   |                 ^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvpoans1n.rs:15:16\n\
    \   |\n14 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |              -------- expected due to the type of this binding\n\
    15 |         left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvpoans1n.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpn0c2mdsh.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm2rcay0u.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi8zw0vmz.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpd52ktsaa.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if (array[0] + array[array.len() - 1]) % 2\
    \ == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n    \
    \        array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    if array[0] + array[array.len() -\
    \ 1] % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt5j0630k.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            if (array[start] + array[end])\
    \ % 2 == 0 {\n                array.swap(start, end);\n            }\n       \
    \     start += 1;\n            end -= 1;\n        }\n        array.sort_by(|a,\
    \ b| {\n            if (a + array[0]) % 2 == 0 {\n                b.cmp(a)\n \
    \           } else {\n                a.cmp(b)\n            }\n        });\n \
    \   }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpem43nwqq.rs:22:23\n   |\n22 |           array.sort_by(|a,\
    \ b| {\n   |           -     ------- ^^^^^^ immutable borrow occurs here\n   |\
    \           |     |\n   |  _________|     mutable borrow later used by call\n\
    \   | |\n23 | |             if (a + array[0]) % 2 == 0 {\n   | |             \
    \        ----- second borrow occurs due to use of `array` in closure\n24 | | \
    \                b.cmp(a)\n25 | |             } else {\n26 | |               \
    \  a.cmp(b)\n27 | |             }\n28 | |         });\n   | |__________- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut odd_indexes = Vec::new();\n    let mut even_indexes = Vec::new();\n\
    \    for (i, &x) in array.iter().enumerate() {\n        if i % 2 == 0 {\n    \
    \        odd_indexes.push(x);\n        } else {\n            even_indexes.push(x);\n\
    \        }\n    }\n    odd_indexes.sort();\n    even_indexes.sort();\n    even_indexes.reverse();\n\
    \    for (i, &x) in odd_indexes.iter().enumerate() {\n        array[i * 2] = x;\n\
    \    }\n    for (i, &x) in even_indexes.iter().enumerate() {\n        array[i\
    \ * 2 + 1] = x;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 4, 3, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3n2yfv5a.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpk596tn8t.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp8dzosi0a.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp_3oiu27x.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() > 0 {\n        let mut i = 0;\n        let mut j = result.len()\
    \ - 1;\n        while i < j {\n            if result[i] % 2 == 0 && result[j]\
    \ % 2 == 1 {\n                result.swap(i, j);\n                i += 1;\n  \
    \              j -= 1;\n            } else if result[i] % 2 == 1 && result[j]\
    \ % 2 == 0 {\n                i += 1;\n                j -= 1;\n            }\
    \ else if result[i] % 2 == 1 && result[j] % 2 == 1 {\n                i += 1;\n\
    \            } else {\n                j -= 1;\n            }\n        }\n   \
    \     if result.len() % 2 == 1 {\n            result[i..].sort();\n        } else\
    \ {\n            result[i..].sort_by(|a, b| b.cmp(a));\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 4, 2, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpkuzw_dxk.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec()).as_mut_slice();\n        right\
    \ = sort_array(right.to_vec()).as_mut_slice();\n        let mut i = 0;\n     \
    \   let mut j = 0;\n        let mut k = 0;\n        while i < left.len() && j\
    \ < right.len() {\n            if (left[i] + right[j]) % 2 == 0 {\n          \
    \      array[k] = left[i];\n                i += 1;\n            } else {\n  \
    \              array[k] = right[j];\n                j += 1;\n            }\n\
    \            k += 1;\n        }\n        while i < left.len() {\n            array[k]\
    \ = left[i];\n            i += 1;\n            k += 1;\n        }\n        while\
    \ j < right.len() {\n            array[k] = right[j];\n            j += 1;\n \
    \           k += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpqb4m56hf.rs:14:56\n   |\n14 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpqb4m56hf.rs:14:56\n   |\n14\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpqb4m56hf.rs:14:37\n\
    \   |\n14 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpqb4m56hf.rs:15:16\n\
    \   |\n15 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n20 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpqb4m56hf.rs:16:17\n\
    \   |\n16 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n20 |      \
    \   while i < left.len() &&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqdenj633.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpexs2ez6c.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    let mut i = 0;\n    let mut j = array.len()\
    \ - 1;\n    let mut temp;\n    while !sorted {\n        sorted = true;\n     \
    \   for _ in 0..array.len() - 1 {\n            if array[i] > array[i + 1] {\n\
    \                temp = array[i];\n                array[i] = array[i + 1];\n\
    \                array[i + 1] = temp;\n                sorted = false;\n     \
    \       }\n            i += 1;\n        }\n        i = 0;\n        for _ in 0..array.len()\
    \ - 1 {\n            if array[j] < array[j - 1] {\n                temp = array[j];\n\
    \                array[j] = array[j - 1];\n                array[j - 1] = temp;\n\
    \                sorted = false;\n            }\n            j -= 1;\n       \
    \ }\n        j = array.len() - 1;\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmph71dqy_h.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpfni1w6lk.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array[..i].sort();\n\
    \        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        array[i..].sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp21tsyhw7.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    let mut i = 0;\n    let mut j = len - 1;\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjjjiou71.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp_wkekrfd.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let first = array[0];\n        let last = array[array.len()\
    \ - 1];\n        if (first + last) % 2 == 0 {\n            array.sort_by(|a, b|\
    \ b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        if (array[i] + array[j])\
    \ % 2 == 0 {\n            if array[i] < array[j] {\n                array.swap(i,\
    \ j);\n                sorted = false;\n            }\n            j -= 1;\n \
    \       } else {\n            if array[i] > array[j] {\n                array.swap(i,\
    \ j);\n                sorted = false;\n            }\n            i += 1;\n \
    \       }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxshqh8_g.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    let mut sorted = false;\n    while !sorted {\n\
    \        sorted = true;\n        for i in 0..len - 1 {\n            let (a, b)\
    \ = (array[i], array[i + 1]);\n            if (a + b) % 2 == 0 && a < b || (a\
    \ + b) % 2 == 1 && a > b {\n                array.swap(i, i + 1);\n          \
    \      sorted = false;\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9g9389ln.rs:17:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpthadnq38.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            array.swap(i, j);\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    array.sort();\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdcywu8lh.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    if (array[0] + array[array.len() -\
    \ 1]) % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpa7651173.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmph4qz2csj.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg514be1r.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpa5tmzvec.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n\
    \    sorted_array.sort();\n    if (array[0] + array[array.len() - 1]) % 2 == 0\
    \ {\n        sorted_array.reverse();\n    }\n    sorted_array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpxwm92c2k.rs:14:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut index = 0;\n    let mut index_end = array.len() - 1;\n    let mut\
    \ is_odd = false;\n    if (array[0] + array[index_end]) % 2 == 1 {\n        is_odd\
    \ = true;\n    }\n    while index < index_end {\n        if is_odd {\n       \
    \     if array[index] % 2 == 0 {\n                while array[index_end] % 2 ==\
    \ 0 {\n                    index_end -= 1;\n                }\n              \
    \  let temp = array[index];\n                array[index] = array[index_end];\n\
    \                array[index_end] = temp;\n            }\n        } else {\n \
    \           if array[index] % 2 == 1 {\n                while array[index_end]\
    \ % 2 == 1 {\n                    index_end -= 1;\n                }\n       \
    \         let temp = array[index];\n                array[index] = array[index_end];\n\
    \                array[index_end] = temp;\n            }\n        }\n        index\
    \ += 1;\n    }\n    if is_odd {\n        array.sort();\n    } else {\n       \
    \ array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplny552el.rs:14:25\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpp9ssmly_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpivkn7cei.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut index = 0;\n    let mut index_end = array.len() - 1;\n    let mut\
    \ sorted = false;\n    let mut odd = false;\n    if array.len() > 1 {\n      \
    \  if (array[0] + array[array.len() - 1]) % 2 == 1 {\n            odd = true;\n\
    \        }\n        while !sorted {\n            sorted = true;\n            if\
    \ odd {\n                for i in index..index_end {\n                    if array[i]\
    \ > array[i + 1] {\n                        array.swap(i, i + 1);\n          \
    \              sorted = false;\n                    }\n                }\n   \
    \             index_end -= 1;\n            } else {\n                for i in\
    \ (index..index_end).rev() {\n                    if array[i] < array[i + 1] {\n\
    \                        array.swap(i, i + 1);\n                        sorted\
    \ = false;\n                    }\n                }\n                index +=\
    \ 1;\n            }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcz4unccw.rs:14:25\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpuwbz1we0.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            while start < end && (array[start]\
    \ + array[end]) % 2 == 1 {\n                start += 1;\n            }\n     \
    \       while start < end && (array[start] + array[end]) % 2 == 0 {\n        \
    \        end -= 1;\n            }\n            if start < end {\n            \
    \    array.swap(start, end);\n            }\n        }\n        if (array[start]\
    \ + array[end]) % 2 == 0 {\n            array[start..].reverse();\n        }\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 0, 5, 1, 3]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp6lbcyjow.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    if len == 1 {\n        return array;\n    }\n    let mut i = 0;\n    let\
    \ mut j = len - 1;\n    while i < j {\n        if (array[i] + array[j]) % 2 ==\
    \ 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n        j -=\
    \ 1;\n    }\n    array.sort();\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpih91d09k.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                let tmp = array[i];\n\
    \                array[i] = array[j];\n                array[j] = tmp;\n     \
    \           sorted = false;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpuq4k4pu0.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                let tmp = array[i];\n\
    \                array[i] = array[j];\n                array[j] = tmp;\n     \
    \           sorted = false;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpp0bunhp5.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptyulldl8.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp32ojtb7l.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 {\n          \
    \      i += 1;\n            } else if array[j] % 2 == 1 {\n                j -=\
    \ 1;\n            } else {\n                array.swap(i, j);\n              \
    \  i += 1;\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 0 {\n            array[i..].reverse();\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 0, 5, 1, 3]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmplsyo7co0.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..len - 1 {\n            if array[i] > array[i + 1] {\n     \
    \           sorted = false;\n                array.swap(i, i + 1);\n         \
    \   }\n        }\n    }\n    if len % 2 == 0 {\n        array.reverse();\n   \
    \ }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3ufx9u2_.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            i += 1;\n        } else if array[j]\
    \ % 2 == 1 {\n            j -= 1;\n        } else {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        }\n    }\n    if array.len()\
    \ % 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0q7tz28c.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut tmp;\n    while\
    \ i < j {\n        if array[i] % 2 == 0 {\n            if array[j] % 2 == 1 {\n\
    \                tmp = array[i];\n                array[i] = array[j];\n     \
    \           array[j] = tmp;\n                i += 1;\n                j -= 1;\n\
    \            } else {\n                j -= 1;\n            }\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if array.len() % 2 == 0 {\n  \
    \      array[..i].sort();\n        array[i..].sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array[..i].sort_by(|a, b| b.cmp(a));\n        array[i..].sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjjve0slc.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp2k80gou9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo3qfg33g.rs:15:16\n   |\n\
    14 |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |              -------- expected due to the type of this binding\n15 |   \
    \      left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo3qfg33g.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj5vstzhr.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array[..i].sort();\n    array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1yqmqde9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    let mut i = 0;\n    let mut j = array.len()\
    \ - 1;\n    while !sorted {\n        sorted = true;\n        for k in i..j {\n\
    \            if (array[i] + array[j]) % 2 == 0 && array[k] > array[k + 1] {\n\
    \                array.swap(k, k + 1);\n                sorted = false;\n    \
    \        } else if (array[i] + array[j]) % 2 != 0 && array[k] < array[k + 1] {\n\
    \                array.swap(k, k + 1);\n                sorted = false;\n    \
    \        }\n        }\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp40umhu3v.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 1 {\n            array[i..].sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array[i..].sort();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpingab2h_.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    let mut i = 0;\n    let mut j = array.len()\
    \ - 1;\n    while !sorted {\n        sorted = true;\n        for k in i..j {\n\
    \            if (array[k] + array[k + 1]) % 2 == 0 {\n                array.swap(k,\
    \ k + 1);\n                sorted = false;\n            }\n        }\n       \
    \ j -= 1;\n        for k in (i..j).rev() {\n            if (array[k] + array[k\
    \ + 1]) % 2 != 0 {\n                array.swap(k, k + 1);\n                sorted\
    \ = false;\n            }\n        }\n        i += 1;\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpsfcqlbsm.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1beb_r6u.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        if (array[0] + array[array.len() - 1]) % 2\
    \ == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n        } else {\n   \
    \         result.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if (array[0] + array[array.len() - 1]) % 2\
    \ == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n    \
    \        array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0sg138h6.rs:15:16\n   |\n\
    14 |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |              -------- expected due to the type of this binding\n15 |   \
    \      left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0sg138h6.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmplr_98dkp.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpw4gp3la0.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut temp = 0;\n\
    \    let mut is_odd = false;\n    if (array[0] + array[array.len() - 1]) % 2 !=\
    \ 0 {\n        is_odd = true;\n    }\n    while i < j {\n        if is_odd {\n\
    \            if array[i] % 2 == 0 {\n                while array[j] % 2 == 0 {\n\
    \                    j -= 1;\n                }\n                temp = array[i];\n\
    \                array[i] = array[j];\n                array[j] = temp;\n    \
    \        }\n        } else {\n            if array[i] % 2 != 0 {\n           \
    \     while array[j] % 2 != 0 {\n                    j -= 1;\n               \
    \ }\n                temp = array[i];\n                array[i] = array[j];\n\
    \                array[j] = temp;\n            }\n        }\n        i += 1;\n\
    \    }\n    array.sort();\n    if is_odd {\n        array.reverse();\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpy1inhqeh.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if (array[0] + array[array.len() - 1]) % 2\
    \ == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n    \
    \        array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    if array.len() > 1\
    \ {\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n    }\n    array.sort();\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpoisj0f5a.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let first = array.first().unwrap();\n    let last = array.last().unwrap();\n\
    \    if (first + last) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n \
    \   } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp_577_wjj.rs:13:31\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 1 {\n            array[i..].sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array[i..].sort();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpz2z6vub6.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0l_itomd.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp1qjr1z01.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfy0ogg57.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort();\n    if array.len() > 0 && array[0]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxuiua_q5.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let n = array.len();\n    if n == 0 || n == 1 {\n        return array;\n\
    \    }\n    let mut i = 0;\n    let mut j = n - 1;\n    if (array[0] + array[n\
    \ - 1]) % 2 == 0 {\n        while i < j {\n            while i < j && (array[i]\
    \ + array[n - 1]) % 2 == 0 {\n                i += 1;\n            }\n       \
    \     while i < j && (array[j] + array[n - 1]) % 2 == 1 {\n                j -=\
    \ 1;\n            }\n            if i < j {\n                array.swap(i, j);\n\
    \            }\n        }\n        array.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        while i < j {\n            while i < j && (array[i] + array[n - 1])\
    \ % 2 == 1 {\n                i += 1;\n            }\n            while i < j\
    \ && (array[j] + array[n - 1]) % 2 == 0 {\n                j -= 1;\n         \
    \   }\n            if i < j {\n                array.swap(i, j);\n           \
    \ }\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp66m99ycp.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptbbeexu9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (first, last) = (array[0], array[array.len()\
    \ - 1]);\n        let (mut left, mut right) = (0, array.len() - 1);\n        while\
    \ left < right {\n            if (first + last) % 2 == 0 {\n                if\
    \ array[left] < array[right] {\n                    array.swap(left, right);\n\
    \                }\n            } else {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     }\n            left += 1;\n            right -= 1;\n        }\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpa5dwh_5v.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort();\n    if array.len() > 0 && array[0]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0bjpxizg.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sorted = false;\n    while !sorted {\n        sorted = true;\n  \
    \      for i in 0..array.len() - 1 {\n            if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n                if array[i] < array[i + 1] {\n           \
    \         array.swap(i, i + 1);\n                    sorted = false;\n       \
    \         }\n            } else {\n                if array[i] > array[i + 1]\
    \ {\n                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptc7rqi8p.rs:16:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxtaz521t.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp6t5p0hco.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i, j);\n   \
    \     }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzmkke85u.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzy3mq9q_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpxht0o6lj.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 1 {\n            array[i..].sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array[i..].sort();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpmg156s35.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjjvm62pl.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut left = 0;\n    let mut right = array.len() - 1;\n    let mut is_odd\
    \ = (array[0] + array[right]) % 2 == 1;\n    while left < right {\n        if\
    \ is_odd {\n            if array[left] % 2 == 0 {\n                left += 1;\n\
    \            } else if array[right] % 2 == 1 {\n                right -= 1;\n\
    \            } else {\n                array.swap(left, right);\n            \
    \    left += 1;\n                right -= 1;\n            }\n        } else {\n\
    \            if array[left] % 2 == 1 {\n                left += 1;\n         \
    \   } else if array[right] % 2 == 0 {\n                right -= 1;\n         \
    \   } else {\n                array.swap(left, right);\n                left +=\
    \ 1;\n                right -= 1;\n            }\n        }\n    }\n    array.sort_by(|a,\
    \ b| {\n        if is_odd {\n            b.cmp(a)\n        } else {\n        \
    \    a.cmp(b)\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3d3_u2lo.rs:14:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            array.swap(i, j);\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    array.sort();\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp_dedm_iw.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpdkcnetg7.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            if (array[start] + array[end])\
    \ % 2 == 0 {\n                array.swap(start, end);\n            }\n       \
    \     start += 1;\n            end -= 1;\n        }\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpmqo292yy.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpy53irkfv.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5xhoi_8i.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut odd_indexes = Vec::new();\n    let mut even_indexes = Vec::new();\n\
    \    for (index, value) in array.iter().enumerate() {\n        if index % 2 ==\
    \ 0 {\n            odd_indexes.push(value);\n        } else {\n            even_indexes.push(value);\n\
    \        }\n    }\n    odd_indexes.sort();\n    even_indexes.sort();\n    even_indexes.reverse();\n\
    \    for (index, value) in array.iter_mut().enumerate() {\n        if index %\
    \ 2 == 0 {\n            *value = odd_indexes.pop().unwrap();\n        } else {\n\
    \            *value = even_indexes.pop().unwrap();\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpessg1xbb.rs:27:22\n   |\n\
    27 |             *value = odd_indexes.pop().unwrap();\n   |             ------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |        \
    \     |\n   |             expected due to the type of this binding\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n27 |             *value = *odd_indexes.pop().unwrap();\n\
    \   |                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpessg1xbb.rs:29:22\n\
    \   |\n29 |             *value = even_indexes.pop().unwrap();\n   |          \
    \   ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n29 |             *value\
    \ = *even_indexes.pop().unwrap();\n   |                      +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpv5zxje1m.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpvongy9n2.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while array[j] % 2 == 0 && i < j {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    array.sort_by(|a, b| {\n        if a % 2 ==\
    \ 0 {\n            b.cmp(a)\n        } else {\n            a.cmp(b)\n        }\n\
    \    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpr0ml9bp_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    if len == 1 {\n        return array;\n    }\n    let sum = array[0] + array[len\
    \ - 1];\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut temp;\n   \
    \ while i < j {\n        if array[i] % 2 == 0 {\n            if array[j] % 2 !=\
    \ 0 {\n                temp = array[i];\n                array[i] = array[j];\n\
    \                array[j] = temp;\n                i += 1;\n                j\
    \ -= 1;\n            } else {\n                j -= 1;\n            }\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    if array.len() % 2 ==\
    \ 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5o2tov6r.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut is_odd = false;\n    if array.len() > 1 {\n        if (array[0] +\
    \ array[array.len() - 1]) % 2 == 1 {\n            is_odd = true;\n        }\n\
    \    }\n    if is_odd {\n        array.sort();\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5boz0yvt.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut is_odd = true;\n    if array.len() > 0 {\n        is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    }\n    if is_odd {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut temp;\n   \
    \ while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            temp\
    \ = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphicmqw08.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzku_7goj.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut start = 0;\n    let mut end = array.len() - 1;\n    let mut is_odd\
    \ = (array[start] + array[end]) % 2 == 1;\n    while start < end {\n        if\
    \ is_odd {\n            if array[start] % 2 == 0 {\n                while start\
    \ < end && array[end] % 2 == 1 {\n                    end -= 1;\n            \
    \    }\n                array.swap(start, end);\n            }\n        } else\
    \ {\n            if array[start] % 2 == 1 {\n                while start < end\
    \ && array[end] % 2 == 0 {\n                    end -= 1;\n                }\n\
    \                array.swap(start, end);\n            }\n        }\n        start\
    \ += 1;\n    }\n    if is_odd {\n        array.sort();\n    } else {\n       \
    \ array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkj67gpod.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        let sum = array[0] + array[array.len() - 1];\n\
    \        if sum % 2 == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            result.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    while i < j {\n        if is_odd {\n\
    \            if array[i] % 2 == 0 {\n                while array[j] % 2 == 0 {\n\
    \                    j -= 1;\n                }\n                array.swap(i,\
    \ j);\n            }\n        } else {\n            if array[i] % 2 == 1 {\n \
    \               while array[j] % 2 == 1 {\n                    j -= 1;\n     \
    \           }\n                array.swap(i, j);\n            }\n        }\n \
    \       i += 1;\n    }\n    array.sort_by(|a, b| {\n        if is_odd {\n    \
    \        b.cmp(a)\n        } else {\n            a.cmp(b)\n        }\n    });\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpuzidhhkp.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    let mut i = 0;\n    let mut j = array.len()\
    \ - 1;\n    if array.len() % 2 == 0 {\n        while i < j {\n            array.swap(i,\
    \ j);\n            i += 1;\n            j -= 1;\n        }\n    } else {\n   \
    \     while i < j - 1 {\n            array.swap(i, j);\n            i += 1;\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi2uwwyj_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let first = array[0];\n        let last = array[array.len()\
    \ - 1];\n        if (first + last) % 2 == 0 {\n            array.sort_by(|a, b|\
    \ b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        array = merge(left, right);\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpi1iu9lj8.rs:17:17\n\
    \   |\n17 |         array = merge(left, right);\n   |                 ^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1iu9lj8.rs:15:16\n\
    \   |\n14 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |              -------- expected due to the type of this binding\n\
    15 |         left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi1iu9lj8.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        i = 0;\n        while i < j {\n            if array[j] < array[j - 1]\
    \ {\n                array.swap(j, j - 1);\n                sorted = false;\n\
    \            }\n            j -= 1;\n        }\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1n2xiuh_.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpcbvrzl2g.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    while i < j {\n        if is_odd {\n\
    \            if array[i] % 2 == 0 {\n                while array[j] % 2 == 0 {\n\
    \                    j -= 1;\n                }\n                array.swap(i,\
    \ j);\n            }\n        } else {\n            if array[i] % 2 == 1 {\n \
    \               while array[j] % 2 == 1 {\n                    j -= 1;\n     \
    \           }\n                array.swap(i, j);\n            }\n        }\n \
    \       i += 1;\n    }\n    if is_odd {\n        array[..i].sort();\n        array[i..].sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a, b| b.cmp(a));\n\
    \        array[i..].sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprsnfypqh.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    while i < j {\n        if is_odd {\n\
    \            if array[i] % 2 == 0 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 1 {\n                j -= 1;\n            } else {\n    \
    \            array.swap(i, j);\n                i += 1;\n                j -=\
    \ 1;\n            }\n        } else {\n            if array[i] % 2 == 1 {\n  \
    \              i += 1;\n            } else if array[j] % 2 == 0 {\n          \
    \      j -= 1;\n            } else {\n                array.swap(i, j);\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    }\n\
    \    array.sort_by(|a, b| {\n        if is_odd {\n            a.cmp(b)\n     \
    \   } else {\n            b.cmp(a)\n        }\n    });\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwu0_dmc7.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array[..i].sort();\n\
    \        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        array[i..].sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp79vm7v5z.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i, j);\n   \
    \     }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpfjazr6i1.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpw7lwycjn.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            if array[j] % 2 == 1 {\n           \
    \     array.swap(i, j);\n                i += 1;\n                j -= 1;\n  \
    \          } else {\n                j -= 1;\n            }\n        } else {\n\
    \            i += 1;\n        }\n    }\n    if array.len() % 2 == 0 {\n      \
    \  array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[i..].sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbuzpco1w.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array[..i].sort();\n\
    \        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        array[i..].sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpetm1c6gc.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if array[i] % 2 == 0 {\n            while i < j && array[j] % 2 == 0 {\n\
    \                j -= 1;\n            }\n            array.swap(i, j);\n     \
    \   }\n        i += 1;\n    }\n    if array.len() % 2 == 0 {\n        array[..i].sort();\n\
    \        array[i..].sort_by(|a, b| b.cmp(a));\n    } else {\n        array[..i].sort_by(|a,\
    \ b| b.cmp(a));\n        array[i..].sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0i0w7ocp.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n        left = sort_array(left.to_vec());\n        right = sort_array(right.to_vec());\n\
    \        array = merge(left, right);\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpv4rd21_q.rs:17:17\n\
    \   |\n17 |         array = merge(left, right);\n   |                 ^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4rd21_q.rs:15:16\n\
    \   |\n14 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |              -------- expected due to the type of this binding\n\
    15 |         left = sort_array(left.to_vec());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&mut [isize]`, found struct `Vec`\n   |\n   = note: expected mutable\
    \ reference `&mut [isize]`\n                         found struct `Vec<isize>`\n\
    help: consider dereferencing here to assign to the mutable borrowed piece of memory\n\
    \   |\n15 |         *left = sort_array(left.to_vec());\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4rd21_q.rs:16:17\n   |\n14 |         let (mut\
    \ left, mut right) = array.split_at_mut(array.len() / 2);\n   |              \
    \          --------- expected due to the type of this binding\n15 |         left\
    \ = sort_array(left.to_vec());\n16 |         right = sort_array(right.to_vec());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut [isize]`, found\
    \ struct `Vec`\n   |\n   = note: expected mutable reference `&mut [isize]`\n \
    \                        found struct `Vec<isize>`\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n16 |         *right\
    \ = sort_array(right.to_vec());\n   |         +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (first, last) = (array[0], array[array.len()\
    \ - 1]);\n        if (first + last) % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort();\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjd2ni4ec.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] > array[i + 1] {\n                array.swap(i, i + 1);\n   \
    \             sorted = false;\n            }\n            i += 1;\n        }\n\
    \        while j > i {\n            if array[j] < array[j - 1] {\n           \
    \     array.swap(j, j - 1);\n                sorted = false;\n            }\n\
    \            j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdx_1ku1z.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let (mut start, mut end) = (0, array.len()\
    \ - 1);\n        while start < end {\n            if array[start] % 2 == 0 {\n\
    \                array.swap(start, end);\n                end -= 1;\n        \
    \    } else {\n                start += 1;\n            }\n        }\n       \
    \ if array[start] % 2 == 0 {\n            start += 1;\n        }\n        array[..start].sort();\n\
    \        array[start..].sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 3, 5, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe370ub_i.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp9qcs4cq1.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppbplaw0j.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if array[i] % 2 == 0 && array[j] %\
    \ 2 == 1 {\n                array.swap(i, j);\n                i += 1;\n     \
    \           j -= 1;\n            } else if array[i] % 2 == 1 && array[j] % 2 ==\
    \ 0 {\n                i += 1;\n                j -= 1;\n            } else if\
    \ array[i] % 2 == 1 && array[j] % 2 == 1 {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        if array.len()\
    \ % 2 == 1 {\n            array[i..].sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array[i..].sort();\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 2, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpghiyb164.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i, j);\n\
    \                sorted = false;\n            }\n            i += 1;\n       \
    \     j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmy792pp9.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i < j {\n            if (array[i] + array[j]) % 2 == 0 {\n\
    \                array.swap(i, j);\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n        array.sort();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmplz6cp3vr.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    if len == 0 {\n        return array;\n    }\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if (array[i]\
    \ + array[j]) % 2 == 0 {\n            array.swap(i, j);\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    array.sort();\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpuz3v8c35.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    let mut sorted = false;\n\
    \    while !sorted {\n        sorted = true;\n        while i < j {\n        \
    \    if array[i] % 2 == 0 && array[j] % 2 == 1 {\n                array.swap(i,\
    \ j);\n                sorted = false;\n            }\n            i += 1;\n \
    \           j -= 1;\n        }\n        i = 0;\n        j = array.len() - 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp75zyx5p4.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
