name: HumanEval_126_is_sorted
language: rust
results:
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp65q3_5z5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i <= p {\n          \
    \      sorted = false;\n                break;\n            }\n        }\n   \
    \     prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkysoaz3f.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.dedup();\n\
    \    sorted == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzdy8rce8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc7ebw61w.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            sorted = false;\n        }\n  \
    \      last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbeu6708g.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for n in lst {\n        if let Some(last)\
    \ = last {\n            if n < last {\n                return false;\n       \
    \     }\n        }\n        last = Some(n);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptctbjpf0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp2a1wtfo4.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppwjnggze.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp54ki4ig5.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = 0;\n    let mut count = 0;\n    for i in lst {\n\
    \        if i == last {\n            count += 1;\n        }\n        if count\
    \ > 1 {\n            return false;\n        }\n        if i < last {\n       \
    \     return false;\n        }\n        last = i;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptn96pw2_.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ykv20nq.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpvqhehtuh.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoqmbcbu_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i <= p {\n          \
    \      sorted = false;\n                break;\n            }\n        }\n   \
    \     prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyie6y0u1.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpf9yres3g.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp2xoi1orv.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7ppuxvxz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp63boh38n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8nlk31yh.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() > i {\n            return false;\n\
    \        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaii1uhv0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpagbeb71u.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpgjqohqmz.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for i in lst {\n        if let Some(x)\
    \ = last {\n            if x >= i {\n                return false;\n         \
    \   }\n        }\n        last = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3sbrr_2m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcv605dol.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp499wlmgb.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmps3x7_pqs.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev > curr {\n            return false;\n\
    \        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5w8gcyhi.rs:17:19\n   |\n\
    17 |         if prev > curr {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n17 |         if prev > Some(curr) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5w8gcyhi.rs:20:16\n   |\n15 |  \
    \   let mut prev = lst_iter.next();\n   |                    --------------- expected\
    \ due to this value\n...\n20 |         prev = curr;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         prev = Some(curr);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp7xpe0k0j.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(j) = last {\n            if i < j {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    last = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkuy2bt3a.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev.is_none() || curr < prev.unwrap()\
    \ {\n            return false;\n        }\n        prev = Some(curr);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf1kahtoe.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7aa82v1d.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() >= i {\n            return\
    \ false;\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppst_362o.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwy1ovfi4.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp6vcechbj.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8tffc2zm.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdr3pegjg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() >= i {\n            return\
    \ false;\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxulek3ia.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpjm9vtd4w.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmplocn5a_0.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpnd_b33dk.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpcwvea2hy.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwyz_emet.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe9i2_258.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmphdthev27.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() >= i {\n            return\
    \ false;\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpywhyip3c.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for num in lst {\n        if let Some(prev)\
    \ = last {\n            if num < prev {\n                return false;\n     \
    \       }\n        }\n        last = Some(num);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl7j8w4am.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() > i {\n            return false;\n\
    \        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_5i8qbgo.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbnmu0z66.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for n in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= n {\n                return false;\n         \
    \   }\n        }\n        prev = Some(n);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsz4eipzp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpviwm1e2h.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    for i in lst {\n       \
    \ if i < last {\n            return false;\n        }\n        last = i;\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp36ux9jix.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for n in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= n {\n                return false;\n         \
    \   }\n        }\n        prev = Some(n);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9nx3z6n1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3qx5n9r4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpal_7nlym.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphdltm0cn.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if prev >= i {\n            sorted = false;\n        }\n \
    \       prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoo521udk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp3ivt7ai3.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkf1w0s5g.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxfd0hrc4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(j) = last {\n            if i < j {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    last = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphxqxj4f4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphq6wpq27.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9iv9oner.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc48c5jbn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplqy8wsbf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz05a2fpa.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev.is_none() || prev.unwrap() >= curr\
    \ {\n            return false;\n        }\n        prev = Some(curr);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8hm1nshn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = lst[0];\n    for i in lst {\n        if i < prev\
    \ {\n            return false;\n        }\n        prev = i;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpujitkjyw.rs:14:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpc4h8nytp.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() >= i {\n            return\
    \ false;\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbzujau3c.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpeztvly6i.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(last_val) = last {\n            if i < last_val {\n\
    \                sorted = false;\n                break;\n            }\n    \
    \    }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgvp3c89w.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnep7vnhz.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpq9lc61__.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpc2fw2ty3.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5xj7t6zf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp80y8bbb5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev > curr {\n            return false;\n\
    \        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprwv0iviu.rs:17:19\n   |\n\
    17 |         if prev > curr {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n17 |         if prev > Some(curr) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprwv0iviu.rs:20:16\n   |\n15 |  \
    \   let mut prev = lst_iter.next();\n   |                    --------------- expected\
    \ due to this value\n...\n20 |         prev = curr;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         prev = Some(curr);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6bo1b4ok.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if prev >= lst[i] {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpzngabz0h.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpn6fb69wq.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for item\
    \ in lst {\n        if let Some(p) = prev {\n            if item < p {\n     \
    \           sorted = false;\n                break;\n            }\n        }\n\
    \        prev = Some(item);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpemjkdysv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn_9r8y5b.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuqw0vx94.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for n in lst_iter {\n        if prev.is_none() || n < prev.unwrap() {\n \
    \           return false;\n        }\n        prev = Some(n);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp99l4smzy.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptobk3_uf.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8jg39_cn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for n in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= n {\n          \
    \      sorted = false;\n                break;\n            }\n        }\n   \
    \     prev = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm91d0y5t.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpuq88n53x.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv9aljmwx.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            sorted = false;\n        }\n  \
    \      last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpop_jwdsh.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp7xjqun8s.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3nwv19wb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpgkrzzw_l.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcf3tvjcf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp78aakcw8.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyytoo21n.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for i in lst_iter {\n        if prev.unwrap() >= i {\n            return\
    \ false;\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_76zis90.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpia_uziqd.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for n in lst_iter {\n        if prev.is_none() || prev.unwrap() > n {\n \
    \           return false;\n        }\n        prev = Some(n);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa82r4a3u.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprp8f7n8a.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().sorted().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmps3jfyw_d.rs:17:23\n   |\n17 |     lst ==\
    \ lst.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp74y_17eg.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp78zbhcp6.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for n in\
    \ lst {\n        if let Some(last_n) = last {\n            if n < last_n {\n \
    \               sorted = false;\n                break;\n            }\n     \
    \   }\n        last = Some(n);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgieg87ls.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplzrerz_x.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpe9g02mf7.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpfc470ekb.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp50k726kl.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpb4vfg1b3.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd95kg63k.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for n in lst_iter {\n        if prev.unwrap() >= n {\n            return\
    \ false;\n        }\n        prev = Some(n);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjuli2duq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1ou5z37l.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps7zza2ns.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpvhnx2_zm.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy_vcgc_a.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if prev >= lst[i] {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp3l77_lpl.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp0118wxgl.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpb4qsr587.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwxqx0hxk.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsdtyyf58.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwir74j8v.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp8im8tc9u.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpimai86mb.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmptuy5u2zk.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpck4_0mw_.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmphnmfvsfp.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if prev >= lst[i] {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbdf8rttl.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprvk17bxw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.dedup();\n\
    \    sorted == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn7w9u5k8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for x in lst {\n        if let Some(y)\
    \ = last {\n            if x < y {\n                return false;\n          \
    \  }\n        }\n        last = Some(x);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo1wdyx9h.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpk4bambdr.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprkf23jia.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp57_i42yv.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8_m_myv6.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            sorted = false;\n        }\n  \
    \      last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpw2w955fs.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for i in lst {\n        if let Some(j)\
    \ = last {\n            if i < j {\n                return false;\n          \
    \  }\n        }\n        last = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp699t3xrr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsec2flsf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc3wrtwsx.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for i in\
    \ lst {\n        if last.is_some() && last.unwrap() >= i {\n            sorted\
    \ = false;\n            break;\n        }\n        last = Some(i);\n    }\n  \
    \  sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw9kx3rrr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_8tt0obm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpa62c9pgn.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpm9t0rd75.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwn38w28g.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmplrrt50b4.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    for i in lst {\n       \
    \ if i < last {\n            return false;\n        }\n        last = i;\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9ru5glt0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for x in\
    \ lst {\n        if let Some(p) = prev {\n            if p >= x {\n          \
    \      sorted = false;\n                break;\n            }\n        }\n   \
    \     prev = Some(x);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprbexv2we.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpct1zvi_6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        match prev {\n            Some(p) => {\n                if i\
    \ < p {\n                    sorted = false;\n                    break;\n   \
    \             }\n            }\n            None => (),\n        }\n        prev\
    \ = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaz1ekczp.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdvdsl8yq.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpds311bjk.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpq2lg06t6.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpsf_jznj9.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpooxx3ap3.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpc3s6llh9.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if prev > i {\n            sorted = false;\n        }\n        prev\
    \ = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp44israme.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp2cdptby0.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp00tofrkt.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev > curr {\n            return false;\n\
    \        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_gmk5248.rs:17:19\n   |\n\
    17 |         if prev > curr {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n17 |         if prev > Some(curr) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_gmk5248.rs:20:16\n   |\n15 |  \
    \   let mut prev = lst_iter.next();\n   |                    --------------- expected\
    \ due to this value\n...\n20 |         prev = curr;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         prev = Some(curr);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev > curr {\n            return false;\n\
    \        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprb74gwff.rs:17:19\n   |\n\
    17 |         if prev > curr {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n17 |         if prev > Some(curr) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprb74gwff.rs:20:16\n   |\n15 |  \
    \   let mut prev = lst_iter.next();\n   |                    --------------- expected\
    \ due to this value\n...\n20 |         prev = curr;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         prev = Some(curr);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzke_1m3l.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(j)\
    \ = prev {\n            if i < j {\n                return false;\n          \
    \  }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjtmq82w.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i < last {\n            sorted = false;\n        }\n  \
    \      last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqhfsqb7q.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut last_val = lst_iter.next().unwrap();\n\
    \    let mut last_val_count = 1;\n    for val in lst_iter {\n        if *val <\
    \ last_val {\n            return false;\n        } else if *val == last_val {\n\
    \            last_val_count += 1;\n            if last_val_count > 1 {\n     \
    \           return false;\n            }\n        } else {\n            last_val\
    \ = *val;\n            last_val_count = 1;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmhpr3xap.rs:18:19\n   |\n\
    18 |         if *val < last_val {\n   |                   ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |  \
    \       if *val < *last_val {\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmhpr3xap.rs:20:27\n   |\n20 |         } else if *val ==\
    \ last_val {\n   |                           ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \ } else if *val == *last_val {\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmhpr3xap.rs:26:24\n   |\n15 |     let mut last_val\
    \ = lst_iter.next().unwrap();\n   |                        ------------------------\
    \ expected due to this value\n...\n26 |             last_val = *val;\n   |   \
    \                     ^^^^\n   |                        |\n   |              \
    \          expected `&isize`, found `isize`\n   |                        help:\
    \ consider borrowing here: `&*val`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev > curr {\n            return false;\n\
    \        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr8cs0l4y.rs:17:19\n   |\n\
    17 |         if prev > curr {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n17 |         if prev > Some(curr) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr8cs0l4y.rs:20:16\n   |\n15 |  \
    \   let mut prev = lst_iter.next();\n   |                    --------------- expected\
    \ due to this value\n...\n20 |         prev = curr;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         prev = Some(curr);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpa747anby.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpv610x__0.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if i < prev {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpmv0wy6hl.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp2x1zneeo.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp88zlrcnk.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy_8fjf90.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for i in\
    \ lst {\n        if let Some(last_i) = last {\n            if i < last_i {\n \
    \               sorted = false;\n                break;\n            }\n     \
    \   }\n        last = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz1os0_1_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdemz22y0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for i in lst {\n        if let Some(j)\
    \ = last {\n            if i < j {\n                return false;\n          \
    \  }\n        }\n        last = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqngdxswr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph60w2co0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_3uq2qyn.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.dedup();\n\
    \    sorted == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwyu2yl7y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    let mut prev = lst_iter.next();\n\
    \    for curr in lst_iter {\n        if prev.unwrap() > curr {\n            return\
    \ false;\n        }\n        prev = Some(curr);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk__cyfyh.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst {\n        if prev > i {\n            sorted = false;\n        }\n  \
    \      prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpsyi8hqo0.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0_xa0m8k.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm5ewtdfd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpck9sxhdu.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < last {\n            sorted = false;\n\
    \            break;\n        }\n        last = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmplbko3p8o.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6rozr01w.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxeu9q2zk.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxn0ycrjx.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpan8bx149.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpog99z6ed.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            sorted = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0g7nfo4e.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmph89id9nn.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3cyyc3ms.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_5_yf_j3.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppkhmyaek.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpszy7cgap.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for i in lst {\n        if let Some(p)\
    \ = prev {\n            if p >= i {\n                return false;\n         \
    \   }\n        }\n        prev = Some(i);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0df056uz.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in lst.iter() {\n        if prev > *i {\n            sorted = false;\n     \
    \       break;\n        }\n        prev = *i;\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5_geyux9.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpuo6pi_mb.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if lst[i] < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp8nbq1bor.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = lst[0];\n    for i\
    \ in 1..lst.len() {\n        if prev > lst[i] {\n            sorted = false;\n\
    \            break;\n        }\n        prev = lst[i];\n    }\n    sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbn3q7a3y.rs:15:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev = None;\n    for i in\
    \ lst {\n        if let Some(p) = prev {\n            if i < p {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi4dhqn6g.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpc16wmhhc.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().collect::<Vec<_>>()\n   |         ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
