name: HumanEval_128_prod_signs
language: rust
results:
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpx99yhd_1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpcrjur4wx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp4cb8swyr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp_6ivscl4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpoul9ifd_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpm4brc50t.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1;\n            sum += i;\n     \
    \   } else if i < 0 {\n            prod *= -1;\n            sum += i.abs();\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpy039o9ff.rs:23:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n23  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        } else if i > 0 {\n            sum += i;\n \
    \       }\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpcj7i5p3l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprsqyvcl7.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            prod = 0;\n        } else if i < 0 {\n            prod *= -1;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp122zm33o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp1rnmyl7b.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpo_vmiz2k.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpeee_uebx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num >\
    \ 0 {\n            prod *= 1;\n        } else if num < 0 {\n            prod *=\
    \ -1;\n        } else {\n            prod *= 0;\n        }\n        sum += num.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp1qijah16.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpqnfp9lhr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1;\n            sum += i;\n     \
    \   } else if i < 0 {\n            prod *= -1;\n            sum += i.abs();\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmprthutms6.rs:23:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n23  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num ==\
    \ 0 {\n            continue;\n        }\n        prod *= num.signum();\n     \
    \   sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpnj32wsi4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmppbo3owwz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            res *= 1;\n        } else if i < 0 {\n            res *= -1;\n  \
    \      } else {\n            res *= 0;\n        }\n        sum += i.abs();\n \
    \   }\n    Some(res * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1;\n            sum += i;\n     \
    \   } else if i < 0 {\n            prod *= -1;\n            sum += -i;\n     \
    \   } else {\n            prod *= 0;\n        }\n    }\n    if arr.len() == 0\
    \ {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpm5qk7ztr.rs:23:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n23  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum = arr.iter().fold(0, |acc, x| acc + x.abs());\n    let prod = arr.iter().fold(1,\
    \ |acc, x| acc * x.signum());\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num >\
    \ 0 {\n            prod *= 1;\n        } else if num < 0 {\n            prod *=\
    \ -1;\n        } else {\n            prod *= 0;\n        }\n        sum += num.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        } else if i > 0 {\n            sum += i;\n \
    \       }\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmp685y6kby.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        if i != 0 {\n\
    \            sum += i.abs();\n            prod *= i.signum();\n        }\n   \
    \ }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp3i2_uyu5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            continue;\n        }\n        prod *= i.signum();\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp5cbm2zd1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for n in arr {\n        prod *= n.signum();\n\
    \        sum += n.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut sum = 0;\n    let mut prod = 1;\n    for i in arr\
    \ {\n        if i > 0 {\n            sum += i;\n            prod *= 1;\n     \
    \   } else if i < 0 {\n            sum += -i;\n            prod *= -1;\n     \
    \   } else {\n            prod *= 0;\n        }\n    }\n    if sum == 0 {\n  \
    \      None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sign_prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num\
    \ > 0 {\n            sign_prod *= 1;\n        } else if num < 0 {\n          \
    \  sign_prod *= -1;\n        } else {\n            sign_prod *= 0;\n        }\n\
    \        sum += num.abs();\n    }\n    Some(sum * sign_prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for num in arr {\n        sum += num.abs();\n\
    \        prod *= num.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n\
    \            prod = 0;\n        } else if i < 0 {\n            prod *= -1;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpzoj55s5j.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp5il7_j9p.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
