{
  "name": "HumanEval_131_digits",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Given a positive integer n, return the product of the odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; >>> (digits 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 15\n(define (digits n)\n",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal? (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate 2468) 0)\n))\n\n(test-humaneval)",
  "completions": [
    "  (if (zero? n)\n    0\n    (let ((digits (string->number n))\n          (result 0))\n      (for-each (lambda (digit)\n                  (if (odd? digit)\n                    (set! result (* result digit))\n                    (set! result 0)))\n        digits)))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((< i n))\n          (set! result (* i (read-number i))))\n        (else\n          result)))\n    result)\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! i (+ i 1))\n          (if (odd? i)\n            (set! result (* i (read-int i)))))))\n    (+ result result)))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (while (< n 0)\n        (set! result (* result (* (read-int) 2)))\n        (set! n (- n 1)))))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (modulo n 2)))\n        (set! n (- n 1)))))\n)\n",
    "  (cond\n    ((zero? n) 0)\n    ((odd? (remainder n 2)) (quotient n 2))\n    (else (product (map odd? (quotient n 2))))))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (begin\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (* (read-int n) (read-int n))))\n        (set! result (result (*",
    "  (let* ([digits (string->list (string->number n))]\n         [result 0])\n    (if (odd? digits)\n      (result (apply (lambda (x y) (* x y))\n                 (first digits)\n                 (second digits)))\n      result 0)\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\"))\n    (while (< n 0)\n      (set! result (* result (modulo n 2)))\n      (set! n (- n 1)))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! i (+ i 1))\n          (if (odd? (modulo i 10))\n            (set! result (* result (modulo i 10)))\n            (set! result (* result (modulo i 10)))\n          )\n        )\n        (return result)\n      )\n    )\n  )\n)\n",
    "  (let* ([digits (string->list (string-split \"0123456789\" n))]\n         [odds (filter odd? digits)]\n         [odd-digits (map odd? odds)]\n         [result (reduce (* odd-digits))])\n    (if result 0\n      result\n      0)))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (let ((i 0))\n        (while (< i n)\n          (set! result (* (modulo (/ i 2)) result)))\n        (set! result (* (modulo (/ i 3) result)))\n        (set! result (* (modulo (/ i 5) result)))\n        (set! result (* (modulo (/ i 7) result)))\n        (set! result (* (modulo (/ i 11) result)))\n        (set! result (* (modulo (/ i 13) result)))\n        (set! result (* (modulo (/ i 17) result)))\n        (set! result (* (modulo (/ i 19) result)))\n        (set! result (* (modulo (/ i 23) result)))\n        (set! result (* (modulo (/ i 29) result)))\n        (set! result (* (modulo (/ i 31) result)))\n        (set! result (* (modulo (/ i 37) result)))\n        (set! result (* (modulo (/ i 41) result)))\n        (set! result (* (modulo (/ i 43) result)))\n        (set! result (* (modulo (/ i 47) result)))\n        (set! result (* (modulo (/ i 53) result)))\n        (set! result (* (modulo (/ i 59) result)))\n        (set! result (* (modulo (/ i 61) result)))\n        (set! result (* (modulo (/ i 67) result)))\n        (set! result (* (modulo (/ i 71) result)))\n        (set! result (* (modulo (/ i 73) result)))\n        (set! result (* (modulo (/ i 79) result)))\n        (set! result (* (modulo (/ i 83) result)))\n        (set! result (* (modulo (/ i 89) result)))\n        (set! result (* (modulo (/ i 97) result)))\n        (set! result (* (modulo (/ i 101) result)))\n        (set! result (* (modulo (/ i 103) result)))\n        (set! result (* (modulo (/ i 107) result)))\n        (set! result (* (modulo (/ i 109) result)))\n        ",
    "  (let ((result 0))\n    (while (< n 0)\n      (if (odd? (remainder n 2))\n        (set! result (* result (remainder n 2)))\n        (set! n (- n 1))))\n    result))\n",
    "  (let ((result 0))\n    (if (zero? n)\n      result\n    (let ((i 0))\n      (while (< i n)\n        (set! i (i + 1))\n        (if (odd? (modulo i 10))\n          (set! result (* (modulo i 10) result))\n        ))\n      result))\n  )\n)\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n i))\n        (set! result (* i (read-int i))))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((i (quotient n 2)))\n        (if (odd? i)\n          (set! result (* result i))\n          (set! n (- n 2)))))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((i (1)))\n    (while (< i n)\n      (if (odd? (modulo i 10))\n        (return (* i (modulo i 10)))\n        (i (i (+ 1)))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"Negative numbers not supported\")\n      (if (odd? n)\n        (do ((i (modulo n 2)))\n          ((= i 0) (set! result 1))\n          (else (set! result (* result i))))\n        (else result 1))))\n",
    "  (let ((result 0))\n    (if (zero? n)\n      result\n    (let ((i 0))\n      (while (< i n)\n        (set! result (* result (modulo (/ i 2) 10)))\n        (set! i (+ i 1)))))\n  result)\n",
    "  (let* ([i (modulo n 10)])\n    (if (= i 0)\n      0\n      (if (= i 1)\n        1\n        (let* ([j (modulo i 2)])\n          (if (= j 0)\n            0\n            (if (= j 1)\n              1\n              (let* ([k (modulo j 2)])\n                (if (= k 0)\n                  0\n                  (if (= k 1)\n                    1\n                    (let* ([l (modulo k 2)])\n                      (if (= l 0)\n                        0\n                        (if (= l 1)\n                          1\n                          (+ (digits (modulo l 2)) (digits (modulo l 2))))))))))))))))))))))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([digits (string-split \"123456789\" digits)])\n        (if (odd? (car digits))\n          (car (cdr digits))\n          0))))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (modulo n 2)))\n        (set! n (- n 1)))))\n)\n",
    "  (let* ([digits (string->list (string->number n))]\n         [odds (filter odd digits)])\n    (if (null? odds)\n      0\n      (reduce (lambda (a b) (* a b)) odds)))\n)\n",
    "  (let* ([result 0])\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n 0))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (quotient n 2)))\n        ((= i 0) (set! result (multiply result (quotient (remainder n 2) 2))))\n        (set! result (multiply result (quotient (remainder n 2) 2))))\n      (return result)))\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"Negative numbers not supported\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((< i n))\n          (set! result (* (read-number i) result)))\n        (else\n          result)))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (if (odd? n)\n        (let ((i 0))\n          (while (< i n)\n            (set! result (* result (read-int i)))\n            (set! i (+ i 1)))))\n      result))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (modulo n 10)))\n        ((= i 0) (set! result (result (* i (read-char #\\space))))))\n        (set! result 0))\n      result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [(odd? n) (quotient n 2)]\n    [else (quotient n 2)]))\n",
    "  (let ((result 0))\n    (if (zero? n)\n      result\n    (if (odd? n)\n      (let ((i (quotient n 2)))\n        (result (* (quotient i 2) i)))\n    (let ((i (quotient n 2)))\n      (result (* i i))))))\n",
    "  (let ((n (abs n)))\n    (if (< n 0)\n      0\n      (let ((digits (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (string-ref x n)) (string-split \"",
    "  (if (zero? n)\n    0\n    (let ((digits (string-split \"123456789\" n)))\n      (reduce (lambda (a b) (* a b))\n        (map (lambda (d) (if (zero? d) 0 (odd? d))) digits))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 1)))\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (modulo n i)) result)))\n      (else result)))\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"Negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (modulo n i)) result)))\n      (+ result result))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (mul (odd? (modulo n 2)) (digits (modulo n 2))))]))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([odds (filter odd? digits)])\n        (if (empty? odds)\n          0\n          (* odds (first odds)))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((< i n))\n          (set! result (* i (read-number i))))\n        (else\n          result)))\n    result))\n",
    "  (if (zero? n)\n    0\n    (let ((i (quotient n 2)))\n      (if (odd? i)\n        (let ((p (quotient i 10)))\n          (if (odd? p)\n            (+ p (quotient (remainder n 10) 2)))\n            (+ (remainder n 10) (quotient (remainder n 10) 2)))))))\n",
    "  (let* ([digits (string->list (string-split \"123456789\" n))]\n         [odds (filter odd? digits)])\n    (if (null? odds)\n      0\n      (reduce (lambda (a b) (* a b)) odds)))\n)\n",
    "  (let* ([digits (string->list (string-split \"123456789\" n))]\n         [result 0])\n    (for ([i 0 (length digits)])\n      (if (odd? (string->number (string-ref digits i)))\n          (set! result (result * (string->number (string-ref digits i))))\n        (set! result 0))\n      (set! result 0))\n    result))\n",
    "  (if (zero? n)\n    0\n    (let ((i (1)))\n      (while (< i n)\n        (if (odd? (modulo i 10))\n          (return (* i (modulo i 10)))\n          (i (i (+ 1)))))))\n)\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n 0))\n        ((= (modulo n i) 0))\n        (set! result (result (* i i)))\n        )\n      (else\n        result 1))\n    result)\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\"))\n    (let ((i 0))\n      (while (< i n)\n        (if (odd? (modulo (read-integer i) 10))\n            (set! result (result (modulo (read-integer i) 10))\n               (set! i (i + 1)))\n            (set! i (i + 1)))\n        (set! i (i + 1)))\n      result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (multiply (first (string-split \" \" (string n) 1)))]\n    [else (multiply (first (string-split \" \" (string n) 1)))]\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (if (odd? n)\n        (let ((i 0))\n          (while (< i n)\n            (set! i (+ i 1))\n            (set! result (* result i)))))\n      (return result)))\n",
    "  (let* ([d (div n 2)\n           m (modulo n 2)])\n    (if (= d 0)\n      (if (= m 0)\n        0\n        (+ (digits (sub d 1)) (* d m)))\n      (+ (digits (sub d 1)) (* d m)))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (modulo n i)) result)))\n      (else result)))\n)\n",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (modulo n 2)))\n        (set! n (- n 1)))))\n)\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([odds (filter odd? digits)])\n        (* (first odds) (first (cdr odds)))\n      )\n    )\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (modulo n i)) result)))\n      (+ result result))\n    result))\n",
    "  (let ((i 0))\n    (while (< i n)\n      (if (odd? (modulo i 10))\n        (return (* i (modulo i 10)))\n        (i (inc i)))))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let ([digits-sum (reduce (lambda (a b) (+ a b)) 0 digits)])\n        (if (modulo digits-sum 2)\n          (reduce (lambda (a b) (* a b)) 1 digits)\n          0))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? i) result)))\n      (else result)))\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\"))\n    (let ((i 0))\n      (while (< i n)\n        (if (odd? (modulo (/ i 10)))\n            (set! result (* result (modulo (/ i 10))))\n            (set! i (add 1 i))))\n      result)))\n",
    "  (let* ([i (modulo n 10)])\n    (if (zero? i)\n      0\n      (if (odd? i)\n        (let* ([p (modulo (quotient n 10) 2)])\n          (if (zero? p)\n            (quotient n 10)\n            (quotient (quotient n 10) 2)))\n        (quotient n 10))))\n",
    "  (let* ([digits (string->list (string->number n))]\n         [result 0])\n    (if (odd? digits)\n      (let* ([i (first digits)]\n             [j (last digits)])\n        (if (odd? i)\n          (result (* i j))\n          (result 0)))\n      result))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([digits-length (length digits)])\n        (let* ([odd-digits (filter odd? digits)])\n          (if (odd-digits)\n            (reduce (lambda (a b) (* a b)) odd-digits)\n            0))))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (product (map (lambda (x) (odd? x)) (take n (string->list \"123456789\"))))]\n  )\n)\n",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (+ (modulo n 2) 1)))\n        (set! n (- n 1)))))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (product (map (odd? n) (range 1 9)))]\n    [(zero? n) 0]\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (modulo (/ i 2)) 1)))\n      result))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? n) (let-values ([(i (modulo n 2))]) (if (zero? i) 0 (n * (i + 1))))]\n    [else n]))\n",
    "  (let ((i n))\n    (if (odd? i)\n      (do ((i (decrement i)))\n        ((= i 0))\n        (return (* i i)))\n      (return 0)))))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([digits-length (length digits)])\n        (if (even? digits-length)\n          0\n          (let* ([odd-digits (first digits)])\n            (let* ([odd-digits-length (length odd-digits)])\n              (if (even? odd-digits-length)\n                0\n                (let* ([odd-digits-product (product odd-digits)])\n                  (if (odd? odd-digits-product)\n                    odd-digits-product\n                    (product odd-digits-product (product odd-digits))))))))))))\n",
    "  (let ((i n))\n    (if (< i 0)\n      0\n      (let ((odd (modulo i 2)))\n        (if odd\n          (+ (modulo i 3)\n             (digits (sub1 i)))\n          (digits (sub1 i)))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i (modulo n 2)))\n          ((= i 0)\n           (set! result (result (* (read-number i) (read-number (remainder n i)))))))\n        (else\n          (set! result 1))))\n  result)\n",
    "  (let ((result 0))\n    (if (zero? n)\n      result\n    (if (odd? n)\n      (let ((i n))\n        (if (odd? (quotient i 10))\n          (result (* i (quotient i 10)))\n          (result (* i (quotient i 10)))))\n      (let ((i n))\n        (if (odd? (quotient i 10))\n          (result (* i (quotient i 10)))\n          (result (* i (quotient i 10))))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")))\n  (let ((i 0))\n    (while (< i n)\n      (if (odd? (modulo (number->string i) 10))\n          (set! result (result * (number->string (modulo (number->string i) 10))))\n          (set! i (i + 1)))\n        (set! i (i + 1))))\n  result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [(odd? n)]\n    [else (quotient n 2)]))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! i (modulo (+ i 1) 10))\n          (set! result (* i result)))\n        (set! result 1)))))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n i))\n        (set! result (* i (read-number i))))\n      (else\n        result)))\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((< i n))\n          (set! result (* (read-number i) result)))\n        (else\n          result)))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((= i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((= i n))\n        (set! result (* (read-int i) result)))\n      (else\n        result))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (product (map (odd? n) (list 1 2 3 4 5 6 7 8 9))))]))\n",
    "  (let* ([p (modulo n 10)])\n    (if (zero? p)\n      0\n      (let* ([d (modulo (remainder n 10) 2)])\n        (if (zero? d)\n          (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2)\n            (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2)))))\n      ))\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be positive\")\n      (let ((i 0))\n        (while (< i n)\n          (if (odd? (modulo (read-number i) 10))\n            (set! result (result (modulo (read-number i) 10)))\n            (set! i (+ i 1)))\n          (else\n            (set! i (+ i 1))))\n        (+ result result)))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (set! result (* result (modulo (/ n 2) 2)))\n      (set! n (- n 1)))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo (/ n 10))))\n        (set! result (* result digit))\n        (set! n (- n 10))))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (begin\n        (set! result (* (read-int n) (read-int n)))\n        (return result)\n      )\n      (return 0)\n    )\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")))\n  (let ((i 0))\n    (while (< i n)\n      (if (odd? (modulo (/ i 10)))\n          (set! result (* result (modulo (/ i 10))))\n        (set! i (+ i 1))))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (if (zero? n)\n    0\n    (let ((digits (string->list (string->number n))))\n      (let ((odds (filter odd? digits)))\n        (if (empty? odds)\n          0\n          (* (first odds) (first (cdr odds))))))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (set! result (* (odd? (modulo n 2)) result)))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n)\n\n;; Given a positive integer n, return the product of the even digits.\n;; Return 0 if all digits are odd.\n;; For example:\n;; >>> (digits 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 15",
    "  (let ((result 0))\n    (while (< n 0)\n      (set! result (* result (modulo n 2)))\n      (set! n (- n 1)))\n    result))\n",
    "  (let* ([digits (string->list (string->number n))]\n         [odds (filter odd digits digits)]\n         [result (reduce (lambda (a b) (* a b)) odds)]))\n  result)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! i (modulo (+ i 1) 10))\n          (set! result (+ result (modulo n i))))))\n    result))\n",
    "  (cond\n    ((zero? n) 0)\n    ((even? n) 0)\n    (else\n      (let ((digits (string->list (string-append (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-append \"8\" (string-append \"9\" (string-append \"0\" (string-append \"1\" (string-append \"2\" (string-append \"3\" (string-append \"4\" (string-append \"5\" (string-append \"6\" (string-append \"7\" (string-",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! result (* result (+ (read-int i) 1)))\n          (set! i (+ i 1)))))\n    (return result)))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (if (odd? (modulo n i))\n            (set! result (result (modulo n i) (modulo n (add1 i))))\n            (set! i (add1 i))))\n        (return result)))\n    ))\n",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (odd? (remainder n 2))))\n        (set! n (- n 1)))))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? n) (product (map odd? n))]\n    [else n]))\n",
    "  (let* ([p (modulo n 10)])\n    (if (zero? p)\n      0\n      (let* ([d (modulo (remainder n 10) 2)])\n        (if (zero? d)\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          (+ (remainder n 2) (remainder (remainder n 2) 2))\n          ",
    "  (let* ([digits (string->list (string->number n))]\n         [result 0])\n    (for ([i (string->list digits)])\n      [if (odd? (string->number (car i)))\n        [result (result * (string->number (car i)))]\n        [else\n          (result 0)]])\n    result))\n",
    "  (let* ([i (modulo n 10)])\n    (if (= i 0)\n      0\n      (if (odd? i)\n        (+ (digits (quotient n i)) (digits (modulo n i)))\n        (digits (quotient n i))))))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n 0))\n        ((set! result (* (read-number i) result)))\n        (set! result 0))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\"))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (= digit 1)\n          (set! result (result * digit))\n          (set! n (- n 1))))\n      (set! result 0))\n    result)\n)\n\n;; Given a positive integer n, return the product of the even digits.\n;; Return 0 if all digits are odd.\n;; For example:\n;; >>> (digits 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 15",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (modulo n 10)))\n        ((= i 0))\n        ((= (modulo i 2) 1)\n          (set! result (result (* i result))))))\n      (else\n        result)))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((= i n))\n        (set! result (* (read-int i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (if (odd? (remainder n 2))\n        (set! result (result (remainder n 2)))\n        (set! n (- n 1))))\n    result))\n",
    "  (let* ([p (modulo n 10)]\n         [i 0])\n    (if (odd? p)\n      (+ (digits (quotient n 10)) i)\n      i)))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n)\n",
    "  (let* ([digits (string->list (string-split \"123456789\" n))]\n         [odds (filter odd? digits)]\n         [odd-digits (map odd? odds)]\n         [odd-product (reduce (* odd-digits))])\n    odd-product)))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (modulo n 10)) (modulo n 10)]\n    [else (product (map odd? (div n 10))) 0]))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (quotient n 2)))\n        ((= i 0) (result (* 2 (quotient (remainder n 2) 2))))\n        (set! result (* result i)))\n      (else\n        result 1))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (read-number i)) result)))\n      (else result)))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? n) (let ((p (prod odd? (cdr n)))) (if (zero? p) 0 p))]\n    [else (let ((p (prod odd? (cdr n)))) (if (zero? p) 0 p))]))\n",
    "  (let ((i n))\n    (if (< i 0)\n      0\n      (if (odd? (modulo i 10))\n        (+ (modulo i 10) (digits (modulo i 10)))\n        (digits (modulo i 10))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (let ((i 0))\n        (while (< i n)\n          (set! result (* result (modulo (/ i 2) 10)))\n          (set! i (+ i 1)))\n        result)))))\n",
    "  (let ((n (abs n)))\n    (if (< n 0)\n      0\n      (let ((digits (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (modulo x 2)) (string-split \"0123456789\" n))))))\n        (string-join \"0\" (map (lambda (x) (modulo x 2)) digits))))))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (if (odd? (modulo n i))\n            (set! result (result (modulo n i) (modulo n (divide n i))))\n            (set! i (add 1 i))))\n        (return result)))\n    ))\n",
    "  (let ((digits (vector 0 (vector 0))))\n    (let ((n (vector n)))\n      (for-each (lambda (x) (vector-set! digits (vector-ref digits x))) n)\n        (if (odd? (vector-ref digits 0))\n            (vector-set! digits (vector-ref digits 0) (* (vector-ref digits 0) (vector-ref n 0))))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))])\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\"))\n    (let ((i 0))\n      (while (< i n)\n        (if (odd? (modulo (read-number i) 10))\n            (set! result (result (modulo (read-number i) 10)))\n            (set! i (i + 1)))\n        (set! i (i + 1)))\n      result)\n  ))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1)))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n)\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((i (1)))\n    (if (< n 0)\n      0\n      (if (odd? i)\n        (+ (digits (sub1 i)) (* i i))\n        (digits (sub1 i))))))\n",
    "  (let ((n (abs n)))\n    (if (< n 0)\n      0\n      (let ((digits (vector 0 0)))\n        (let ((i 0))\n          (while (< i n)\n            (set! digits (vector (* (vector (car digits) (car i)) (cdr digits)) (cdr i)))\n            (set! i (cdr i))\n            )\n          )\n        (car digits)\n        )\n      )\n    )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((< i n))\n          (set! result (* (read-number i) result)))\n        (else\n          result)))))\n",
    "  (let ((i (1)))\n    (if (odd? i)\n      (let ((p (product i)))\n        (if (odd? p)\n          (return 0)\n          (return p)))\n      (return 0)))\n  n)\n",
    "  (let ((i n))\n    (if (odd? i)\n      (let ((p (digits (quotient i 2))))\n        (return (* p i))))\n    0)))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")))\n  (let ((i 0))\n    (while (< i n)\n      (if (odd? (modulo (/ i 10)))\n        (set! result (* result (modulo (/ i 10))))\n        (set! i (+ i 1))))\n    result))\n",
    "  (let ((n (abs n)))\n    (if (< n 0)\n      0\n      (let ((digits (string-split \"0123456789\" (string-join \"0\" (map (lambda (x) (modulo x 2)) (string-split \"0123456789\" n))))))\n        (if (even? digits)\n          0\n          (reduce (lambda (x y) (multiply x y)) 1 (map (lambda (x) (string-join \"0\" (string-split \"0123456789\" x))) digits)))))))\n",
    "  (let ((result 0))\n    (if (zero? n)\n      result\n    (let ((i 0))\n      (while (< i n)\n        (set! i (i + 1))\n        (if (odd? (remainder n i))\n          (set! result (result * (remainder n i)))\n          (set! i (i + 1))))\n      result))))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-int i) result)))\n      (else\n        result))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1)))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (modulo (/ i 2) 10) 1))\n        (set! result (* (modulo (/ i 3) 10) 1))\n        (set! result (* (modulo (/ i 4) 10) 1))\n        (set! result (* (modulo (/ i 5) 10) 1))\n        (set! result (* (modulo (/ i 6) 10) 1))\n        (set! result (* (modulo (/ i 7) 10) 1))\n        (set! result (* (modulo (/ i 8) 10) 1))\n        (set! result (* (modulo (/ i 9) 10) 1))\n        (set! result (* (modulo (/ i 10) 10) 1))\n        (set! result (* (modulo (/ i 11) 10) 1))\n        (set! result (* (modulo (/ i 12) 10) 1))\n        (set! result (* (modulo (/ i 13) 10) 1))\n        (set! result (* (modulo (/ i 14) 10) 1))\n        (set! result (* (modulo (/ i 15) 10) 1))\n        (set! result (* (modulo (/ i 16) 10) 1))\n        (set! result (* (modulo (/ i 17) 10) 1))\n        (set! result (* (modulo (/ i 18) 10) 1))\n        (set! result (* (modulo (/ i 19) 10) 1))\n        (set! result (* (modulo (/ i 20) 10) 1))\n        (set! result (* (modulo (/ i 21) 10) 1))\n        (set! result (* (modulo (/ i 22) 10) 1))\n        (set! result (* (modulo (/ i 23) 10) 1))\n        (set! result (* (modulo (/ i 24) 10) 1))\n        (set! result (* (modulo (/ i 25) 10) 1))\n        (set! result (* (modulo (/ i 26) 10) 1))\n        (set! result (* (modulo (/ i 27)",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (while (< n 0)\n        (set! result (* result (modulo (/ n 10))))\n        (set! n (- n 1))))\n    result))\n",
    "  (cond\n    ((zero? n) 0)\n    ((even? n) 0)\n    (else\n      (let ((n (abs n))\n            (digits (vector (map (lambda (x) (modulo n x)) (range 1 (truncate n 2)))))\n            (product (vector (map (lambda (x) (quotient n x)) (range 1 (truncate n 2))))))\n        (if (even? (car digits))\n            (cdr digits)\n            (car digits))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (if (odd? n)\n        (do ((i 0 (+ i 1)))\n          ((= i n)\n           (return result)\n           (set! result (* result (read-number i))))\n         (set! result 0)))))\n",
    "  (cond\n    ((zero? n) 0)\n    ((even? n) 0)\n    (else\n      (let ((i (modulo n 2)))\n        (if (zero? i)\n            (let ((d (quotient n 2)))\n              (if (odd? d)\n                  (quotient (remainder n 2) 2)\n                  (quotient n 2)))\n            (if (odd? i)\n                (quotient (remainder n 2) 2)\n                (quotient n 2)))\n        (quotient n 2)))\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! result (* result (+ (modulo (/ i 2) 1) (modulo (/ i 3) 1)\n                                  (modulo (/ i 5) 1) (modulo (/ i 7) 1))))\n          (set! i (+ i 1))))\n      result)))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? (read-number i)) result)))\n      (else result)))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (mul (modulo n 10) (read-int n))]\n    [else (mul (modulo n 10) (read-int n))]))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (quotient n 2)))\n        ((< i 0))\n        ((= (modulo i 2) 1)\n          (set! result (result (* i (quotient i 2))))))\n      (else\n        result)))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (n (- n 1))))\n      (n 2)))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (product (map (odd? n) (range 1 9)))]\n  ))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n 0))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? n) (multiply-odd-digits (quotient n 2))]\n    [else (multiply-odd-digits n)]))\n",
    "  (cond\n    ((zero? n) 0)\n    ((odd? (remainder n 2)) (quotient n 2))\n    (else (product (map odd? (quotient n 2))))))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (odd? (length digits))\n      (reduce (lambda (a b) (* a b)) (first digits) (second digits))\n      0)))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 2)))\n  result)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? n) (product (map odd? n))]\n    [else n]))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")))\n  (let ((i 0))\n    (while (< i n)\n      (if (odd? (modulo (read-number i) 10))\n          (set! result (result (modulo (read-number i) 10)))))\n      (set! i (+ i 1)))\n    result))\n",
    "  (let* ([p (modulo n 10)])\n    (if (zero? p)\n      0\n      (let* ([d (modulo (remainder n 10) 2)])\n        (if (zero? d)\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder (remainder n 10) 2) 2))\n          (+ (modulo (remainder n 10) 2)",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (if (odd? n)\n        (set! result (* (read-int n) result)))\n      (digits (- n 1))))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (if (odd? (remainder n 2))\n        (set! result (result (remainder n 2)) (remainder n 2))\n        (set! n (- n 1))))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (let ((i 0))\n        (while (< i n)\n          (if (odd? (modulo n i))\n            (set! result (result (modulo n i) (modulo n (add1 i))))\n            (set! i (add1 i))))\n        result)))\n  (digits)))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (odd? (length digits))\n      (let* ([digits (filter odd? digits)])\n        (reduce (lambda (a b) (* a b)) digits))\n      0)))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((digits (vector (map (lambda (x) (modulo x 2)) (vector n))))\n        (let ((result 0))\n          (for-each (lambda (x) (set! result (* x (vector-ref digits x))))\n               (vector-ref digits 0)))\n        result))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))])\n)\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< n i))\n        (set! result (* i (read-int i))))\n      (else\n        result)))\n)\n",
    "  (let* ([i (modulo n 10)])\n    (if (zero? i)\n      0\n      (let* ([d (modulo (remainder n 10) 2)])\n        (if (zero? d)\n          (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2))\n          (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2)\n            (+ (modulo (remainder n 10) 2) (modulo (remainder n 10) 2)))))\n      ))\n  )\n)\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (if (odd? n)\n        (let ((i 0))\n          (while (< i n)\n            (set! result (* result (+ (read-number i) 1)))\n            (set! i (+ i 1)))\n          result)\n        (else\n          result)))\n  result)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (set! result (* digit result))\n            (set! n (- n 1))))\n      (set! result 1)))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (if (odd? (remainder n 2))\n        (set! result (result (remainder n 2)) (remainder n 2))\n        (set! n (- n 1))))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"digits: n must be a positive integer\")\n      (while (< n 0)\n        (set! result (* result (modulo n 2)))\n        (set! n (- n 1)))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (n (- n 1))))\n      (n 1)))\n)\n",
    "  (cond\n    [(zero? n) 0]\n    [(even? n) 0]\n    [(odd? n) (mul (odd? (modulo n 2)) (digits (remainder n 2))))]))\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i (modulo n 10)))\n        ((= i 0) (set! result (result (* i (read-number i))))))\n      (else\n        (set! result 1))))\n)\n",
    "  (let* ([digits (string->list n)])\n    (let ([odd (filter odd digits)])\n      (if odd\n        (prod odd)\n        0))))\n",
    "  (if (zero? n)\n    0\n    (let ((i (1-n)))\n      (if (odd? i)\n        (let ((j (quotient i 10)))\n          (if (odd? j)\n            (+ (digits (remainder i 10)) j)\n            (digits (quotient i 10))))))))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (even? (length digits))\n      0\n      (reduce (lambda (a b) (* a b))\n        (first digits)\n        (second digits)\n        (third digits)\n        (fourth digits)\n        (fifth digits)\n        (sixth digits)\n        (seventh digits)\n        (eighth digits)\n        (ninth digits)\n        (tenth digits))))))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (if (odd? (modulo n 2))\n        (set! result (* result (modulo n 2)))\n        (set! n (- n 1)))\n      )\n    (return result)\n    )\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1)))))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo (/ n 10))))\n        (set! result (* result digit))\n        (set! n (- n 10))))\n    result))\n\n;; Given a positive integer n, return the product of the even digits.\n;; Return 0 if all digits are odd.\n;; For example:\n;; >>> (digits 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 0",
    "  (if (zero? n)\n    0\n    (let ((result 0))\n      (while (< n 0)\n        (set! result (* result (+ (car n) (cdr n))))\n        (set! n (- n 1)))))\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo (/ n 10))))\n        (set! result (* result digit))\n        (set! n (- n 10)))\n      )\n    )\n    result\n  )\n)\n",
    "  (if (zero? n)\n    0\n    (let ((i (quotient n 2)))\n      (if (odd? i)\n        (let ((j (remainder n 2)))\n          (if (odd? j)\n            (+ (digits (quotient j 2)) (digits (remainder j 2))))\n          (digits (quotient i 2)))\n        (digits (remainder i 2))))))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (return 0)\n      (let ((i 0))\n        (while (< i n)\n          (set! i (i + 1))\n          (if (odd? (modulo n i))\n            (set! result (result * i))\n            (else\n              (return result))))))))\n",
    "  (let* ([digits (string->list (string->number n))]\n         [result 0])\n    (for ([i (string->list digits)])\n      [if (odd? (string->number (car i)))\n        [result (result + (string->number (car i)))]])\n    result))\n",
    "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 2)) (quotient n 2)]\n    [else (product (map odd? (quotient n 2)))]))\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo (/ n 10))))\n        (set! result (* result digit))\n        (set! n (- n 10)))\n      )\n    )\n  )\n)\n",
    "  (let ((result 0))\n    (if (odd? n)\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (read-number i) result)))\n      (else\n        result))\n    result))\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([digits (first digits)])\n        (if (odd? (string-length digits))\n          (string-join \"\")\n          (string-join (first digits) (rest digits)))))\n  )\n)\n",
    "  (let ((result 0))\n    (while (< n 0)\n      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n          (set! result (* digit result))\n          (set! n (- n 1))))\n      (set! result 1))\n    result))\n",
    "  (let ((result 0))\n    (if (< n 0)\n      (error \"negative number\")\n      (do ((i 0 (+ i 1)))\n        ((< i n))\n        (set! result (* (odd? i) result)))\n      (else result)))\n)\n",
    "  (let* ([digits (string-split \"123456789\" n)])\n    (if (empty? digits)\n      0\n      (let* ([digits (string-split \"123456789\" (car digits))])\n        (if (odd? (car digits))\n          (car digits)\n          0))))\n"
  ],
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ]
}