{
  "name": "HumanEval_2_truncate_number",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 3.5)\n;; 0.5\n(define (truncate_number number)\n",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-equal? (candidate 3.5) 0.5)\n    (check-equal? (candidate 1.25) 0.25)\n    (check-equal? (candidate 123.0) 0.0)\n))\n\n(test-humaneval)",
  "completions": [
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (negative? integer-part)\n      (negate (truncate_number (- integer-part) decimals))\n      decimals)))\n\n;; Given a positive integer, return the number of digits in it.\n;; >>> (digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (zero? decimals)\n      integer-part\n      (truncate_number (number - decimals))))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (negative? number)\n        (let ((sign (if (negative? integer-part) -1.0 else 1.0)))\n          (let ((decimal-part (sign * decimals)))\n            (if (negative? integer-part)\n              (let ((negative-decimal-part (sign * decimal-part)))\n                (negative-decimal-part))\n              (sign * decimal-part))))\n        (sign * decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part (- number integer-part))\n        decimals))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and a\n;; remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let* ([integer (floor number)]\n         [decimals (number - integer)])\n    decimals))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (negative? integer-part)\n      (negate (truncate_number (- integer-part) (truncate_number decimals)))\n      (truncate_number decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals)))))\n\n;; Given a positive integer, it can be decomposed into a power of two\n;; and a remainder.\n;; Return the remainder.\n;; >>> (truncate_power_of_two 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (< decimal-part 0.5)\n        (sub1 decimal-part)\n        decimal-part))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the power of two part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (< decimal-part 0.0)\n        (error \"decimal part of number must be positive\")\n      (else\n        decimal-part))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (remaining part always smaller than given number).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (negative? integer-part)\n        (let ((decimals (decimals - 1)))\n          (if (negative? decimals)\n            (neg decimals)\n            decimals))\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 3)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 16)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (< decimals 0.0)\n      (+ integer-part decimals)\n      integer-part)))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, return the number of digits in it.\n;; >>> (digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (integer-digits 5)\n;; 2",
    "  (let* ([integer (floor number)]\n         [decimals (number - integer)])\n    decimals))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits_in_integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let* ([integer (floor number)]\n         [decimal (number - integer)])\n    decimal))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (integer-digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the remainder.\n;; >>> (remainder-of-power-of-two 2)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? number)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; a base-10 integer part and a base-2 integer part.\n;; Return the base-2 integer part of the number.\n;; >>> (truncate_number 3)\n;; 1",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than given number).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (negative? number)\n        (let ((sign (if (zero? decimals) 1 -1)))\n          (return (- sign) decimals))\n        (return decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a base-2 exponent (largest integer smaller than given number) and\n;; a base-2 mantissa (leftover part always smaller than 1).\n;; Return the mantissa of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let* ([integer (floor number)]\n         [decimals (number - integer)])\n    decimals))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let* ([integer (floor number)]\n         [decimals (mod number number)])\n    decimals))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals)))))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 2).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into a list of\n;; digits (each digit is a positive integer smaller than given number).\n;; Return the list of digits.\n;; >>> (digits 5)\n;; [5]",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (< decimal-part 0.0)\n        (error \"decimal part must be positive\")\n      decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into a list of\n;; integers, where the first element is the largest integer smaller\n/// than the given number, and the last element is the remainder.\n;; Return the first element of the list.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? number)\n        (negate (truncate_number (- number integer-part)))\n        (truncate_number (number integer-part decimals))))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (zero? decimals)\n      integer-part\n      (cons integer-part (truncate_number (- decimals)))))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (negative? integer-part)\n      (neg decimals)\n      decimals)))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the power of two part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let* ([integer (floor number)]\n         [decimals (mod number number)])\n    decimals))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and power of 2 part (leftover part always smaller than 2).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (< decimal-part 0.0)\n        (error \"decimal part of number must be positive\")\n      decimal-part)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((i (floor number)))\n    (let ((d (number - i)))\n      (if (< d 0.0)\n        (error \"truncate_number: number must be positive\")\n      (else\n        d))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits_in_integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (negative? integer-part)\n        (cons -1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the remainder.\n;; >>> (truncate_power_of_two 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part (truncate_number (- decimals 1.0)))\n        integer-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals)))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 10)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"Truncate_number: number is not a positive integer\" number)\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 3)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a base-10 integer part and a base-2 integer part.\n;; Return the base-2 integer part of the number.\n;; >>> (truncate_number 5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and power of 2 part (leftover part always smaller than 2).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"Truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (negate decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part (truncate-decimals number integer-part decimals)))\n      decimals)))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 2).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 2)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; remainder (leftover part always smaller than given number).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (zero? decimals)\n        (integer-part)\n        (truncate_number (integer-part + decimals))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-in-integer-part 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and decimal part (remaining part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (let ((decimal-part (floor decimals)))\n        (if (< decimal-part 0.0)\n          (error \"decimal part must be positive\")\n        (number (- integer-part (- decimal-part))))))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimal part of the number must be positive\")\n      (+ integer-part (- decimals 1.0)))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than given number).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; a power of 2 and a remainder.\n;; Return the power of 2.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (< decimals 0.0)\n        (+ decimals 0.0)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and power of 2 (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (cons decimals (cons 0)))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the power of two part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? number)\n        (negate (truncate_number (- number integer-part)))))\n    decimals))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 16)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (let ((decimal-part (floor decimals)))\n        (if (< decimal-part 0.0)\n          (error \"decimal part must be positive\")\n        (number-part decimal-part))))))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 16)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part (- number integer-part))\n        decimals))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let* ([integer (floor number)]\n         [decimals (mod number integer)])\n    decimals))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits_in_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimal part (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 3)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be a positive number\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than given number).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part))))\n    (if (negative? integer-part)\n      (negate (truncate_number (- integer-part) (truncate_number decimals)))\n      (truncate_number decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (zero? decimals)\n        integer-part\n        (cons integer-part (truncate_number (- number integer-part) decimals))))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (< decimal-part 0.0)\n        (error \"decimal part must be positive\")\n      decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; and power of two part (leftover part always smaller than 1).\n;; Return the power of two part of the number.\n;; >>> (truncate_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number is not a positive integer\")\n      (+ integer-part (- decimals 1.0)))))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals)))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (< decimal-part 0.0)\n        (error \"decimal part must be positive\")\n      decimal-part))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the power of two.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part (- number integer-part))\n        decimals))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((int-part (floor number)))\n    (let ((decimal-part (number - int-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; decimals (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n;; >>> (truncate_number 3)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 16)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (+ integer-part decimals)\n        integer-part))))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((i (floor number)))\n    (let ((d (number - i)))\n      (if (< d 0.0)\n        (error \"truncate_number: number must be positive\")\n      (else\n        (return (number - d)))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits_in_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimal part of number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 (leftover part always power of 2).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_power_of_two 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 10)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (integer-digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (+ integer-part (- decimals 1))\n        integer-part))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? number)\n        (negate (truncate_number (- number integer-part)))\n        (truncate_number (number integer-part decimals))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (let ((decimal-part (floor decimals)))\n        (if (< decimal-part 0.0)\n          (error \"decimal part must be positive\")\n        (+ decimal-part integer-part))))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_int 3)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals)))))\n)\n\n;; Given a positive integer, it can be decomposed into a list of\n;; digits.\n;; Return the list of digits.\n;; >>> (digits 123)\n;; '(1 2 3)'",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals)))))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, return the smallest integer that is greater\n;; than the given integer and is divisible by 3.\n;; >>> (divisible_by_3 3)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (negate decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 5)\n;; 5",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (< decimals 0.0)\n        (error \"Truncate_number: number must be positive\")\n      (+ (truncate decimals) integer-part))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be positive\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive floating point number, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and decimals\n;; (leftover part always smaller than 1).\n;; Return the integer part of the number.\n;; >>> (truncate_number 3.5)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"decimals must be a positive number\")\n      (+ integer-part decimals))))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; and integer part (largest integer smaller than given number) and\n;; power of 2 part (leftover part always smaller than 1).\n;; Return the power of 2 part of the number.\n;; >>> (truncate_number 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"truncate_number: number is not a positive integer\")\n        (let ((decimal-part (number integer-part decimals)))\n          (if (< decimal-part 0.0)\n            (error \"truncate_number: number is not a positive integer\")\n            (number decimal-part)))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (number_of_digits 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n",
    "  (let* ([integer (floor number)]\n         [decimals (mod number number)])\n    decimals))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than given number).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((int-part (floor number)))\n    (let ((decimals (modulo number int-part)))\n      (if (negative? number)\n        (negate decimals)\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and a\n;; remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_int 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (number - integer-part)))\n      (if (zero? decimals)\n        (integer-part)\n        (truncate_number (integer-part + decimals))))))\n\n;; Given a positive integer, return the smallest integer that is greater\n;; than or equal to the given integer.\n;; >>> (ceiling-of-3)\n;; 3",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0)\n        (+ integer-part (- number integer-part))\n        decimals))))\n\n;; Given a positive integer, it can be decomposed into a pair of\n;; positive integers (first one is always smaller than second one)\n;; and a remainder.\n;; Return the remainder.\n;; >>> (truncate_pair 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (neg decimals)\n        decimals))))\n",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (number - integer-part))))\n    decimal-part))\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 3)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimal-part (mod number integer-part)))\n      (if (negative? integer-part)\n        (neg decimal-part)\n        decimal-part)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a base-10 integer part and a base-2 integer part.\n;; Return the base-2 integer part of the number.\n;; >>> (base-2-integer-part 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; an integer part (largest integer smaller than given number) and\n;; a remainder (leftover part always smaller than 1).\n;; Return the remainder of the number.\n;; >>> (truncate_number 5)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (sub1 decimals)\n        decimals)))\n)\n\n;; Given a positive integer, it can be decomposed into\n;; a power of two and a remainder.\n;; Return the remainder.\n;; >>> (truncate_number 16)\n;; 0",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (negative? integer-part)\n        (negate (truncate_number (- integer-part decimals)))\n        (truncate_number (- integer-part decimals))))))\n\n;; Given a positive integer, return the number of digits in the integer part.\n;; >>> (digits-of-integer 5)\n;; 2",
    "  (let ((integer-part (floor number)))\n    (let ((decimals (modulo number integer-part)))\n      (if (< decimals 0.0)\n        (error \"Truncate_number: number must be positive\")\n      (+ integer-part decimals)))\n  ))\n\n;; Given a positive integer, return the smallest integer that is greater\n;; than or equal to the given integer.\n;; >>> (ceiling 2)\n;; 2"
  ],
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ]
}