name: HumanEval_132_is_nested
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a string as input which contains\
  \ only square brackets.\n;; The function should return #t if and only if there is\
  \ a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
  \ is nested.\n;; >>> (is_nested \"[[]]\")\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\"\
  )\n;; #f\n;; >>> (is_nested \"[][]\")\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n\
  ;; >>> (is_nested \"[[][]]\")\n;; #t\n;; >>> (is_nested \"[[]][[\")\n;; #t\n(define\
  \ (is_nested string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (+ i 1))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((= string \"\") #t)\n    ((= string \"[]\"\
    ) #f)\n    (else\n      (let ((i (1)))\n        (while (< i (length string))\n\
    \          (if (string-char (string-substring string i i))\n            (if (string-char\
    \ (string-substring string i i - 1))\n              (return #f)\n            \
    \  (else (return #t))))\n            (setq i (i + 1)))\n        (return #f)))\n\
    \  ))\n\n;; Create a function that takes a string as input which contains only\
    \ square brackets.\n;; The function should return #t if and only if there is a\
    \ valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n\
    \      (let ((bracket_count (string-count '([]' string))))\n        (and (>= bracket_count\
    \ 1) (string-count '([]' string) bracket_count))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string=? string \"\") #t)\n    ((string=?\
    \ string \"[]\") #t)\n    (else (is_nested (string (- (string-length string) 1)))\
    \ #t)\n  ))\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n\
    \      (let ((bracket_count (string-count string #\"[\" #\"]\"))))\n        (and\
    \ (>= bracket_count 1) (is_nested (string-replace string #\"[\" #\"]\" \"\")))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket (string-index string 0)))\n        (if (string-substring\
    \ bracket 1 (string-length string))\n            (is_nested (string-substring\
    \ bracket 1 (string-length string)))\n            (is_nested (string-substring\
    \ bracket 1 (string-length string) - 1)))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((bracket_count (string-count string '[')))\n\
    \        (let ((bracket_depth (string-count string '[' ']')))\n          (and\
    \ (>= bracket_count 1) (>= bracket_depth 1)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) < 2)\n    (else\n\
    \      (let ((bracket_count (string-count string '[')))\n        (let ((nested_count\
    \ (string-count string '[' ']')))\n          (and (not (zero? bracket_count))\n\
    \               (not (zero? nested_count))))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (+ i 1))))))))\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket (string-match \"^\\\\[\\\\[*$\" string)))\n        (if (null?\
    \ bracket)\n          #f\n          (let ((substring (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (c", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((bracket_count (string-count string #\"[\" #\"]\"))))\n        (and (>= bracket_count\
    \ 1)\n             (string-length (string-replace string #\"[\" #\"]\" \"\")))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count string '[')))\n\
    \        (let ((nested_count (string-count string '[' '[')))\n          (let ((valid\
    \ (and (not (eq bracket_count 0))\n                          (not (eq nested_count\
    \ 0))))\n                (subseq (string-copy string 0 (string-length string)\
    \ - 1)))\n            (and valid\n               (cond\n                 ((eq\
    \ nested_count 0)\n                   (not (string-length subseq)))\n        \
    \         ((eq bracket_count 0)\n                   (not (string-length subseq)))\n\
    \                 (else\n                   (string-append subseq \"]\"))))))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((i 0))\n        (while (< i string-length)\n          (if (string-ref string\
    \ i)\n            (if (< (string-length string) i)\n              (if (string-ref\
    \ string i)\n                (return #f)\n                (return #t))\n     \
    \         (return #f))\n            (setq i (+ i 1)))\n          (setq i 0)))\n\
    \    (return #t)))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_square_brackets \"[[[]]]\"\
    )\n;; #t\n;; >>> (is_nested_square_brackets \"[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n \
    \       (while (< i string-length)\n          (if (string-ref string i)\n    \
    \        (if (string-ref string (1+i))\n              (return #t)\n          \
    \    (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i 0))\n   \
    \     (while (< i string-length)\n          (if (string-ref string i)\n      \
    \      (if (string-ref string (1+ i))\n              (return #t)\n           \
    \   (return #f))\n            (i (1+ i)))\n          (i (1+ i)))))))\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((i (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) == 0)\n    ((string-length string)\
    \ == 1)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    ((string-length string)\
    \ == 2)\n    (string-contains? \"][\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"]]]\" string)\n\
    \    (string-contains? \"][[\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"][[\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"][[\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"][[\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"][[\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"][[\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"[[\" string)\n    (string-contains? \"]]\" string)\n\
    \    (string-contains? \"][[\" string)\n    (string-contains? \"[[\" string)\n\
    \    (string-contains? \"]]\" string)\n    (string-contains? \"[", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket (string-match \"^\\\\[.*\\\\\
    ]$\" string)))\n        (if (null? bracket)\n          #f\n          (let ((bracket\
    \ (string-match \"^\\\\[.*\\\\]\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n       \
    \     (if (null? bracket)\n              #f\n              (let ((bracket (string-match\
    \ \"^\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n                (if (null? bracket)\n\
    \                  #f\n                  (let ((bracket (string-match \"^\\\\\
    [.*\\\\]$\" string)))\n                    (if (null? bracket)\n             \
    \         #f\n                      (let ((bracket (string-match \"^\\\\[.*\\\\\
    ]\\\\[.*\\\\]$\" string)))\n                        (if (null? bracket)\n    \
    \                      #f\n                          (let ((bracket (string-match\
    \ \"^\\\\[.*\\\\]\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n                     \
    \       (if (null? bracket)\n                              #f\n              \
    \                (let ((bracket (string-match \"^\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n\
    \                                (if (null? bracket)\n                       \
    \           #f\n                                  (let ((bracket (string-match\
    \ \"^\\\\[.*\\\\]$\" string)))\n                                    (if (null?\
    \ bracket)\n                                      #f\n                       \
    \               (let ((bracket (string-match \"^\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n\
    \                                        (if (null? bracket)\n               \
    \                           #f\n                                          (let\
    \ ((bracket (string-match \"^\\\\[.*\\\\]\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n\
    \                                            (if (null? bracket)\n           \
    \                                   #f\n                                     \
    \         (let ((bracket (string-match \"^\\\\[.*\\\\]\\\\[.*\\\\]$\" string)))\n\
    \                                                (if (null? bracket)\n       \
    \                                           #f\n                             \
    \                     (let ((bracket (string-match \"^\\\\[", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((bracket_count (string-count string #\"\
    [\" #\"]\")))\n        (and (>= bracket_count 1)\n             (string-length\
    \ (string-replace string #\"[\" #\"]\" \"\"))\n             (string-length (string-replace\
    \ string #\"[\" #\"]\" \"\")))))\n  ))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((nested (string-split\
    \ string \"]\")))\n        (and (string-length (first nested))\n             (string-length\
    \ (second nested))\n             (is_nested (cdr (first nested)))\n          \
    \   (is_nested (car (second nested)))))))\n\n;; Create a function that takes a\
    \ string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) < 3)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((bracket_count (string-count\
    \ \"]\")))\n        (and (>= bracket_count 1)\n             (string-length (string-replace/all\
    \ string \"]\" \"\") - bracket_count))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) < 2)\n    (else\n      (let ((bracket_count (string-count\
    \ string #\"[\" #\"]\"))))\n        (and (>= bracket_count 1)\n             (string-length\
    \ (string-replace string #\"[\" #\"]\" \"\")))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((bracket\
    \ (string-index string 0)))\n        (let ((nested (string-index string 1)))\n\
    \          (cond\n            ((string-index string (string-length string) - 1)\
    \ == bracket)\n            (else\n              (let ((nested (string-index string\
    \ (string-index string (string-length string) - 1) - 1)))\n                (cond\n\
    \                  ((string-index string (string-length string) - 2) == nested)\n\
    \                  (else\n                    (let ((nested (string-index string\
    \ (string-index string (string-length string) - 2) - 1)))\n                  \
    \    (cond\n                        ((string-index string (string-length string)\
    \ - 3) == nested)\n                        (else\n                          (let\
    \ ((nested (string-index string (string-index string (string-length string) -\
    \ 3) - 1)))\n                            (cond\n                             \
    \ ((string-index string (string-length string) - 4) == nested)\n             \
    \                 (else\n                                (let ((nested (string-index\
    \ string (string-index string (string-length string) - 4) - 1)))\n           \
    \                       (cond\n                                    ((string-index\
    \ string (string-length string) - 5) == nested)\n                            \
    \        (else\n                                      (let ((nested (string-index\
    \ string (string-index string (string-length string) - 5) - 1)))\n           \
    \                             (cond\n                                        \
    \  ((string-index string (string-length string) - 6) == nested)\n            \
    \                              (else\n                                       \
    \     (let ((nested (string-index string (string-index string (string-length string)\
    \ - 6) - 1)))\n                                              (cond\n         \
    \                                       ((string-index string (string-length string)\
    \ - 7) == nested)\n                                                (else\n   \
    \                                               (let ((nested (string-index string\
    \ (string-index string (string-length string) - 7) - 1)))\n                  \
    \                                  (cond\n                                   \
    \                   ((string-index string (string-length string) - 8) == nested",
  "  (cond\n    ((string-length string) == 0)\n    ((string-length string) == 1)\n\
    \    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket (string-index string 0)))\n \
    \       (cond\n          ((string-length string) == 1)\n          (else\n    \
    \        (let ((substring (string-substring string 1)))\n              (cond\n\
    \                ((string-length substring) == 1)\n                (else\n   \
    \               (let ((subsubstring (string-substring substring 1)))\n       \
    \             (cond\n                      ((string-length substring) == 2)\n\
    \                      (else\n                        (let ((subsubsubstring (string-substring\
    \ substring 2)))\n                          (cond\n                          \
    \  ((string-length substring) == 3)\n                            (else\n     \
    \                         (let ((subsubsubsubstring (string-substring substring\
    \ 3)))\n                                (cond\n                              \
    \    ((string-length substring) == 4)\n                                  (else\n\
    \                                    (let ((subsubsubsubsubstring (string-substring\
    \ substring 4)))\n                                      (cond\n              \
    \                          ((string-length substring) == 5)\n                \
    \                        (else\n                                          (let\
    \ ((subsubsubsubsubsubstring (string-substring substring 5)))\n              \
    \                              (cond\n                                       \
    \       ((string-length substring) == 6)\n                                   \
    \           (else\n                                                (let ((subsubsubsubsubsubsubstring\
    \ (string-substring substring 6)))\n                                         \
    \         (cond\n                                                    ((string-length\
    \ substring) == 7)\n                                                    (else\n\
    \                                                      (let ((subsubsubsubsubsubsubstring\
    \ (string-substring substring 7)))\n                                         \
    \               (cond\n                                                      \
    \    ((string-length substring) == 8)\n                                      \
    \                    (else\n                                                 \
    \           (let ((subsubsubsubsubsubsubstring (string-substring substring 8)))\n\
    \                                                              (cond\n       \
    \                                                         ((string-length substring)\
    \ == 9)\n                                                                (else\n\
    \                                                                  (let ((subsubsubsubsubsubsubsubstring\
    \ (string-sub", "  (cond\n    ((string-length string) < 2)\n    (else\n      (let\
    \ ((i (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_with_count \"[[]]\")\n;; #t\n;; >>> (is_nested_with_count\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_with_count \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_with_count \"[]\")\n;; #f\n;; >>> (is_nested_with_count \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_with_count \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (and (string-char\
    \ string i) #\\[)\n          (if (string-char string (1+i))\n            (return\
    \ #t)\n          (i (1+i))))))))\n\n;; Create a function that takes a string as\
    \ input which contains only square brackets.\n;; The function should return #t\
    \ if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ string #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"\
    ]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n\
    \    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\"\
    \ #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (+ i 1)))))))\n)\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((bracket_count (string-count\
    \ string '[')))\n        (let ((nested_bracket_count (string-count string '['\
    \ '[')))\n          (let ((nested_bracket_count_2 (string-count string '[' '['\
    \ '[')))\n            (let ((nested_bracket_count_3 (string-count string '[' '['\
    \ '[' '['))))\n              (let ((nested_bracket_count_4 (string-count string\
    \ '[' '[' '[' '[' '['))))\n                (let ((nested_bracket_count_5 (string-count\
    \ string '[' '[' '[' '[' '[' '['))))\n                  (let ((nested_bracket_count_6\
    \ (string-count string '[' '[' '[' '[' '[' '[' '['))))\n                    (let\
    \ ((nested_bracket_count_7 (string-count string '[' '[' '[' '[' '[' '[' '[' '['))))\n\
    \                      (let ((nested_bracket_count_8 (string-count string '['\
    \ '[' '[' '[' '[' '[' '[' '[' '['))))\n                        (let ((nested_bracket_count_9\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n         \
    \                 (let ((nested_bracket_count_10 (string-count string '[' '['\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                            (let ((nested_bracket_count_11\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n \
    \                             (let ((nested_bracket_count_12 (string-count string\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                  \
    \              (let ((nested_bracket_count_13 (string-count string '[' '[' '['\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                          \
    \        (let ((nested_br", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((nested_brackets (string-split string \"]\")))\n        (and\n  \
    \        (string-length nested_brackets)\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\") 1)\n          (string-length (string-join nested_brackets \"]\") 2)\n\
    \          (string-length (string-join nested_brackets \"]\") 3)\n          (string-length\
    \ (string-join nested_brackets \"]\") 4)\n          (string-length (string-join\
    \ nested_brackets \"]\") 5)\n          (string-length (string-join nested_brackets\
    \ \"]\") 6)\n          (string-length (string-join nested_brackets \"]\") 7)\n\
    \          (string-length (string-join nested_brackets \"]\") 8)\n          (string-length\
    \ (string-join nested_brackets \"]\") 9)\n          (string-length (string-join\
    \ nested_brackets \"]\") 10)\n          (string-length (string-join nested_brackets\
    \ \"]\") 11)\n          (string-length (string-join nested_brackets \"]\") 12)\n\
    \          (string-length (string-join nested_brackets \"]\") 13)\n          (string-length\
    \ (string-join nested_brackets \"]\") 14)\n          (string-length (string-join\
    \ nested_brackets \"]\") 15)\n          (string-length (string-join nested_brackets\
    \ \"]\") 16)\n          (string-length (string-join nested_brackets \"]\") 17)\n\
    \          (string-length (string-join nested_brackets \"]\") 18)\n          (string-length\
    \ (string-join nested_brackets \"]\") 19)\n          (string-length (string-join\
    \ nested_brackets \"]\") 20)\n          (string-length (string-join nested_brackets\
    \ \"]\") 21)\n          (string-length (string-join nested_brackets \"]\") 22)\n\
    \          (string-length (string-join nested_brackets \"]\") 23)\n          (string-length\
    \ (", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((bracket_count\
    \ (string-count (string-replace string \"]\"))))\n        (and (>= (string-length\
    \ string) 2)\n             (>= bracket_count 1)\n             (not (string-index\
    \ (string-replace string \"]\") \"]\")))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (and (string-char string i) (string-char/ci\
    \ string i))\n          (setf i (+ i 1)))\n        (if (string-char/ci string\
    \ i)\n          (return #t)\n          (else\n            (return #f)))))))\n\n\
    ;; Create a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is nested.\n;; >>>\
    \ (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>>\
    \ (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;;\
    \ >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket_count (string-count string '[')))\n \
    \       (let ((bracket_nested (string-count string '[' '[')))\n          (let\
    \ ((bracket_nested_count (string-count string '[' '[' '[')))\n            (let\
    \ ((bracket_nested_count_2 (string-count string '[' '[' '[' '['))))\n        \
    \      (let ((bracket_nested_count_3 (string-count string '[' '[' '[' '[' '['))))\n\
    \                (let ((bracket_nested_count_4 (string-count string '[' '[' '['\
    \ '[' '[' '['))))\n                  (let ((bracket_nested_count_5 (string-count\
    \ string '[' '[' '[' '[' '[' '[' '['))))\n                    (let ((bracket_nested_count_6\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '['))))\n                 \
    \     (let ((bracket_nested_count_7 (string-count string '[' '[' '[' '[' '[' '['\
    \ '[' '[' '['))))\n                        (let ((bracket_nested_count_8 (string-count\
    \ string '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                       \
    \   (let ((bracket_nested_count_9 (string-count string '[' '[' '[' '[' '[' '['\
    \ '[' '[' '[' '[' '['))))\n                            (let ((bracket_nested_count_10\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n     \
    \                         (let ((bracket_nested_count_11 (string-count string\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                          \
    \      (let ((bracket_nested_count_12 (string-count string '[' '[' '[' '[' '['\
    \ '[' '[' '[' '[' '[' '['))))\n                                  (let ((bracket_nested_count_13\
    \ (string-count string '[' '[' '['", "  (cond\n    ((string-length string) ==\
    \ 0)\n    (else\n      (let ((bracket_count (string-count string '[')))\n    \
    \    (let ((nested_bracket_count (string-count string '[' '[')))\n          (let\
    \ ((result (and (not (eq bracket_count 0))\n                          (not (eq\
    \ nested_bracket_count 0))))\n                (string-set! string (string-append\
    \ string \"]\"))))\n          (string-set! string (string-append string \"]\"\
    )))))))\n\n;; Create a function that takes a string as input which contains only\
    \ square brackets.\n;; The function should return #t if and only if there is a\
    \ valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket_count (string-count \"]\")))\n        (cond\n          ((=\
    \ bracket_count 0) #t)\n          (else\n            (let ((nested_bracket_count\
    \ (string-count \"][\")))\n              (cond\n                ((= nested_bracket_count\
    \ 0) #t)\n                (else\n                  (let ((nested_bracket_count\
    \ (string-count \"][\")))\n                    (cond\n                      ((=\
    \ nested_bracket_count 0) #t)\n                      (else\n                 \
    \       (let ((nested_bracket_count (string-count \"][\")))\n                \
    \          (cond\n                            ((= nested_bracket_count 0) #t)\n\
    \                            (else\n                              (let ((nested_bracket_count\
    \ (string-count \"][\")))\n                                (cond\n           \
    \                       ((= nested_bracket_count 0) #t)\n                    \
    \              (else\n                                    (let ((nested_bracket_count\
    \ (string-count \"][\")))\n                                      (cond\n     \
    \                                   ((= nested_bracket_count 0) #t)\n        \
    \                                (else\n                                     \
    \     (let ((nested_bracket_count (string-count \"][\")))\n                  \
    \                          (cond\n                                           \
    \   ((= nested_bracket_count 0) #t)\n                                        \
    \      (else\n                                                (let ((nested_bracket_count\
    \ (string-count \"][\")))\n                                                  (cond\n\
    \                                                   ((= nested_bracket_count 0)\
    \ #t)\n                                                   (else\n            \
    \                                         (let ((nested_bracket_count (string-count\
    \ \"][\")))\n                                                       (cond\n  \
    \                                                       ((= nested_bracket_count\
    \ 0) #t)\n                                                         (else\n   \
    \                                                        (let ((nested_bracket_count\
    \ (string-count \"][\")))\n                                                  \
    \            (cond\n                                                         \
    \       ((= nested_bracket_count 0", "  (cond\n    ((string-length string) ==\
    \ 0)\n    (else\n      (let ((bracket_count (string-count \"]\")))\n        (and\
    \ (>= (string-length string) bracket_count)\n             (string-contains string\
    \ \"]\")\n             (string-contains string \"[\")\n             (is_nested\
    \ (string-replace string \"]\" \"]\")))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((result (string-match\
    \ (string-join \"()\" string) \"()\"))))\n      (if result\n        (is_nested\
    \ (string-replace string \"()\" \"\"))\n        (is_nested (string-replace string\
    \ \"()\" \"()\")))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((nested_brackets (string-split string \"]\")))\n\
    \        (and\n          (string-length nested_brackets)\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\"))\n          (string-length (string-join nested_brackets \"]\"))\n   \
    \       (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\"))\n          (string-length (string-join nested_brackets \"]\"))\n   \
    \       (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\"))\n          (string-length (string-join nested_brackets \"]\"))\n   \
    \       (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\"))\n          (string-length (string-join nested_brackets \"]\"))\n   \
    \       (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          (string-length (string-join nested_brackets\
    \ \"]\"))\n          (string-length (string-join nested_brackets \"]\"))\n   \
    \       (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\"))\n          (string-length (string-join\
    \ nested_brackets \"]\"))\n          ", "  (cond\n    ((string-length string)\
    \ == 0)\n    ((string-length string) == 1)\n    (string-contains? \"]\" string)\n\
    \    (string-contains? \"[\" string)\n    (is_nested (string-append string \"\
    ]\"))\n    (is_nested (string-append string \"[\"))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (< (string-length string)\
    \ i)\n              (if (string-ref string (sub1 i))\n                (return\
    \ #t)\n                (else (return #f)))\n              (else (return #f)))\n\
    \            (else (return #f)))\n          (setq i (add1 i)))\n        (return\
    \ #f)))\n  )\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i string-length)\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((bracket (string-index string 0)))\n        (if (string-length (string-substring\
    \ string 0 (string-index string bracket) - 1))\n          (is_nested (string-substring\
    \ string 0 (string-index string bracket) - 1))\n          (else\n            (is_nested\
    \ (string-substring string 0 (string-index string bracket) - 1)))))))\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f",
  "  (cond\n    ((string-length string) == 0)\n    ((string-length string) == 1)\n\
    \    (else\n      (let ((bracket (string-index string 0)))\n        (if (string-substring\
    \ bracket 2)\n            (is_nested (string-substring bracket 2))\n         \
    \   (is_nested (string-substring bracket 1)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (and (string-ref string i) #\"[\" (string-length\
    \ string))\n          (if (string-ref string (1+i))\n            (return #t)\n\
    \            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>>\
    \ (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;;\
    \ >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i 0))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+ i))\n              (return #t)\n              (return #f))\n           \
    \ (setq i (1+ i)))\n          (setq i (1+ i)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count string #\"\
    [\" #\"]\"))))\n        (and (>= bracket_count 1)\n             (string-contains\
    \ string #\"[\" #\"]\"))))\n  #t))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ \"]\")\n    (string-contains? \"]][\")\n    (string-contains? \"]][[\")\n  \
    \  (string-contains? \"]][[][\")\n    (string-contains? \"]][[][[\")\n    (string-contains?\
    \ \"]][[][[][\")\n    (string-contains? \"]][[][[][[\")\n    (string-contains?\
    \ \"]][[][[][[][\")\n    (string-contains? \"]][[][[][[][[][\")\n    (string-contains?\
    \ \"]][[][[][[][[][[][\")\n    (string-contains? \"]][[][[][[][[][[][[][\")\n\
    \    (string-contains? \"]][[][[][[][[][[][[][[][\")\n    (string-contains? \"\
    ]][[][[][[][[][[][[][[][[][\")\n    (string-contains? \"]][[][[][[][[][[][[][[][[][[][\"\
    )\n    (string-contains? \"]][[][[][[][[][[][[][[][[][[][[][\")\n    (string-contains?\
    \ \"]][[][[][[][[][[][[][[][[][[][[][[][\")\n    (string-contains? \"]][[][[][[][[][[][[][[][[][[][[][[][[][\"\
    )\n    (string-contains? \"]][[][[][[][[][[][[][[][[][[][[][[][[][[][\")\n   \
    \ (string-contains? \"]][[][[][[][[][[][[][[][[][[][[][[][[][[][[][\")\n    (string-contains?\
    \ \"]][[][[][[][[][[][[][[][[][[][[][[][[][[][[][[][", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count string #\"\
    [\" #\"]\")))\n        (and (not (zero? bracket_count))\n             (not (zero?\
    \ (string-count string #\"[\"))))\n        (not (zero? (string-count string #\"\
    ]\"))))\n      #t))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ string #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"\
    ]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n\
    \    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\"\
    \ #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #", "  (cond\n    ((string=? string \"\"\
    ) #t)\n    ((string=? string \"[]\") #t)\n    (else (\n      (string=? string\
    \ \"[]\")\n      (string=? string \"[[][]\")\n      (string=? string \"[[][[][]\"\
    )\n      (string=? string \"[[[][[][[][]\")\n      (string=? string \"[[[][[][[][[][]\"\
    )\n      (string=? string \"[[[][[][[][[][[][]\")\n      (string=? string \"[[[][[][[][[][[][[][]\"\
    )\n      (string=? string \"[[[][[][[][[][[][[][[][]\")\n      (string=? string\
    \ \"[[[][[][[][[][[][[][[][[][]\")\n      (string=? string \"[[[][[][[][[][[][[][[][[][[][]\"\
    )\n      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][]\")\n      (string=?\
    \ string \"[[[][[][[][[][[][[][[][[][[][[][[][]\")\n      (string=? string \"\
    [[[][[][[][[][[][[][[][[][[][[][[][[][]\")\n      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][[][[][[][]\"\
    )\n      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][[][[][[][[][]\")\n\
    \      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][[][[][[][[][[][]\")\n\
    \      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][[][[][[][[][[][[][]\"\
    )\n      (string=? string \"[[[][[][[][[][[][[][[][[][[][[][[][[][[][[][[", " \
    \ (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n\
    \        (while (< i string-length)\n          (if (string-ref string i)\n   \
    \         (if (string-ref string (sub1 i))\n              (return #t)\n      \
    \        (else\n                (setq i (add1 i)))))\n          (setq i (add1\
    \ i)))))))\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>>\
    \ (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;;\
    \ >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ == 0)\n    ((string-length string) == 1)\n    (string-contains? \"]\" string)\n\
    \    (string-contains? \"[\" string)\n    (is_nested (cdr string))\n    (is_nested\
    \ (car string))\n    (else #f)\n  )\n)\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i 0))\n        (while (< i string-length)\n          (if (string-ref\
    \ string i)\n            (if (< (string-length string) i)\n              (if (string-ref\
    \ string (1+ i))\n                (return #t)\n                (return #f))\n\
    \              (return #f))\n            (i (1+ i)))\n          (i (1+ i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested \"[[]]\")\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested \"[][]\")\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n\
    ;; >>> (is_nested \"[[][]]\")\n;; #t\n;; >>> (is_nested \"[[]][[\")\n;; #t", " \
    \ (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n\
    \        (while (< i (string-length string))\n          (if (string-ref string\
    \ i)\n            (if (string-ref string (1+i))\n              (return #t)\n \
    \             (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string=? string \"\") #t)\n    ((string=?\
    \ string \"[]\") #f)\n    (else\n      (let ((i (string-index string \"]\")))\n\
    \        (cond\n          ((i= 0) #t)\n          ((i> 0)\n            (let ((j\
    \ (string-index string \"[\")))\n              (cond\n                ((j= 0)\
    \ #t)\n                ((j> 0) #f)\n                (else #t))))))))))\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is nested.\n;; >>>\
    \ (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? \"]\" string)\n    (string-contains? \"\
    [\" string)\n    (is_nested (cdr string))\n    (is_nested (car string))\n    (else\
    \ #f)\n  )\n)\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((= string \"\") #t)\n    (else\n      (let\
    \ ((brackets (string-split string \"]\")))\n        (cond\n          ((= brackets\
    \ 1) #t)\n          (else\n            (let ((bracket_count (count brackets)))\n\
    \              (cond\n                ((= bracket_count 0) #t)\n             \
    \   (else\n                  (let ((bracket_nested (string-split brackets \"[\"\
    )))\n                    (cond\n                      ((= bracket_nested 1) #t)\n\
    \                      (else\n                        (let ((bracket_nested_count\
    \ (count bracket_nested)))\n                          (cond\n                \
    \            ((= bracket_nested_count 0) #t)\n                            (else\n\
    \                              (let ((bracket_nested_count_2 (count bracket_nested_count)))\n\
    \                                (cond\n                                  ((=\
    \ bracket_nested_count_2 0) #t)\n                                  (else\n   \
    \                                 (let ((bracket_nested_count_3 (count bracket_nested_count_2)))\n\
    \                                      (cond\n                               \
    \         ((= bracket_nested_count_3 0) #t)\n                                \
    \        (else\n                                          (let ((bracket_nested_count_4\
    \ (count bracket_nested_count_3)))\n                                         \
    \   (cond\n                                              ((= bracket_nested_count_4\
    \ 0) #t)\n                                              (else\n              \
    \                                  (let ((bracket_nested_count_5 (count bracket_nested_count_4)))\n\
    \                                                  (cond\n                   \
    \                                 ((= bracket_nested_count_5 0) #t)\n        \
    \                                            (else\n                         \
    \                             (let ((bracket_nested_count_6 (count bracket_nested_count_5)))\n\
    \                                                        (cond\n             \
    \                                             ((= bracket_nested_count_6 0) #t)\n\
    \                                                          (else\n           \
    \                                                (let ((bracket_nested_count_7\
    \ (count bracket_nested_count", "  (cond\n    ((string-length string) == 0)\n\
    \    (else\n      (let ((nested-brackets (string-split string \"]\")))\n     \
    \   (and\n          (string-length nested-brackets)\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          (string-length (string-join nested-brackets\
    \ \"]\"))\n          (string-length (string-join nested-brackets \"]\"))\n   \
    \       (string-length (string-join nested-brackets \"]\"))\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          (string-length (string-join nested-brackets\
    \ \"]\"))\n          (string-length (string-join nested-brackets \"]\"))\n   \
    \       (string-length (string-join nested-brackets \"]\"))\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          (string-length (string-join nested-brackets\
    \ \"]\"))\n          (string-length (string-join nested-brackets \"]\"))\n   \
    \       (string-length (string-join nested-brackets \"]\"))\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          (string-length (string-join nested-brackets\
    \ \"]\"))\n          (string-length (string-join nested-brackets \"]\"))\n   \
    \       (string-length (string-join nested-brackets \"]\"))\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          (string-length (string-join nested-brackets\
    \ \"]\"))\n          (string-length (string-join nested-brackets \"]\"))\n   \
    \       (string-length (string-join nested-brackets \"]\"))\n          (string-length\
    \ (string-join nested-brackets \"]\"))\n          (string-length (string-join\
    \ nested-brackets \"]\"))\n          ", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket (string-index string 0)))\n        (if\
    \ (eq? (string-substring bracket (- (string-length string) 1)) \"]\")\n      \
    \    (is_nested (string-substring string 1 bracket)))\n        (else\n       \
    \   (is_nested (string-substring string 1 (string-index string bracket) - 1)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((i (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (+ 1)))))))\n)\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((bracket_count (string-count string '[')))\n        (let ((nested_bracket_count\
    \ (string-count string '[' '[')))\n          (let ((valid_bracket_count (bracket_count\
    \ + nested_bracket_count)))\n            (and (>= valid_bracket_count 1)\n   \
    \              (= valid_bracket_count (bracket_count + nested_bracket_count))))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    ((string-length string)\
    \ == 1)\n    (else\n      (let ((i (string-index string 1)))\n        (cond\n\
    \          ((string-ref string i) == '[' && (string-ref string (1+i)))\n     \
    \     (else\n            (is_nested (substring string i))))))))\n\n;; Create a\
    \ function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (setq i (1+i)))\n          (setq\
    \ i (1+i)))\n        (return #f)))\n  )\n)\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n;; >>> (is_nested \"[[][]]\")\n;;\
    \ #t\n;; >>> (is_nested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ < 2)\n    (else\n      (let ((bracket_count (string-count string '[')))\n  \
    \      (let ((nested_count (string-count string '[' ']')))\n          (cond\n\
    \            ((bracket_count > 1) && (nested_count > 0))\n            (else\n\
    \              #f))))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket (string-index string 0)))\n \
    \       (if (string-substring bracket 2 bracket)\n            (is_nested (string-substring\
    \ bracket 2 bracket))\n            (is_nested (string-substring bracket 2 (string-index\
    \ string bracket -1))))\n          #t\n          (is_nested (string-substring\
    \ bracket 2 (string-index string bracket -1)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket (string-match \"^\\\\[\\\\[.*\\\
    \\]\\\\]\" string)))\n        (if (null? bracket)\n          #f\n          (let\
    \ ((substring (string-substring string (bracket 0) (bracket 1))))\n          \
    \  (if (string-length substring)\n              (is_nested substring)\n      \
    \        #f)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested \"[[]]\")\n;; #t\n;; >>> (is_nested\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested \"[][]\")\n;; #f\n;; >>> (is_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_nested \"[[][]]\")\n;; #t\n;; >>> (is_nested \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) < 3)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((bracket (string-index string 0)))\n        (if (string-substring bracket 2\
    \ bracket)\n            (is_nested (string-substring bracket 2 bracket))\n   \
    \         (is_nested (string-substring bracket 1 bracket)))))))\n\n;; Create a\
    \ function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #t",
  "  (cond\n    ((string-length string) < 2)\n    (else\n      (let ((bracket (string-index\
    \ string 0)))\n        (let ((nested (string-index string 1)))\n          (cond\n\
    \            ((string-index string (string-length string) - 1)\n             \
    \ (string-set! bracket -1)\n              (string-set! nested -1)\n          \
    \    (is_nested string))\n            ((string-index string (string-length string)\
    \ - 1)\n              (string-set! bracket -1)\n              (string-set! nested\
    \ -1)\n              (is_nested string))\n            ((string-index string (string-length\
    \ string) - 1)\n              (string-set! bracket -1)\n              (string-set!\
    \ nested -1)\n              (is_nested string))\n            ((string-index string\
    \ (string-length string) - 1)\n              (string-set! bracket -1)\n      \
    \        (string-set! nested -1)\n              (is_nested string))\n        \
    \    ((string-index string (string-length string) - 1)\n              (string-set!\
    \ bracket -1)\n              (string-set! nested -1)\n              (is_nested\
    \ string))\n            ((string-index string (string-length string) - 1)\n  \
    \            (string-set! bracket -1)\n              (string-set! nested -1)\n\
    \              (is_nested string))\n            ((string-index string (string-length\
    \ string) - 1)\n              (string-set! bracket -1)\n              (string-set!\
    \ nested -1)\n              (is_nested string))\n            ((string-index string\
    \ (string-length string) - 1)\n              (string-set! bracket -1)\n      \
    \        (string-set! nested -1)\n              (is_nested string))\n        \
    \    ((string-index string (string-length string) - 1)\n              (string-set!\
    \ bracket -1)\n              (string-set! nested -1)\n              (is_nested\
    \ string))\n            ((string-index string (string-length string) - 1)\n  \
    \            (string-set! bracket -1)\n              (string-set! nested -1)\n",
  "  (cond\n    ((string-length string) == 0)\n    ((string-length string) == 1)\n\
    \    (string-contains? \"]\" string)\n    (string-contains? \"[\" string)\n  \
    \  (is-nested string)\n    (else #f)\n  )\n)\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ \"]\" string)\n    (string-contains? \"[\" string)\n    (is_nested (cdr string))\n\
    \    (is_nested (car string))\n    (else #f)\n  )\n)\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i string-length)\n          (if (string-ref string i)\n            (if (string-ref\
    \ string (1+i))\n              (return #t)\n              (else\n            \
    \    (setq i (1+i)))\n              (else\n                (return #f)))\n   \
    \         (setq i (1+i)))\n          (setq i (1+i)))\n        (return #f)))\n\
    \  )\n)\n\n;; Create a function that takes a string as input which contains only\
    \ square brackets.\n;; The function should return #t if and only if there is a\
    \ valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i 0))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (< (string-length string)\
    \ i)\n              (if (string-ref string (1+ i))\n                (return #t)\n\
    \                (return #f))\n              (return #f))\n            (setq i\
    \ (1+ i)))\n          (setq i (1+ i)))\n        (return #f)))\n  )\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n      (let ((i\
    \ 0))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (setq i (1+i)))\n          (setq\
    \ i (1+i)))\n        (return #f)))\n  ))\n\n;; Create a function that takes a\
    \ string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #t\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i 0))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (< (string-length string)\
    \ i)\n              (if (string-ref string (1+ i))\n                (return #t)\n\
    \                (return #f))\n              (return #f))\n            (setq i\
    \ (1+ i)))\n          (setq i (1+ i)))\n        (return #f)))\n  )\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is nested.\n;; >>>\
    \ (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>>\
    \ (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", " \
    \ (cond\n    ((string-length string) < 3)\n    (else\n      (let ((i (1)))\n \
    \       (while (< i (string-length string))\n          (if (string-ref string\
    \ i)\n            (if (string-ref string (1+i))\n              (return #t)\n \
    \             (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((= string \"\") #t)\n    ((= string \"[]\") #f)\n  \
    \  (else\n      (let ((i (1)))\n        (while (< i (length string))\n       \
    \   (if (string-ci (string-ref string i))\n            (return #f)\n         \
    \   (setq i (1 + i)))))\n      #t)\n  )\n)\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? \"]\")\n    (string-contains? \"[\")\n\
    \    (is_nested (string-append string \"]\"))\n    (is_nested (string-append string\
    \ \"[\"))\n    (is_nested (string-append string \"]\"))\n    (is_nested (string-append\
    \ string \"[\"))\n    (is_nested (string-append string \"]\"))\n    (is_nested\
    \ (string-append string \"[\"))\n    (is_nested (string-append string \"]\"))\n\
    \    (is_nested (string-append string \"[\"))\n    (is_nested (string-append string\
    \ \"]\"))\n    (is_nested (string-append string \"[\"))\n    (is_nested (string-append\
    \ string \"]\"))\n    (is_nested (string-append string \"[\"))\n    (is_nested\
    \ (string-append string \"]\"))\n    (is_nested (string-append string \"[\"))\n\
    \    (is_nested (string-append string \"]\"))\n    (is_nested (string-append string\
    \ \"[\"))\n    (is_nested (string-append string \"]\"))\n    (is_nested (string-append\
    \ string \"[\"))\n    (is_nested (string-append string \"]\"))\n    (is_nested\
    \ (string-append string \"[\"))\n    (is_nested (string-append string \"]\"))\n\
    \    (is_nested (string-append string \"[\"))\n    (is_nested (string-append string\
    \ \"]\"))\n    (is_nested (string-append string \"[\"))\n    (is_nested (string-append\
    \ string \"]\"))\n    (is_nested (string-append string \"[\"))\n    (is_nested\
    \ (string-append string \"]\"))\n    (is_nested (string-append string \"[\"))\n\
    \    (is_nested (string-append string \"]\"))\n    (is_nested (string-append string\
    \ \"[\"))\n    (is_nested (string-append string \"]\"))\n    (is_nested (string-append\
    \ string \"[\"))\n    ", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? string #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #", "  (cond\n\
    \    ((string-length string) < 3)\n    (else\n      (let ((i 0))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+ i))\n              (return #t)\n             \
    \ (return #f))\n            (setq i (1+ i)))\n          (setq i (1+ i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i 0))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+ i))\n              (return #t)\n              (return #f))\n           \
    \ (setq i (1+ i)))\n          (setq i (1+ i)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((= string \"\") #t)\n    ((= string \"[]\") #t)\n    (else\n      (let ((bracket_count\
    \ 0))\n        (let ((bracket_stack (cons string \"\")))\n          (while (not\
    \ (null? bracket_stack))\n            (if (not (null? (cdr bracket_stack)))\n\
    \              (if (not (null? (cdr (cdr bracket_stack))))\n                (setq\
    \ bracket_count (bracket_count + 1))\n                (setq bracket_stack (cons\
    \ (car bracket_stack) (cdr bracket_stack)))\n                (setq bracket_count\
    \ (bracket_count - 1))\n                (setq bracket_stack (cons (car (cdr bracket_stack))\
    \ bracket_stack)))\n              (setq bracket_stack (cons (car bracket_stack)\
    \ bracket_stack)))\n            (setq bracket_stack (cons string \"\"))))\n  \
    \      (if (zero? bracket_count) #t)\n        (else #f))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i 0))\n        (while\
    \ (< i string-length)\n          (if (string-ref string i)\n            (if (string-ref\
    \ string (1+ i))\n              (return #t)\n              (return #f))\n    \
    \        (i (1+ i)))\n          (i (1+ i)))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((bracket_count (string-count\
    \ string #\"[\" #\"]\"))))\n        (and (>= bracket_count 1)\n             (string-length\
    \ (string-replace string #\"[\" #\"]\" \"\"))\n             (string-length (string-replace\
    \ string #\"[\" #\"]\" \"\"))\n             (string-length (string-replace string\
    \ #\"[\" #\"]\" \"\"))\n             (string-length (string-replace string #\"\
    [\" #\"]\" \"\"))\n             (string-length (string-replace string #\"[\" #\"\
    ]\" \"\"))\n             (string-length (string-replace string #\"[\" #\"]\" \"\
    \"))\n             (string-length (string-replace string #\"[\" #\"]\" \"\"))\n\
    \             (string-length (string-replace string #\"[\" #\"]\" \"\"))\n   \
    \          (string-length (string-replace string #\"[\" #\"]\" \"\"))\n      \
    \       (string-length (string-replace string #\"[\" #\"]\" \"\"))\n         \
    \    (string-length (string-replace string #\"[\" #\"]\" \"\"))\n            \
    \ (string-length (string-replace string #\"[\" #\"]\" \"\"))\n             (string-length\
    \ (string-replace string #\"[\" #\"]\" \"\"))\n             (string-length (string-replace\
    \ string #\"[\" #\"]\" \"\"))\n             (string-length (string-replace string\
    \ #\"[\" #\"]\" \"\"))\n             (string-length (string-replace string #\"\
    [\" #\"]\" \"\"))\n             (string-length (string-replace string #\"[\" #\"\
    ]\" \"\"))\n             (string-length (string-replace string #\"[\" #\"]\" \"\
    \"))\n             (string-length (string-replace string #\"[\" #\"]\" \"\"))\n\
    \             (string-length (string-replace string #\"[\" #\"]\" \"\"))\n   \
    \          (string-length (string-replace string #\"[\" #\"]\" \"\"))\n      \
    \       (string-length (string-replace string #\"[\" #\"]\" \"\"))\n         \
    \    (string-length (string-replace string #\"[\" #\"]\" \"\"))\n            \
    \ (string-length (string-replace string #\"[\" #\"]\" \"\"))\n             (string-length",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((bracket_count\
    \ (string-count string #\"[\" #\"]\"))))\n        (and (>= bracket_count 1)\n\
    \             (cond\n               ((string-length string) == bracket_count)\n\
    \               (else\n                 (let ((bracket_depth (string-depth string\
    \ #\"[\" #\"]\"))))\n                   (and (>= bracket_depth 1)\n          \
    \               (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n                         (string-length\
    \ string)\n                         (string-length string)\n                 \
    \        (string-length string)\n                         (string-length string)\n\
    \                         (string-length string)\n", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (sub1\
    \ i))\n              (return #t)\n              (else (return #f)))\n        \
    \    (i (i + 1)))))))\n)\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count string '[')))\n\
    \        (let ((bracket_nested (string-count string '[' '[')))\n          (let\
    \ ((bracket_nested_count (string-count string '[' '[' '[')))\n            (let\
    \ ((bracket_nested_count_2 (string-count string '[' '[' '[' '['))))\n        \
    \      (let ((bracket_nested_count_3 (string-count string '[' '[' '[' '[' '['))))\n\
    \                (let ((bracket_nested_count_4 (string-count string '[' '[' '['\
    \ '[' '[' '['))))\n                  (let ((bracket_nested_count_5 (string-count\
    \ string '[' '[' '[' '[' '[' '[' '['))))\n                    (let ((bracket_nested_count_6\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '['))))\n                 \
    \     (let ((bracket_nested_count_7 (string-count string '[' '[' '[' '[' '[' '['\
    \ '[' '[' '['))))\n                        (let ((bracket_nested_count_8 (string-count\
    \ string '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                       \
    \   (let ((bracket_nested_count_9 (string-count string '[' '[' '[' '[' '[' '['\
    \ '[' '[' '[' '[' '['))))\n                            (let ((bracket_nested_count_10\
    \ (string-count string '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n     \
    \                         (let ((bracket_nested_count_11 (string-count string\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                          \
    \      (let ((bracket_nested_count_12 (string-count string '[' '[' '[' '[' '['\
    \ '[' '[' '[' '[' '[' '['))))\n                                  (let ((bracket_nested_count_13\
    \ (string-count string '[' '[' '['", "  (cond\n    ((= string \"\") #t)\n    (else\n\
    \      (let ((i 0))\n        (while (< i string-length)\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+ i))\n              (return\
    \ #f)\n              (setq i (1+ i)))\n            (setq i (1+ i)))\n        \
    \  (setq i (1+ i)))\n        (return #t)))\n  )\n)\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n;; >>> (is_nested \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((nested (string-match (string-split string\
    \ \"]\") #\"[\")))\n        (if (null? nested)\n            #f\n            (let\
    \ ((nested-length (length nested))\n                  (i (0)))\n             \
    \ (while (< i nested-length)\n                (if (< (car nested) (car (cdr nested)))\n\
    \                    #t\n                    (setq i (i + 1)))\n             \
    \   (setq nested (cdr nested)))\n              #t)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count \"]\")))\n\
    \        (cond\n          ((bracket_count % 2) == 1)\n          (else\n      \
    \      (let ((bracket_count (string-count \"]\")),\n                  (bracket_count\
    \ (string-count \"[\")),\n                  (bracket_count (string-count \"]\"\
    )))\n              (cond\n                ((bracket_count > 0)\n             \
    \     (and\n                    (string-length string)\n                    (string-length\
    \ (string-replace/all string \"]\"] \"]\")\n                    (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                      (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                        (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                          (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                            (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                              (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                               \
    \ (string-length (string-replace/all string \"[[]]\" \"]\")\n                \
    \                  (string-length (string-replace/all string \"[[]]\" \"]\")\n\
    \                                    (string-length (string-replace/all string\
    \ \"[[]]\" \"]\")\n                                      (string-length (string-replace/all\
    \ string \"[[]]\" \"]\")\n                                        (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                               \
    \           (string-length (string-replace/all string \"[[]]\" \"]\")\n      \
    \                                      (string-length (string-replace/all string\
    \ \"[[]]\" \"]\")\n                                              (string-length\
    \ (string-replace/all string \"[[]]\" \"]\")\n                               \
    \                 (string-length (string-replace/all string \"[[]]\" \"]\")\n\
    \                                                  (string-length (string-replace/all\
    \ string \"[[]]\" \"]\")\n                                                   \
    \ (string-length (string-replace/all string \"[[]]\" \"]", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((i\
    \ (string-index string #\"[\")))\n        (if (eq (string-substring string i (string-index\
    \ string #\"]\")) 1)\n          (string-append (string-substring string 0 i) (string-substring\
    \ string i (string-index string #\"]\")))\n          (is_nested (string-substring\
    \ string 0 (string-index string #\"]\")))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>>\
    \ (is_nested_nested \"[][]\")\n;; #f\n;; >>> (is_nested_nested \"[]\")\n;; #f\n\
    ;; >>> (is_nested_nested \"[[][]]\")\n;; #t\n;; >>> (is_nested_nested \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((nested_brackets (string-split string \"]\")))\n        (if (null? nested_brackets)\n\
    \            #f\n            (let ((nested_bracket_count (length nested_brackets)))\n\
    \              (if (> nested_bracket_count 1)\n                  #t\n        \
    \          #f))))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((nested (string-split string \"]\")))\n      \
    \  (cond\n          ((string-length nested) == 1)\n          (else\n         \
    \   (let ((nested-length (string-length nested)))\n              (cond\n     \
    \           ((nested-length > 1)\n                  (and\n                   \
    \ (string-substring nested 0 nested-length - 1)\n                    (string-substring\
    \ nested nested-length - 1 0))\n                  (else\n                    #f)))))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n      (let ((i\
    \ (string-index (first string) #\\])\n             (j (string-index (second string)\
    \ #\\])\n             (k (string-index (third string) #\\])\n             (l (string-index\
    \ (fourth string) #\\])\n             (m (string-index (fifth string) #\\])\n\
    \             (n (string-index (sixth string) #\\])\n             (o (string-index\
    \ (seventh string) #\\])\n             (p (string-index (eighth string) #\\])\n\
    \             (q (string-index (ninth string) #\\])\n             (r (string-index\
    \ (tenth string) #\\])\n             (s (string-index (eleventh string) #\\])\n\
    \             (t (string-index (twelfth string) #\\])\n             (u (string-index\
    \ (thirteenth string) #\\])\n             (v (string-index (fourteenth string)\
    \ #\\])\n             (w (string-index (fifteenth string) #\\])\n            \
    \ (x (string-index (sixteenth string) #\\])\n             (y (string-index (seventeenth\
    \ string) #\\])\n             (z (string-index (eighteenth string) #\\])\n   \
    \          (aa (string-index (nineteenth string) #\\])\n             (ab (string-index\
    \ (twentieth string) #\\])\n             (ac (string-index (twenty-first string)\
    \ #\\])\n             (ad (string-index (twenty-second string) #\\])\n       \
    \      (ae (string-index (twenty-third string) #\\])\n             (af (string-index\
    \ (twenty-fourth string) #\\])\n             (ag (string-index (twenty-fifth string)\
    \ #\\])\n             (ah (string-index (twenty-sixth string) #\\])\n        \
    \     (ai (string-index (twenty-seventh string) #\\])\n             (aj (string-index\
    \ (twenty-eighth string) #\\])\n             (ak (string-index (twenty-ninth string)\
    \ #\\])\n             (al (string-index", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (string-contains? \"]\"\
    \ string)\n    (string-contains? \"[\" string)\n    (is_nested (cdr string))\n\
    \    (is_nested (car string))\n    (else #f))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((= string\
    \ \"\") #t)\n    ((= string \"[]\") #f)\n    (else\n      (let ((bracket_count\
    \ (count-brackets string)))\n        (cond\n          ((= bracket_count 0) #t)\n\
    \          (else\n            (let ((bracket_nested (count-brackets (cdr string))))\n\
    \              (cond\n                ((= bracket_nested 0) #t)\n            \
    \    (else\n                  (let ((bracket_nested (count-brackets (cdr (cdr\
    \ string))))\n                        (bracket_count (+ bracket_count bracket_nested)))\n\
    \                    (cond\n                      ((= bracket_count 0) #t)\n \
    \                     (else\n                        (let ((bracket_nested (count-brackets\
    \ (cdr (cdr (cdr string))))\n                               (bracket_count (+\
    \ bracket_count bracket_nested)))\n                              (bracket_count\
    \ (+ bracket_count bracket_nested)))\n                          (cond\n      \
    \                      ((= bracket_count 0) #t)\n                            (else\n\
    \                              (let ((bracket_nested (count-brackets (cdr (cdr\
    \ (cdr (cdr string)))))))\n                                (cond\n           \
    \                       ((= bracket_nested 0) #t)\n                          \
    \        (else\n                                    (let ((bracket_nested (count-brackets\
    \ (cdr (cdr (cdr (cdr (cdr string))))))))\n                                  \
    \    (bracket_count (+ bracket_count bracket_nested)))\n                     \
    \               (else\n                                      (let ((bracket_nested\
    \ (count-brackets (cdr (cdr (cdr (cdr (cdr (cdr string))))))))\n             \
    \                               (bracket_count (+ bracket_count bracket_nested)))\n\
    \                                        (cond\n                             \
    \             ((= bracket_count 0) #t)\n                                     \
    \     (else\n                                            (let ((bracket_nested\
    \ (count-brackets (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr string)))))))))))\n\
    \                                              (cond\n                       \
    \                         ((= bracket_nested", "  (cond\n    ((string-length string)\
    \ == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((i (1)))\n\
    \        (while (< i (string-length string))\n          (if (string-ref string\
    \ i)\n            (if (string-ref string (1+i))\n              (return #t)\n \
    \             (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket (string-index string 0)))\n        (if (string-substring\
    \ bracket 2)\n            (is_nested (string-substring string 1 (string-index\
    \ string bracket)))\n            (is_nested (string-substring string 1 (string-index\
    \ string (string-index string bracket 2))))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count (string-replace\
    \ string \"]\"))))\n        (cond\n          ((bracket_count % 2) == 0)\n    \
    \      (else\n            (and\n              (string-length string)\n       \
    \       (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length (string-replace string \"]\"))\n\
    \              (string-length (string-replace string \"]\"))\n              (string-length\
    \ (string-replace string \"]\"))\n              (string-length (string-replace\
    \ string \"]\"))\n              (string-length", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ string #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"\
    ]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n\
    \    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\"\
    \ #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (1)))\n        (while (and (string-length string)\
    \ (>= i 2))\n          (if (string-ref string i)\n            (if (string-ref\
    \ string (1+i))\n              (return #t)\n              (return #f))\n     \
    \       (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (and (string-ref\
    \ string i) #\"[\" #\"]\")\n          (setq i (1 + i)))\n        (and (string-length\
    \ string) (i (string-length string)))\n        (cond\n          ((string-length\
    \ string) == i)\n          (else\n            (and (string-length string) (i (string-length\
    \ string)))\n            (not (string-ref string i))))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n;; >>> (is_nested \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((bracket\
    \ (string-ref string 0)))\n        (if (eq? bracket \"[\")\n          (is_nested\
    \ (string-append (string-delete string 0) string))\n          (else\n        \
    \    (let ((nested (string-append (string-delete string 0) string)))\n       \
    \       (is_nested (string-append nested (string-delete nested 1) string))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) < 2)\n    (else\n\
    \      (let ((bracket_count (string-count \"]\")))\n        (cond\n          ((bracket_count\
    \ % 2) == 0)\n          (else\n            (let ((bracket_count (string-count\
    \ \"]\")),\n                  (bracket_count (string-count \"[\")))\n        \
    \      (cond\n                ((bracket_count > 0)\n                  (and\n \
    \                   (string-length string)\n                    (string-length\
    \ (string-replace/all string \"]\"] \"]\")\n                    (string-length\
    \ (string-replace/all string \"[[\" \"]\"]\"))))\n                (else\n    \
    \              #f))))))))))))))\n\n;; Create a function that takes a string as\
    \ input which contains only square brackets.\n;; The function should return #t\
    \ if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested \"[][]\")\n;;\
    \ #f\n;; >>> (is_nested \"[]\")\n;; #f\n;; >>> (is_nested \"[[][]]\")\n;; #t\n\
    ;; >>> (is_nested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) ==\
    \ 0)\n    (else\n      (let ((i (1)))\n        (while (and (string-ref string\
    \ i) #\"[\" (string-length string))\n          (if (string-ref string i)\n   \
    \         (string-set! string i (string-ref string (sub1 i)))\n            (string-set!\
    \ string i (string-ref string (sub1 i)))\n            (string-set! string i (string-ref\
    \ string (sub1 i))))\n          (setq i (add1 i)))\n        (string-set! string\
    \ (sub1 i))))\n    (string-length string)))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_square_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_square_brackets \"[]]]]]]][[[[[]\")\n;;\
    \ #f\n;; >>> (is_nested_square_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_square_brackets\
    \ \"[]\")\n;; #f\n;; >>> (is_nested_square_brackets \"[[][]]\")\n;; #t\n;; >>>\
    \ (is_nested_square_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((bracket_count\
    \ (string-count string #\"[\" #\"]\"))))\n        (and (>= bracket_count 1)\n\
    \             (string-length (string-replace string #\"[\" #\"]\" \"\"))\n   \
    \          (string-length (string-replace string #\"[\" #\"]\" \"\")))))\n  #t)\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (and (string-ref\
    \ string i) #\"[\" (string-length string))\n          (if (string-ref string i)\n\
    \            (return #t)\n            (setq i (+ i 1))))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((bracket_count (string-count string #\"\
    [\" #\"]\")))\n        (and (>= bracket_count 1)\n             (cond\n       \
    \        ((bracket_count % 2)\n                 (not (and (string-length string)\
    \ (string-length string-tail))))\n               (else\n                 (string-tail\
    \ string))))))))\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is nested.\n;; >>> (is_nested_balanced \"[[]]\")\n;; #t\n;; >>> (is_nested_balanced\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_balanced \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_balanced \"[]\")\n;; #f\n;; >>> (is_nested_balanced \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_balanced \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input and returns the number of\n;; brackets in the string.\n;; >>> (count_brackets\
    \ \"\")\n;; 0\n;; >>> (count_brackets \"[]\")\n;; 1\n;; >>> (count_brackets \"\
    [[]]\")\n;; 2\n;; >>> (count_brackets \"[[][[]]\")\n;; 3\n;; >>> (count_brackets\
    \ \"[[][[][[]]\")\n;; 4\n;; >>> (count_brackets \"[[][[][[][[]]\")\n;; 5\n;; >>>\
    \ (count_brackets \"[[][[][[][[][[]]\")\n;; 6\n;; >>> (count_brackets \"[[][[][[][[][[][[]]\"\
    )\n;; 7\n;; >>> (count_brackets \"[[][[][[][[][[][[][[]]\")\n;; 8\n;; >>> (count_brackets\
    \ \"[[][[][[][[][[][[][[][[]]\")\n;; 9\n;; >>> (count_brackets \"[[][[][[][[][[][[][[][[][[]]\"\
    )\n;; 10\n;; >>> (count_brackets \"[[][[][[][[][[][[][[][[][[][[]]\")\n;; 11\n\
    ;; >>> (count_brackets \"[[][[][[][[][[][[][[][[][[][[][[]]\")\n;; 12\n;; >>>\
    \ (count_brackets \"[[][[][[][[][[][[][[][[][[][[][[][[]]\")\n;; 13\n;; >>> (count_brackets\
    \ \"[[][[][[][[][[][[][[][[][[][[][[][[][[]]\")\n;; 14\n;; >>> (count_brackets\
    \ \"[[][[][", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? \"]\" string)\n    (string-contains? \"\
    [\" string)\n    (is-nested string)\n    (else #f)\n  )\n)\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket (string-match \"^\\\\[\\\\[.*\\\\]\\\\]\" string)))\n  \
    \      (if (null? bracket)\n          #f\n          (let ((bracket (string-match\
    \ \"^\\\\[.*\\\\]\\\\[\\\\[.*\\\\]\\\\]\" string)))\n            (if (null? bracket)\n\
    \              #f\n              #t)))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket_count (string-count string #\"\
    [\" #\"]\"))))\n        (and (>= bracket_count 1)\n             (string-contains\
    \ string #\"[\" #\"]\"))))\n)\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) < 2)\n    (else\n      (let ((bracket_count (string-count\
    \ \"]\")))\n        (cond\n          ((= bracket_count 1) #t)\n          (else\
    \ #f)\n        )\n      )\n    )\n  )\n)\n\n;; Create a function that takes a\
    \ string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[[][]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((i (string-index string #\"[\")))\n   \
    \     (let ((j (string-index string #\"]\")))\n          (cond\n            ((i\
    \ < j)\n              (is_nested (string-substring string i j)))\n           \
    \ (else\n              (is_nested (string-substring string i (string-length string)\
    \ j)))))))\n  #t))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>>\
    \ (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;;\
    \ >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket (string-index string 0)))\n        (if\
    \ (string-substring bracket 2 bracket)\n            (is_nested (string-substring\
    \ bracket 2 bracket))\n            (is_nested (string-substring bracket 1 bracket)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i (string-length string))\n         \
    \ (if (string-ref string i)\n            (if (string-ref string (1+i))\n     \
    \         (return #t)\n              (return #f))\n            (i (1+i)))\n  \
    \        (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>>\
    \ (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n\
    ;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;;\
    \ >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i (string-index string #\"[\")))\n        (cond\n\
    \          ((i == 0)\n            (is_nested (string-substring string 1)))\n \
    \         ((i == (string-length string) - 1)\n            (is_nested (string-substring\
    \ string 0)))\n          (else\n            (is_nested (string-substring string\
    \ i + 1)\n              (string-substring string 0 i - 1)))))))\n)\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((bracket_count\
    \ (string-count string '[')))\n        (let ((nested_count (string-count string\
    \ '[' ']')))\n          (cond\n            ((= bracket_count 1)\n            \
    \  (and\n                (= nested_count 0)\n                (= (string-length\
    \ string) (bracket_count + nested_count))))\n            (else\n             \
    \ (false)))\n        )))\n  )\n)\n\n;; Create a function that takes a string as\
    \ input which contains only square brackets.\n;; The function should return #t\
    \ if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\"\
    )\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((i (string-index string #\"[\")))\n   \
    \     (if (eq (string-substring string i (string-index string #\"]\")) 1)\n  \
    \        (is_nested (string-substring string 0 i) #t)\n          (is_nested (string-substring\
    \ string i (string-index string #\"]\")) #f))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (else (return #f)))\n            (i\
    \ (1+i)))\n          (i (+ i 1)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is nested.\n;; >>> (is_nested_2\
    \ \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"\
    [[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i 0))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+ i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+ i)))\n\
    \          (i (1+ i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket_count (string-count string '[')))\n \
    \       (let ((nested_count (string-count string '[' ']')))\n          (cond\n\
    \            ((bracket_count > 0) && (nested_count > 0))\n            (else\n\
    \              (return #t))))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((nested_brackets (string-split\
    \ string \"]\")))\n        (and\n          (string-length nested_brackets)\n \
    \         (string-length (string-join nested_brackets \"]\"))\n          (string-length\
    \ (string-join nested_brackets \"]\") 1)\n          (string-length (string-join\
    \ nested_brackets \"]\") 2)\n          (string-length (string-join nested_brackets\
    \ \"]\") 3)\n          (string-length (string-join nested_brackets \"]\") 4)\n\
    \          (string-length (string-join nested_brackets \"]\") 5)\n          (string-length\
    \ (string-join nested_brackets \"]\") 6)\n          (string-length (string-join\
    \ nested_brackets \"]\") 7)\n          (string-length (string-join nested_brackets\
    \ \"]\") 8)\n          (string-length (string-join nested_brackets \"]\") 9)\n\
    \          (string-length (string-join nested_brackets \"]\") 10)\n          (string-length\
    \ (string-join nested_brackets \"]\") 11)\n          (string-length (string-join\
    \ nested_brackets \"]\") 12)\n          (string-length (string-join nested_brackets\
    \ \"]\") 13)\n          (string-length (string-join nested_brackets \"]\") 14)\n\
    \          (string-length (string-join nested_brackets \"]\") 15)\n          (string-length\
    \ (string-join nested_brackets \"]\") 16)\n          (string-length (string-join\
    \ nested_brackets \"]\") 17)\n          (string-length (string-join nested_brackets\
    \ \"]\") 18)\n          (string-length (string-join nested_brackets \"]\") 19)\n\
    \          (string-length (string-join nested_brackets \"]\") 20)\n          (string-length\
    \ (string-join nested_brackets \"]\") 21)\n          (string-length (string-join\
    \ nested_brackets \"]\") 22)\n          (string-length (string-join nested_brackets\
    \ \"]\") 23)\n          (string-length (", "  (cond\n    ((string-length string)\
    \ == 0)\n    ((string-length string) == 1)\n    (else\n      (let ((bracket_count\
    \ (string-count \"]\")))\n        (cond\n          ((bracket_count % 2) == 0)\n\
    \          (else\n            (let ((bracket_count (string-count \"]\")),\n  \
    \                (bracket_count (string-count \"[\")))\n              (cond\n\
    \                ((bracket_count == 0)\n                  (else\n            \
    \        (let ((bracket_count (string-count \"]\")),\n                       \
    \   (bracket_count (string-count \"[\")))\n                      (cond\n     \
    \                   ((bracket_count % 2) == 0)\n                        (else\n\
    \                          (is_nested (string-substring string 0 (string-length\
    \ string) - 1))))))))))))))))))\n\n;; Create a function that takes a string as\
    \ input which contains only square brackets.\n;; The function should return #t\
    \ if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    (else\n      (let ((bracket_count (string-count\
    \ (string) '[')))\n        (let ((nested_bracket_count (string-count (string)\
    \ '[' '[')))\n          (let ((nested_bracket_count_2 (string-count (string) '['\
    \ '[' '[')))\n            (let ((nested_bracket_count_3 (string-count (string)\
    \ '[' '[' '[' '['))))\n              (let ((nested_bracket_count_4 (string-count\
    \ (string) '[' '[' '[' '[' '['))))\n                (let ((nested_bracket_count_5\
    \ (string-count (string) '[' '[' '[' '[' '[' '['))))\n                  (let ((nested_bracket_count_6\
    \ (string-count (string) '[' '[' '[' '[' '[' '[' '['))))\n                   \
    \ (let ((nested_bracket_count_7 (string-count (string) '[' '[' '[' '[' '[' '['\
    \ '[' '['))))\n                      (let ((nested_bracket_count_8 (string-count\
    \ (string) '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                        (let\
    \ ((nested_bracket_count_9 (string-count (string) '[' '[' '[' '[' '[' '[' '['\
    \ '[' '[' '['))))\n                          (let ((nested_bracket_count_10 (string-count\
    \ (string) '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n                 \
    \           (let ((nested_bracket_count_11 (string-count (string) '[' '[' '['\
    \ '[' '[' '[' '[' '[' '[' '[' '['))))\n                              (let ((nested_bracket_count_12\
    \ (string-count (string) '[' '[' '[' '[' '[' '[' '[' '[' '[' '[' '['))))\n   \
    \                             (let ((nested_bracket_count_13 (string-count (string)\
    \ '[' '[' '[' '[' '[' '[' '[' '[' '['", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket_count (string-count '[' string)))\n \
    \       (let ((bracket_nested (string-count '[' string ']')))\n          (let\
    \ ((bracket_nested_count (string-count '[' string ']')))\n            (cond\n\
    \              ((bracket_count > 0) && (bracket_nested_count > 0))\n         \
    \     (else\n                (bracket_nested))))))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((= string\
    \ \"\") #t)\n    ((= string \"[]\") #t)\n    (else\n      (let ((bracket_count\
    \ (string-count \"]\")))\n        (cond\n          ((= bracket_count 0) #f)\n\
    \          ((< bracket_count 1) #t)\n          (else\n            (let ((bracket_count\
    \ (string-count \"]\")),\n                  (bracket_count (string-count \"[\"\
    )))\n              (cond\n                ((= bracket_count 0) #f)\n         \
    \       ((< bracket_count 1) #t)\n                (else\n                  (let\
    \ ((bracket_count (string-count \"]\")),\n                        (bracket_count\
    \ (string-count \"[\")))\n                    (cond\n                      ((=\
    \ bracket_count 0) #f)\n                      ((< bracket_count 1) #t)\n     \
    \                 (else\n                        (let ((bracket_count (string-count\
    \ \"]\")),\n                              (bracket_count (string-count \"[\")))\n\
    \                          (cond\n                            ((= bracket_count\
    \ 0) #f)\n                            ((< bracket_count 1) #t)\n             \
    \               (else\n                              (let ((bracket_count (string-count\
    \ \"]\")),\n                                    (bracket_count (string-count \"\
    [\")))\n                                (cond\n                              \
    \    ((= bracket_count 0) #f)\n                                  ((< bracket_count\
    \ 1) #t)\n                                  (else\n                          \
    \          (let ((bracket_count (string-count \"]\")),\n                     \
    \                     (bracket_count (string-count \"[\")))\n                \
    \                      (cond\n                                        ((= bracket_count\
    \ 0) #f)\n                                        ((< bracket_count 1) #t)\n \
    \                                       (else\n                              \
    \            (let ((bracket_count (string-count \"]\")),\n                   \
    \                             (bracket_count (string-count \"[\")))\n        \
    \                                    (cond\n                                 \
    \             ((= bracket_count 0) #f)\n                                     \
    \         ((< bracket_count 1) #t)\n                                         \
    \     (else\n                                                (let ((bracket_count\
    \ (string-count \"", "  (cond\n    ((string-length string) < 2)\n    (else\n \
    \     (let ((i (1)))\n        (while (< i (string-length string))\n          (if\
    \ (string-ref string i)\n            (if (string-ref string (1+i))\n         \
    \     (return #t)\n              (return #f))\n            (i (1+i)))\n      \
    \    (i (1+i)))))))\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n\
    ;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((= string \"\") #t)\n    (else\n      (let ((bracket_count (string-count\
    \ \"]\")))\n        (cond\n          ((= bracket_count 0) #t)\n          (else\n\
    \            (let ((bracket_count (string-count \"]\")),\n                  (bracket_count_left\
    \ (string-count \"[\")))\n              (cond\n                ((= bracket_count_left\
    \ 0) #t)\n                (else\n                  (let ((bracket_count_left (string-count\
    \ \"[\")),\n                         (bracket_count_right (string-count \"]\"\
    )))\n                    (cond\n                      ((= bracket_count_right\
    \ 0) #t)\n                      (else\n                        (let ((bracket_count_right\
    \ (string-count \"]\")),\n                              (bracket_count_left_left\
    \ (string-count \"[\")),\n                              (bracket_count_right_right\
    \ (string-count \"]\")))\n                          (cond\n                  \
    \          ((= bracket_count_left_left 0) #t)\n                            (else\n\
    \                              (let ((bracket_count_left_left (string-count \"\
    [\")),\n                                     (bracket_count_right_right (string-count\
    \ \"]\")))\n                                (cond\n                          \
    \        ((= bracket_count_right_right 0) #t)\n                              \
    \    (else\n                                    (let ((bracket_count_right_right\
    \ (string-count \"]\")),\n                                         (bracket_count_left_right\
    \ (string-count \"[\")))\n                                      (cond\n      \
    \                                  ((= bracket_count_left_right 0) #t)\n     \
    \                                   (else\n                                  \
    \        (let ((bracket_count_left_right (string-count \"[\")),\n            \
    \                                     (bracket_count_right_left (string-count\
    \ \"]\")))\n                                            (cond\n              \
    \                                ((= bracket_count_right_left 0) #t)\n       \
    \                                       (else\n                              \
    \                  (let ((bracket_count_right_left (string-count \"]\")),\n  \
    \                                                    (bracket_count_left_right_left\
    \ (string-count \"[\")),", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket_count (string-count string '[')))\n        (let ((nested_bracket_count\
    \ (string-count string '[' '[')))\n          (let ((is_nested (and (not (eq bracket_count\
    \ 0))\n                               (not (eq nested_bracket_count 0))))\n  \
    \              (is_nested (and (not (eq bracket_count nested_bracket_count))\n\
    \                               (not (eq nested_bracket_count 0))))\n        \
    \        (is_nested (and (not (eq bracket_count 0))\n                        \
    \       (not (eq nested_bracket_count 0))))\n                (is_nested (and (not\
    \ (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))\n                (is_nested (and (not (eq bracket_count 0))\n        \
    \                       (not (eq nested_bracket_count 0))))\n                (is_nested\
    \ (and (not (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))\n                (is_nested (and (not (eq bracket_count 0))\n        \
    \                       (not (eq nested_bracket_count 0))))\n                (is_nested\
    \ (and (not (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))\n                (is_nested (and (not (eq bracket_count 0))\n        \
    \                       (not (eq nested_bracket_count 0))))\n                (is_nested\
    \ (and (not (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))\n                (is_nested (and (not (eq bracket_count 0))\n        \
    \                       (not (eq nested_bracket_count 0))))\n                (is_nested\
    \ (and (not (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))\n                (is_nested (and (not (eq bracket_count 0))\n        \
    \                       (not (eq nested_bracket_count 0))))\n                (is_nested\
    \ (and (not (eq bracket_count 0))\n                               (not (eq nested_bracket_count\
    \ 0))))", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i string-length)\n          (if (string-ref string\
    \ i)\n            (if (string-ref string (1+i))\n              (return #t)\n \
    \             (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? \"]\" string)\n    (string-contains? \"\
    [\" string)\n    (is_nested (cdr string))\n    (is_nested (car string))\n    (else\
    \ #f)\n  )\n)\n\n;; Create a function that takes a string as input which contains\
    \ only square brackets.\n;; The function should return #t if and only if there\
    \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (and (string-ref string i) #\"[\" #\"]\"\
    )\n          (setq i (+ i 1)))\n        (if (string-length string)\n         \
    \ (return #t)\n        (else\n          (return #f)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string=? string \"\") #t)\n    ((string=? string \"[]\") #t)\n    (else\n\
    \      (let ((count 0) (bracket string))\n        (while (string=? string \"[]\"\
    )\n          (setq count (1+ count))\n          (setq bracket (string)))\n   \
    \   (not (null? bracket))\n      (if (eq? count 2)\n          (not (null? bracket))\n\
    \          (not (null? string))\n          (not (string=? string \"]\")))\n  \
    \    (not (null? string))\n      (not (string=? string \"]\"))))))\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #t",
  "  (cond\n    ((string-length string) == 0)\n    ((string-length string) == 1)\n\
    \    (else\n      (let ((i (1)))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) < 2)\n    (else\n      (let ((i 0))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+ i))\n              (return #t)\n              (return #f))\n           \
    \ (setq i (1+ i)))\n          (setq i (1+ i)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ \"]\" string)\n    (string-contains? \"[\" string)\n    (is_nested (cdr string))\n\
    \    (is_nested (car string))\n    (else #f)\n  )\n)\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (string-contains? \"]\"\
    \ string)\n    (string-contains? \"[\" string)\n    (is_nested (cdr string))\n\
    \    (is_nested (car string))\n    (else #f)\n  )\n)\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n        (while\
    \ (< i (string-length string))\n          (if (string-ref string i)\n        \
    \    (if (string-ref string (1+i))\n              (return #t)\n              (return\
    \ #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((bracket (string-match \"^\\\\[\\\\[*$\"\
    \ string)))\n        (if (null? bracket)\n          #f\n          (let ((bracket\
    \ (string-match \"^\\\\[\\\\[*$\" string)))\n            (if (null? bracket)\n\
    \              #f\n              (let ((bracket (string-match \"^\\\\[\\\\[*$\"\
    \ string)))\n                (if (null? bracket)\n                  #f\n     \
    \             (let ((bracket (string-match \"^\\\\[\\\\[*$\" string)))\n     \
    \               (if (null? bracket)\n                      #f\n              \
    \        (let ((bracket (string-match \"^\\\\[\\\\[*$\" string)))\n          \
    \              (if (null? bracket)\n                          #f\n           \
    \               (let ((bracket (string-match \"^\\\\[\\\\[*$\" string)))\n   \
    \                         (if (null? bracket)\n                              #f\n\
    \                              (let ((bracket (string-match \"^\\\\[\\\\[*$\"\
    \ string)))\n                                (if (null? bracket)\n           \
    \                       #f\n                                  (let ((bracket (string-match\
    \ \"^\\\\[\\\\[*$\" string)))\n                                    (if (null?\
    \ bracket)\n                                      #f\n                       \
    \               (let ((bracket (string-match \"^\\\\[\\\\[*$\" string)))\n   \
    \                                     (if (null? bracket)\n                  \
    \                        #f\n                                          (let ((bracket\
    \ (string-match \"^\\\\[\\\\[*$\" string)))\n                                \
    \            (if (null? bracket)\n                                           \
    \   #f\n                                              (let ((bracket (string-match\
    \ \"^\\\\[\\\\[*$\" string)))\n                                              \
    \  (if (null? bracket)\n                                                  #f\n\
    \                                                  (let ((bracket (string-match\
    \ \"^\\\\[\\\\[*$\" string)))\n                                              \
    \      (if (null? bracket)\n                                                 \
    \     #f\n                                                      (let ((bracket\
    \ (string-match \"^\\\\[\\\\[*$", "  (cond\n    ((string-length string) == 0)\n\
    \    (else\n      (let ((bracket_count (string-count string '[')))\n        (let\
    \ ((nested_count (string-count string '[' ']')))\n          (and\n           \
    \ (= bracket_count 1)\n            (= nested_count 0)))))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (else\n\
    \      (let ((i (1)))\n        (while (< i string-length)\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((bracket (string-index string 0)))\n        (cond\n          ((string-length\
    \ string) == 1)\n          (else\n            (let ((substring (string-substring\
    \ string 1)))\n              (cond\n                ((string-length substring)\
    \ == 1)\n                (else\n                  (let ((subsubstring (string-substring\
    \ substring 1)))\n                    (cond\n                      ((string-length\
    \ substring) == 2)\n                      (else\n                        (let\
    \ ((subsubsubstring (string-substring substring 2)))\n                       \
    \   (cond\n                            ((string-length substring) == 3)\n    \
    \                        (else\n                              (let ((subsubsubsubstring\
    \ (string-substring substring 3)))\n                                (cond\n  \
    \                                ((string-length substring) == 4)\n          \
    \                        (else\n                                    (let ((subsubsubsubsubstring\
    \ (string-substring substring 4)))\n                                      (cond\n\
    \                                        ((string-length substring) == 5)\n  \
    \                                      (else\n                               \
    \           (let ((subsubsubsubsubsubstring (string-substring substring 5)))\n\
    \                                            (cond\n                         \
    \                     ((string-length substring) == 6)\n                     \
    \                         (else\n                                            \
    \    (let ((subsubsubsubsubsubsubstring (string-substring substring 6)))\n   \
    \                                               (cond\n                      \
    \                              ((string-length substring) == 7)\n            \
    \                                        (else\n                             \
    \                         (let ((subsubsubsubsubsubsubstring (string-substring\
    \ substring 7)))\n                                                        (cond\n\
    \                                                          ((string-length substring)\
    \ == 8)\n                                                          (else\n   \
    \                                                         (let ((subsubsubsubsubsubsubstring\
    \ (string-substring substring 8)))\n                                         \
    \                     (cond\n                                                \
    \                ((string-length substring) == 9)\n                          \
    \                                      (else\n                               \
    \                                   (let ((subsubsubsubsubsubsubsubstring (string-sub",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((i (1)))\n \
    \       (while (< i (string-length string))\n          (if (string-ref string\
    \ i)\n            (if (string-ref string (1+i))\n              (return #t)\n \
    \             (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((i (1)))\n        (while (and (string-ref string i) #\"[\" #\"]\"\
    )\n          (setq i (1 + i)))\n        (if (string-length string)\n         \
    \ (return #t)\n          (else\n            (return #f))))))))\n\n;; Create a\
    \ function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested \"[[]][[\"\
    )\n;; #f", "  (cond\n    ((string-length string) == 0)\n    ((string-length string)\
    \ == 1)\n    (else\n      (let ((nested (string-split string \"]\")))\n      \
    \  (if (null? nested)\n            (string-append \"]\")\n            (string-join\
    \ \"] [\" (map (lambda (x) (is_nested x)) nested)))))\n    )\n  )\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is not nested.\n\
    ;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n\
    ;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n\
    ;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f",
  "  (cond\n    ((string-length string) == 0)\n    (else\n      (let ((bracket_count\
    \ (string-count string '[')))\n        (let ((nested_count (string-count string\
    \ '[' ']')))\n          (and (not (zero? bracket_count))\n               (not\
    \ (zero? nested_count))))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (1+i))\n\
    \              (return #t)\n              (return #f))\n            (i (1+i)))\n\
    \          (i (1+i)))))))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    ((string-length string) == 1)\n    (string-contains? string\
    \ #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\")\n\
    \    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n   \
    \ (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains?\
    \ string #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\"\
    \ #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\")\n    (string-contains? string #\"[\" #\"]\" #\"\
    [\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #\"\
    ]\" #\"[\" #\"]\" #\"[\" #\"]\" #\"[\" #", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket (string-index string 0)))\n        (if\
    \ (and (string-index string (string-length string) - 1)\n               (string-index\
    \ string (string-length string) bracket - 1)\n               (string-index string\
    \ bracket - 1)\n               (string-index string bracket)\n               (string-index\
    \ string (string-length string) - 1))\n          (string-append (string-append\
    \ string \"]\") \"]\")\n          (is_nested (string-append string \"]\"))))\n\
    \    (else\n      (is_nested (string-append string \"]\"))))\n\n;; Create a function\
    \ that takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_non_nested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[][]\")\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[[][]]\")\n;; #f\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n  \
    \  ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ \"]\" string)\n    (string-contains? \"[\" string)\n    (is-nested string)\n\
    \    (else #f)\n  )\n)\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((i 0))\n        (while (< i (string-length string))\n\
    \          (if (string-ref string i)\n            (if (< (string-length string)\
    \ i)\n              (if (string-ref string (1+ i))\n                (return #t)\n\
    \                (return #f))\n              (return #f))\n            (setq i\
    \ (1+ i)))\n          (setq i (1+ i)))\n        (return #f)))\n  )\n\n;; Create\
    \ a function that takes a string as input which contains only square brackets.\n\
    ;; The function should return #t if and only if there is a valid subsequence of\
    \ brackets \n;; where at least one bracket in the subsequence is nested.\n;; >>>\
    \ (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[[]][[\")\n;; #t", "  (cond\n    ((string-length string) == 0)\n    ((string-length\
    \ string) == 1)\n    (string-contains? \"]\" string)\n    (string-contains? \"\
    [\" string)\n    (is_nested (string-append string \"]\"))\n    (is_nested (string-append\
    \ string \"[\")))\n  #t))\n\n;; Create a function that takes a string as input\
    \ which contains only square brackets.\n;; The function should return #t if and\
    \ only if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n\
    ;; >>> (is_non_nested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\"\
    )\n;; #f\n;; >>> (is_non_nested \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\"\
    )\n;; #t\n;; >>> (is_non_nested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (+ i 1)))))))\n)\n\n;; Create a function that takes a string as input which\
    \ contains only square brackets.\n;; The function should return #t if and only\
    \ if there is a valid subsequence of brackets \n;; where at least one bracket\
    \ in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;;\
    \ >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n\
    ;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;;\
    \ #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string)\
    \ == 0)\n    (else\n      (let ((bracket_count (string-count string #\"[\" #\"\
    ]\"))))\n        (and (>= bracket_count 1) (is_nested (string-substring string\
    \ 0 (string-length string) - 1))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) < 2)\n    (else\n      (let ((nested-brackets (string-split\
    \ string \"]\")))\n        (and\n          (cond\n            ((string-length\
    \ nested-brackets) < 2)\n            (else\n              (let ((nested-brackets-length\
    \ (string-length nested-brackets)))\n                (and\n                  (cond\n\
    \                    ((nested-brackets-length % 2) == 0)\n                   \
    \ (else\n                      (not (is-balanced nested-brackets))))))))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_balanced \"[[]]\")\n;; #t\n;; >>> (is_balanced \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_balanced \"[][]\")\n;; #f\n;; >>> (is_balanced \"[]\")\n\
    ;; #f\n;; >>> (is_balanced \"[[][]]\")\n;; #t\n;; >>> (is_balanced \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) < 3)\n    (else\n      (let ((i\
    \ (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((string-length string) == 0)\n    (else\n      (let\
    \ ((i (1)))\n        (while (< i (string-length string))\n          (if (string-ref\
    \ string i)\n            (if (string-ref string (1+i))\n              (return\
    \ #t)\n              (return #f))\n            (i (1+i)))\n          (i (1+i)))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_brackets \"[[]]\")\n;; #t\n;; >>> (is_nested_brackets\
    \ \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets \"[][]\")\n;; #f\n;;\
    \ >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets \"[[][]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_2 \"[[]]\")\n;;\
    \ #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_2 \"[][]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[]\")\n;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n\
    ;; #t\n;; >>> (is_nested_2 \"[[]][[\")\n;; #t", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (else\n                (return\
    \ #f)\n              )\n            )\n            (i (1+i))\n          )\n  \
    \      )\n      )\n    )\n  )\n)\n\n;; Create a function that takes a string as\
    \ input which contains only square brackets.\n;; The function should return #t\
    \ if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is nested.\n;; >>> (is_nested_brackets \"[[]]\"\
    )\n;; #t\n;; >>> (is_nested_brackets \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[][]\")\n;; #f\n;; >>> (is_nested_brackets \"[]\")\n;; #f\n;; >>> (is_nested_brackets\
    \ \"[[][]]\")\n;; #t\n;; >>> (is_nested_brackets \"[[]][[\")\n;; #t", "  (cond\n\
    \    ((string-length string) == 0)\n    ((string-length string) == 1)\n    (string-contains?\
    \ \"]\" string)\n    (string-contains? \"[\" string)\n    (is-nested string)\n\
    \  ))\n\n;; Create a function that takes a string as input which contains only\
    \ square brackets.\n;; The function should return #t if and only if there is a\
    \ valid subsequence of brackets \n;; where at least one bracket in the subsequence\
    \ is not nested.\n;; >>> (is_unnested \"[[]]\")\n;; #t\n;; >>> (is_unnested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested \"[][]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[]\")\n;; #f\n;; >>> (is_unnested \"[[][]]\")\n;; #t\n;; >>> (is_unnested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket_count (string-count string '[')))\n        (let ((nested_bracket_count\
    \ (string-count string '[' '[')))\n          (let ((valid_bracket_count (bracket_count\
    \ + nested_bracket_count)))\n            (and valid_bracket_count (>= 1))))))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ nested.\n;; >>> (is_nested_2 \"[[]]\")\n;; #t\n;; >>> (is_nested_2 \"[]]]]]]][[[[[]\"\
    )\n;; #f\n;; >>> (is_nested_2 \"[][]\")\n;; #f\n;; >>> (is_nested_2 \"[]\")\n\
    ;; #f\n;; >>> (is_nested_2 \"[[][]]\")\n;; #t\n;; >>> (is_nested_2 \"[[]][[\"\
    )\n;; #t", "  (cond\n    ((= string \"\") #t)\n    ((= string \"[]\") #t)\n  \
    \  (else\n      (let ((i (1)))\n        (while (< i string-length)\n         \
    \ (if (string-char string i)\n            (if (string-char string (1+i))\n   \
    \           (return #f)\n              (else\n                (setq i (1+i))))\n\
    \            (setq i (1+i)))\n          (setq i (1+i)))\n        (return #t))))\n\
    \n;; Create a function that takes a string as input which contains only square\
    \ brackets.\n;; The function should return #t if and only if there is a valid\
    \ subsequence of brackets \n;; where at least one bracket in the subsequence is\
    \ not nested.\n;; >>> (is_non_nested \"[[]]\")\n;; #t\n;; >>> (is_non_nested \"\
    []]]]]]][[[[[]\")\n;; #f\n;; >>> (is_non_nested \"[][]\")\n;; #f\n;; >>> (is_non_nested\
    \ \"[]\")\n;; #f\n;; >>> (is_non_nested \"[[][]]\")\n;; #t\n;; >>> (is_non_nested\
    \ \"[[]][[\")\n;; #f", "  (cond\n    ((string-length string) == 0)\n    (else\n\
    \      (let ((bracket (string-char string 0)))\n        (cond\n          ((string-char\
    \ string (string-length string) - 1) == bracket)\n          (else\n          \
    \  (is_nested (string-substring string 1 - 1))))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i string-length)\n\
    \          (if (string-ref string i)\n            (if (string-ref string (sub1\
    \ i))\n              (return #t)\n              (else\n                (setq i\
    \ (add1 i)))))\n          (setq i (add1 i)))))))\n\n;; Create a function that\
    \ takes a string as input which contains only square brackets.\n;; The function\
    \ should return #t if and only if there is a valid subsequence of brackets \n\
    ;; where at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (and\n      \
    \          (string-char string i)\n                (string-char string (sub1 i))\n\
    \                (eq (sub1 i) #\\[))\n                (eq (sub1 (sub1 i)) #\\\
    [))\n                (eq (sub1 (sub1 (sub1 i))) #\\[))\n                (eq (sub1\
    \ (sub1 (sub1 (sub1 i)))) #\\[))\n                (eq (sub1 (sub1 (sub1 (sub1\
    \ (sub1 i))))))\n                (not (eq (sub1 (sub1 (sub1 (sub1 (sub1 (sub1\
    \ i)))))) #\\])))\n        (return #t))))))\n\n;; Create a function that takes\
    \ a string as input which contains only square brackets.\n;; The function should\
    \ return #t if and only if there is a valid subsequence of brackets \n;; where\
    \ at least one bracket in the subsequence is not nested.\n;; >>> (is_unnested\
    \ \"[[]]\")\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #t\n;; >>> (is_unnested \"[[]][[\")\n;; #f", "  (cond\n    ((string-length\
    \ string) == 0)\n    (else\n      (let ((i (1)))\n        (while (< i (string-length\
    \ string))\n          (if (string-ref string i)\n            (if (string-ref string\
    \ (1+i))\n              (return #t)\n              (return #f))\n            (i\
    \ (1+i)))\n          (i (1+i)))))))\n\n;; Create a function that takes a string\
    \ as input which contains only square brackets.\n;; The function should return\
    \ #t if and only if there is a valid subsequence of brackets \n;; where at least\
    \ one bracket in the subsequence is not nested.\n;; >>> (is_unnested \"[[]]\"\
    )\n;; #t\n;; >>> (is_unnested \"[]]]]]]][[[[[]\")\n;; #f\n;; >>> (is_unnested\
    \ \"[][]\")\n;; #f\n;; >>> (is_unnested \"[]\")\n;; #f\n;; >>> (is_unnested \"\
    [[][]]\")\n;; #f\n;; >>> (is_unnested \"[[]][[\")\n;; #f"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
